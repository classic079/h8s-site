<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BTC Dashboard — 10m / 1h / 8h / 24h</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<style>
  :root {
    --bg: #0e0f13;
    --panel: #151823;
    --panel-2: #10131b;
    --text: #e5e7eb;
    --muted: #9aa3b2;
    --accent: #4da3ff;
    --up: #16c784;
    --down: #ff4d4d;
    --grid-gap: 16px;
    --radius: 16px;
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: radial-gradient(1200px 600px at 50% -50%, #1a2031 0%, var(--bg) 55%) fixed;
    color: var(--text);
    font: 14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  .wrap {
    max-width: 1720px;
    margin: 20px auto 40px;
    padding: 0 16px;
  }

  header {
    display: flex; align-items: baseline; justify-content: space-between;
    margin-bottom: 14px;
  }
  header h1 { font-size: 18px; font-weight: 700; margin: 0; letter-spacing: .2px; }
  header .sub { color: var(--muted); font-size: 12px; }

  .grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--grid-gap);
  }

  .col {
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border-radius: var(--radius);
    padding: 12px 12px 10px;
    box-shadow: 0 6px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.02);
    display: grid;
    grid-template-rows: auto 10px auto 10px auto 1fr; /* title, gap, price chart, gap, gauge, volume, spacer */
    min-height: 560px;
  }

  .title {
    display: flex; align-items: baseline; justify-content: space-between;
    padding: 4px 2px 0;
  }
  .title .tf {
    font-weight: 700; text-transform: uppercase; letter-spacing: .6px; font-size: 12px; color: var(--muted);
  }
  .title .price {
    font-variant-numeric: tabular-nums; font-weight: 700; letter-spacing: .2px;
  }

  .chartCard {
    position: relative; height: 190px;
    background: rgba(255,255,255,.02);
    border-radius: 12px;
    overflow: hidden;
  }

  .gaugeCard {
    height: 130px;
    display: grid; place-items: center;
  }

  .volumeCard {
    height: 130px;
    background: rgba(255,255,255,.02);
    border-radius: 12px;
    overflow: hidden;
  }

  .spacer {
    min-height: 40px; /* reserved space for future Top Buy/Sell block per column */
  }

  /* Gauge */
  .gauge {
    width: 100%;
    max-width: 360px;
    aspect-ratio: 2 / 1;
    display: block;
  }
  .gauge text { fill: var(--muted); font-weight: 600; }
  .needle {
    transform-origin: 50% 100%;
    transition: transform 220ms ease-out;
  }
  .gauge .scaleGood { stop-color: var(--up); }
  .gauge .scaleBad { stop-color: var(--down); }

  /* Tiny legend line color dots */
  .legend { display: flex; gap: 8px; align-items: center; padding: 6px 2px 0; font-size: 12px; color: var(--muted); }
  .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; background: var(--accent); }
  .dot.vol { background: #b9c2d0; }

  /* Mobile safety: still desktop-first, but don’t break completely */
  @media (max-width: 1280px) {
    .grid { grid-template-columns: repeat(2, 1fr); }
  }
  @media (max-width: 740px) {
    .grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>BTC Overview</h1>
      <div class="sub">4 columns · Chart (top), Bias (middle), Volume (bottom) · Space reserved for Top Buy/Sell</div>
    </header>

    <section class="grid" id="dashboard">
      <!-- Columns will be injected by JS -->
    </section>
  </div>

  <!-- Chart.js for fast, accurate lines & bars (with straight segments; no rounding) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" integrity="sha384-v2dU6O2Yx3mR9r5v6k8Xz1GQzYbTgH+oB7C0y9nD8Nw0w2Y6dGv+q6KqNQbF1m9G" crossorigin="anonymous"></script>

  <script>
  /***********************
   * CONFIG
   ***********************/
  const USE_MOCK_DATA = false;  // set to false to connect to Coinbase Exchange ticker (BTC-USD)
  const PRODUCT_ID = "BTC-USD";

  // Timeframes in milliseconds
  const TIMEFRAMES = [
    { key: '10m',  label: '10 MIN', windowMs: 10 * 60 * 1000,  sampleEveryMs: 2000 },   // update chart every 2s in mock
    { key: '1h',   label: '1 HOUR', windowMs: 60 * 60 * 1000,  sampleEveryMs: 5000 },
    { key: '8h',   label: '8 HOURS', windowMs: 8 * 60 * 60 * 1000, sampleEveryMs: 15000 },
    { key: '24h',  label: '24 HOURS', windowMs: 24 * 60 * 60 * 1000, sampleEveryMs: 30000 }
  ];

  // Styling prefs for “accurate, less rounded” lines (no bezier smoothing)
  const CHART_LINE_OPTIONS = {
    segment: { borderWidth: 2 },
    cubicInterpolationMode: 'default',
    tension: 0,                   // straight segments
    pointRadius: 0,               // no dots
  };

  /***********************
   * DOM BUILD
   ***********************/
  const dashEl = document.getElementById('dashboard');

  function gaugeSVG(idSuffix) {
    // Semi-circle from 180° (left) to 0° (right). Needle rotates around bottom center.
    return `
    <svg viewBox="0 0 200 100" class="gauge" aria-label="bias gauge">
      <defs>
        <linearGradient id="grad-${idSuffix}" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" class="scaleBad"/>
          <stop offset="50%" stop-color="#d6dbe5"/>
          <stop offset="100%" class="scaleGood"/>
        </linearGradient>
      </defs>
      <path d="M10,100 A90,90 0 0,1 190,100" fill="none" stroke="url(#grad-${idSuffix})" stroke-width="14" />
      <!-- ticks -->
      ${Array.from({length: 11}).map((_,i)=>{
        const t = i/10; // 0..1
        const angle = Math.PI - t*Math.PI; // PI..0
        const r1=86, r2=96, cx=100, cy=100;
        const x1=cx+r1*Math.cos(angle), y1=cy+r1*Math.sin(angle);
        const x2=cx+r2*Math.cos(angle), y2=cy+r2*Math.sin(angle);
        return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#2b3242" stroke-width="${i%5===0?2:1}" />`
      }).join('')}
      <!-- needle -->
      <g id="needle-${idSuffix}" class="needle" transform="translate(100,100) rotate(0)">
        <polygon points="-2,0 2,0 0,-78" fill="#fff"/>
        <circle cx="0" cy="0" r="4" fill="#fff"/>
      </g>
      <text x="100" y="96" text-anchor="middle" font-size="10">Bias</text>
    </svg>`;
  }

  function columnTemplate(tf) {
    const id = tf.key;
    return `
      <div class="col" id="col-${id}">
        <div class="title">
          <div class="tf">${tf.label}</div>
          <div class="price" id="price-${id}">$—</div>
        </div>

        <div class="chartCard">
          <canvas id="priceChart-${id}" aria-label="${tf.label} price chart"></canvas>
        </div>
        <div class="legend"><span class="dot"></span> Price</div>

        <div class="gaugeCard">
          ${gaugeSVG(id)}
        </div>

        <div class="volumeCard">
          <canvas id="volChart-${id}" aria-label="${tf.label} volume chart"></canvas>
        </div>
        <div class="legend"><span class="dot vol"></span> Volume</div>

        <div class="spacer"></div>
      </div>
    `;
  }

  dashEl.innerHTML = TIMEFRAMES.map(columnTemplate).join('');

  /***********************
   * STATE
   ***********************/
  const state = {};
  let lastPrice = 65000; // seed for mock
  let lastVolume = 1.0;

  // Per timeframe series: arrays of { t, price, vol }
  TIMEFRAMES.forEach(tf=>{
    state[tf.key] = {
      series: [],
      lastSampleTs: 0,
      priceChart: null,
      volChart: null,
    };
  });

  /***********************
   * CHART BOOTSTRAP
   ***********************/
  function makeLineChart(canvas, label) {
    const ctx = canvas.getContext('2d');
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{
        label,
        data: [],
        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#4da3ff',
        borderWidth: 2,
        fill: false,
        ...CHART_LINE_OPTIONS
      }]},
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 0 },
        plugins: {
          legend: { display: false },
          tooltip: { intersect: false, mode: 'index', displayColors: false, callbacks: {
            label: ctx => `$${Number(ctx.formattedValue).toLocaleString()}`,
          }},
        },
        scales: {
          x: { ticks: { display: false }, grid: { display: false }, border: { display: false }},
          y: { ticks: { display: true, color: '#7f8796', callback: v=>'$'+Number(v).toLocaleString() },
               grid: { color: 'rgba(255,255,255,.06)' }, border: { display: false } },
        }
      }
    });
  }

  function makeBarChart(canvas, label) {
    const ctx = canvas.getContext('2d');
    return new Chart(ctx, {
      type: 'bar',
      data: { labels: [], datasets: [{
        label,
        data: [],
        borderWidth: 0
      }]},
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 0 },
        plugins: { legend: { display: false }, tooltip: { callbacks: { label: c=>`Vol: ${Number(c.raw).toLocaleString()}` } } },
        scales: {
          x: { ticks: { display: false }, grid: { display: false }, border: { display: false }},
          y: { ticks: { display: false }, grid: { color: 'rgba(255,255,255,.06)' }, border: { display: false } }
        }
      }
    });
  }

  TIMEFRAMES.forEach(tf=>{
    const line = makeLineChart(document.getElementById(`priceChart-${tf.key}`), 'Price');
    const vol  = makeBarChart(document.getElementById(`volChart-${tf.key}`), 'Volume');
    state[tf.key].priceChart = line;
    state[tf.key].volChart = vol;
  });

  /***********************
   * HELPERS
   ***********************/
  function prune(tfKey) {
    const tf = TIMEFRAMES.find(t=>t.key===tfKey);
    const cutoff = Date.now() - tf.windowMs;
    const bucket = state[tfKey];
    bucket.series = bucket.series.filter(p => p.t >= cutoff);
  }

  function resampleIfNeeded(tfKey, price, volume) {
    const tf = TIMEFRAMES.find(t=>t.key===tfKey);
    const bucket = state[tfKey];
    const now = Date.now();
    if (now - bucket.lastSampleTs >= tf.sampleEveryMs) {
      bucket.series.push({ t: now, price, vol: volume });
      bucket.lastSampleTs = now;
    }
  }

  function updateCharts(tfKey) {
    const bucket = state[tfKey];
    const line = bucket.priceChart;
    const bar = bucket.volChart;
    const labels = bucket.series.map(p => new Date(p.t).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}));
    const prices = bucket.series.map(p => p.price);
    const vols   = bucket.series.map(p => p.vol);

    line.data.labels = labels;
    line.data.datasets[0].data = prices;
    line.update('none');

    bar.data.labels = labels;
    bar.data.datasets[0].data = vols;
    // volume color by direction vs previous
    const bgs = vols.map((_,i)=>{
      if (i===0) return '#b9c2d0';
      const up = prices[i] >= prices[i-1];
      return up ? getCSS('--up') : getCSS('--down');
    });
    bar.data.datasets[0].backgroundColor = bgs;
    bar.update('none');
  }

  function getCSS(varName) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  // bias ∈ [-100, 100] based on % change between oldest and newest in window,
  // compressed via tanh for stability.
  function computeBias(tfKey) {
    const ser = state[tfKey].series;
    if (ser.length < 2) return 0;
    const first = ser[0].price;
    const last = ser[ser.length - 1].price;
    const pct = (last - first) / first; // e.g., 0.012
    // scale 5% => ±100, squashed a bit
    const scaled = Math.tanh((pct / 0.05) * 1.2) * 100;
    return Math.max(-100, Math.min(100, scaled));
  }

  function setGauge(tfKey, bias) {
    const id = `needle-${tfKey}`;
    const needle = document.getElementById(id);
    // map [-100,100] to [ -90deg, +90deg ]
    const deg = (bias / 100) * 90;
    needle.style.transform = `translate(100px,100px) rotate(${deg}deg)`;
  }

  function setPriceBadge(tfKey, price, prev) {
    const el = document.getElementById(`price-${tfKey}`);
    const diff = price - prev;
    const color = diff >= 0 ? getCSS('--up') : getCSS('--down');
    el.style.color = color || 'inherit';
    el.textContent = '$' + Number(price).toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  /***********************
   * DATA: MOCK OR LIVE
   ***********************/
  function startMock() {
    // Random walk; tick ~ every 750ms
    setInterval(()=>{
      const drift = 0.0;
      const shock = (Math.random() - 0.5) * 40; // up to ±$20 per tick
      const meanRevert = (65000 - lastPrice) * 0.002;
      const next = Math.max(1000, lastPrice + drift + shock + meanRevert);

      // volume ~ log-normal-ish
      const vol = Math.max(0.1, (Math.random() * 2.0) ** 2);

      onQuote(next, vol);
    }, 750);
  }

  // Coinbase Exchange public WS (ticker): wss://ws-feed.exchange.coinbase.com
  // Docs: https://docs.cloud.coinbase.com/exchange/docs/websocket-overview
  function startCoinbase() {
    const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
    ws.onopen = () => {
      ws.send(JSON.stringify({
        type: 'subscribe',
        product_ids: [PRODUCT_ID],
        channels: ['ticker']
      }));
    };
    ws.onmessage = (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'ticker' && msg.price && msg.product_id === PRODUCT_ID) {
          const price = parseFloat(msg.price);
          const volume = msg.last_size ? parseFloat(msg.last_size) : (parseFloat(msg.best_bid_size || 0) + parseFloat(msg.best_ask_size || 0))/2 || 0.2;
          onQuote(price, volume);
        }
      } catch(e) { /* ignore */ }
    };
    ws.onclose = () => {
      // optional: attempt simple reconnect
      setTimeout(startCoinbase, 2000);
    };
  }

  function onQuote(price, volume) {
    const prev = lastPrice;
    lastPrice = price;
    lastVolume = volume;

    // For each timeframe, keep series inside window, resample, update charts & gauges
    TIMEFRAMES.forEach(tf=>{
      prune(tf.key);
      resampleIfNeeded(tf.key, price, volume);
      updateCharts(tf.key);
      const bias = computeBias(tf.key);
      setGauge(tf.key, bias);
      setPriceBadge(tf.key, price, prev);
    });
  }

  // Bootstrap seed: fill each series with a short history so charts don’t start empty
  (function seedInitialHistory(){
    const now = Date.now();
    TIMEFRAMES.forEach(tf=>{
      const step = Math.max(2000, Math.floor(tf.windowMs / 60)); // ~60 samples per timeframe
      const arr = [];
      let p = lastPrice;
      for (let t = now - tf.windowMs; t <= now; t += step) {
        p += (Math.random()-0.5)*15;
        arr.push({ t, price: p, vol: Math.random()*2 });
      }
      state[tf.key].series = arr;
      state[tf.key].lastSampleTs = now;
      updateCharts(tf.key);
      setGauge(tf.key, computeBias(tf.key));
      setPriceBadge(tf.key, p, p);
    });
  })();

  // Start feed
  if (USE_MOCK_DATA) {
    startMock();
  } else {
    startCoinbase();
  }

  </script>
</body>
</html>
