<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>h8s — desktop (ranges)</title>
<style>
  :root{
    --bg:#0b0b0b; --panel:#111; --panel-2:#0e0e0e;
    --text:#e9fef7; --muted:#c8d6cf;
    --up:#2dd4bf; --down:#f59e0b;
    --grid:rgba(255,255,255,.08); --grid-2:rgba(255,255,255,.06);
    --pill-bg:rgba(0,0,0,.75); --pill-bd:rgba(255,255,255,.22);
    --glow:0 0 0 1px rgba(255,255,255,.06), 0 20px 50px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  .wrap{max-width:1200px; margin:28px auto; padding:0 20px;}
  .row{display:flex; gap:16px; align-items:center; margin-bottom:14px}
  .brand{font-weight:800; letter-spacing:.3px; opacity:.9}
  .tabs{display:flex; gap:8px}
  .tab{padding:8px 12px; border-radius:9px; background:#151515; color:#fff; border:1px solid #272727; cursor:pointer}
  .tab.active{background:var(--up); color:#0c1513; border-color:transparent; font-weight:700}
  .cards{display:flex; flex-direction:column; gap:16px}

  .card{background:var(--panel); border-radius:14px; box-shadow:var(--glow); padding:14px}
  .h1{font-weight:900; font-size:36px; margin:0 0 8px}
  .sub{opacity:.8; font-size:14px; margin-bottom:10px}

  /* canvases */
  .chartWrap{padding:8px; background:var(--panel-2); border-radius:12px}
  canvas{display:block; width:100%; background:transparent}
  #priceCanvas{height:360px}
  #gaugeCanvas{height:28px}
  #volCanvas{height:240px}

  /* legend */
  .legend{display:flex; align-items:center; gap:16px; margin-top:10px}
  .dot{width:12px; height:12px; border-radius:3px; display:inline-block}
  .dot.up{background:var(--up)} .dot.down{background:var(--down)}
  .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px;
        border-radius:999px; background:var(--pill-bg); border:1px solid var(--pill-bd);
        font-size:12px; white-space:nowrap; color:#fff; margin-left:auto}

  /* tops */
  .topsGrid{display:grid; grid-template-columns:1fr 1fr; gap:16px}
  .topsCol{background:var(--panel); border-radius:12px; padding:12px; box-shadow:var(--glow)}
  .topsCol h3{margin:0 0 8px; font-size:14px; opacity:.9}
  .topList{list-style:none; margin:0; padding:0; font-variant-numeric:tabular-nums}
  .topItem{display:flex; justify-content:space-between; align-items:center; gap:10px;
           padding:6px 8px; border-radius:8px}
  .topItem.buy{background:color-mix(in oklab, var(--up) 12%, transparent)}
  .topItem.sell{background:color-mix(in oklab, var(--down) 12%, transparent)}
  .usd{font-weight:800}
  .btc,.t{opacity:.85}
  .t{font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <div class="brand">coinbase stalker — desktop</div>
      <div class="tabs" id="tabs">
        <button class="tab active" data-ms="600000">10m</button>
        <button class="tab" data-ms="3600000">1h</button>
        <button class="tab" data-ms="28800000">8h</button>
        <button class="tab" data-ms="86400000">24h</button>
      </div>
      <div class="pill" id="connPill">Connecting…</div>
    </div>

    <div class="cards">
      <!-- Chart -->
      <div class="card">
        <div class="h1" id="bigPrice">$—</div>
        <div class="chartWrap"><canvas id="priceCanvas"></canvas></div>
        <div class="legend">
          <span class="dot up"></span>Buys
          <span class="dot down"></span>Sells
          <span class="pill" id="rangePill">window 10m</span>
        </div>
      </div>

      <!-- Vol bias gauge -->
      <div class="card">
        <div class="sub">Buy/Sell bias (selected window)</div>
        <div class="chartWrap" style="padding:10px 12px">
          <canvas id="gaugeCanvas"></canvas>
        </div>
      </div>

      <!-- Volume bars -->
      <div class="card">
        <div class="sub">Per-bin volume (auto bin size)</div>
        <div class="chartWrap"><canvas id="volCanvas"></canvas></div>
        <div class="legend">
          <span class="dot up"></span>Buys
          <span class="dot down"></span>Sells
          <span class="pill" id="maxVolPill">max ₿—</span>
        </div>
      </div>

      <!-- Top trades -->
      <div class="topsGrid">
        <div class="topsCol">
          <h3>Top Buys (window)</h3>
          <ul id="topBuys" class="topList"></ul>
        </div>
        <div class="topsCol">
          <h3>Top Sells (window)</h3>
          <ul id="topSells" class="topList"></ul>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== elements ===== */
const bigPrice = document.getElementById('bigPrice');
const priceCanvas = document.getElementById('priceCanvas');
const gaugeCanvas = document.getElementById('gaugeCanvas');
const volCanvas = document.getElementById('volCanvas');
const maxVolPill = document.getElementById('maxVolPill');
const rangePill = document.getElementById('rangePill');
const tabs = document.getElementById('tabs');
const connPill = document.getElementById('connPill');
const ulTopBuys = document.getElementById('topBuys');
const ulTopSells = document.getElementById('topSells');

/* ===== state ===== */
let series = [];         // [{t,p}]
let trades = [];         // raw trades in memory (we'll prune to 24h)
let lastScaled = null;
let lastRaw = null;
let VALUE_SCALE = 1;     // desktop: show 1 BTC equivalent
let RANGE_MS = 600000;   // default 10m
const MAX_KEEP_MS = 86400000; // keep last 24h

/* ===== utils ===== */
function sizeCanvas(c){
  const dpr = Math.min(3, window.devicePixelRatio||1);
  c.width = Math.max(1, c.clientWidth*dpr);
  c.height = Math.max(1, c.clientHeight*dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}
const fmtUSD=(v,fd=0)=> new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:fd}).format(v);
function roundRect(ctx,x,y,w,h,r,fill=true,stroke=false){
  ctx.beginPath(); ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

/* ===== tab switching ===== */
tabs.addEventListener('click', (e)=>{
  const b = e.target.closest('button.tab'); if(!b) return;
  for(const t of tabs.querySelectorAll('.tab')) t.classList.remove('active');
  b.classList.add('active');
  RANGE_MS = +b.dataset.ms;
  rangePill.textContent = 'window ' + (RANGE_MS===600000?'10m':RANGE_MS===3600000?'1h':RANGE_MS===28800000?'8h':'24h');
});

/* ===== WebSocket feed (Coinbase matches) ===== */
let ws, recon;
function startWS(){
  try{ ws && ws.close(); }catch{}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  ws.onopen = ()=>{
    ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
    connPill.textContent='Live';
  };
  ws.onmessage = (ev)=>{
    try{
      const m = JSON.parse(ev.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        const t = new Date(m.time).getTime();
        const p = +m.price, s = +m.size, side = m.side==='sell'?'sell':'buy';
        series.push({t, p});
        trades.push({t, p, s, side});

        // price header (scaled)
        lastRaw = p;
        const scaled = p * VALUE_SCALE;
        if(lastScaled!=null){
          bigPrice.classList.remove('up','down');
          if(scaled>lastScaled) bigPrice.classList.add('up'); else if(scaled<lastScaled) bigPrice.classList.add('down');
        }
        lastScaled = scaled;
        bigPrice.textContent = fmtUSD(scaled,2);
      }
    }catch{}
  };
  ws.onclose = ()=>{ connPill.textContent='Reconnecting…'; recon=setTimeout(startWS,1200); };
  ws.onerror = ()=>{ try{ws.close()}catch{} };
}
startWS();

/* ===== pruning ===== */
function prune(){
  const now = Date.now();
  series = series.filter(d=> d.t >= now - MAX_KEEP_MS);
  trades = trades.filter(d=> d.t >= now - MAX_KEEP_MS);
}

/* ===== Chart draw ===== */
function drawPrice(){
  const ctx = sizeCanvas(priceCanvas);
  const w = priceCanvas.clientWidth, h = priceCanvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  roundRect(ctx,0,0,w,h,10);

  if(series.length<2) return;

  const now = Date.now();
  // Stretch only while filling the *10m* window; otherwise fixed-span
  const firstTs = Math.min(...series.map(d=>d.t));
  const wantSpan = RANGE_MS;
  const span = (RANGE_MS===600000) ? Math.min(wantSpan, Math.max(2000, now-firstTs+1000)) : wantSpan;
  const startT = now - span;

  // buckets: 1s for small windows, 5s/15s for larger for performance
  const step = RANGE_MS<=600000 ? 1000 : RANGE_MS<=3600000 ? 5000 : 15000;
  const buckets=[];
  for(let t=startT; t<=now; t+=step){
    // take latest <= t+step
    let chosen=null;
    for(let i=series.length-1;i>=0;i--){
      const s=series[i];
      if(s.t <= t+step){ chosen=s; break; }
    }
    if(chosen) buckets.push(chosen);
  }
  if(buckets.length<2) return;

  let min=Infinity,max=-Infinity,sum=0;
  for(const b of buckets){ if(b.p<min)min=b.p; if(b.p>max)max=b.p; sum+=b.p; }
  const range=(max-min)||1, avg=sum/buckets.length;

  const padX=18, padY=24;

  // grid lines
  ctx.strokeStyle='var(--grid)';
  for(let i=1;i<=3;i++){
    const y=padY+(h-2*padY)*(i/4*(4/3)); ctx.beginPath(); ctx.moveTo(padX,y); ctx.lineTo(w-padX,y); ctx.stroke();
  }
  // average dashed
  const yAvg = padY + (h-2*padY)*(1-(avg-min)/range);
  ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,.35)';
  ctx.beginPath(); ctx.moveTo(padX,yAvg); ctx.lineTo(w-padX,yAvg); ctx.stroke(); ctx.setLineDash([]);

  // map to px (monotonic X)
  const usable = w-2*padX; const pts=[]; let lastX=-1;
  for(const d of buckets){
    const x=padX + ((d.t-startT)/span)*usable;
    const y=padY + (h-2*padY)*(1-(d.p-min)/range);
    const xi=Math.round(x); if(xi<=lastX) continue; lastX=xi; pts.push({x:xi,y});
  }
  if(pts.length<2) return;

  // Catmull–Rom -> Bezier
  const cr2bz=(p0,p1,p2,p3,t=0.5)=>{
    const d1x=(p2.x-p0.x)*t, d1y=(p2.y-p0.y)*t;
    const d2x=(p3.x-p1.x)*t, d2y=(p3.y-p1.y)*t;
    return [{x:p1.x+d1x/3,y:p1.y+d1y/3},{x:p2.x-d2x/3,y:p2.y-d2y/3}];
  };
  const up = getComputedStyle(document.body).getPropertyValue('--up').trim();
  ctx.strokeStyle=up; ctx.lineWidth=2.25; ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=0;i<pts.length-1;i++){
    const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
    const [c1,c2]=cr2bz(p0,p1,p2,p3,.5);
    ctx.bezierCurveTo(c1.x,c1.y,c2.x,c2.y,p2.x,p2.y);
  }
  ctx.stroke();

  // labels (max/avg/min)
  ctx.fillStyle='rgba(255,255,255,.9)'; ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.textBaseline='middle';
  ctx.fillText(fmtUSD(max,0), padX, padY+4);
  ctx.fillText(fmtUSD(avg,0), padX, Math.max(padY+12, Math.min(h-padY-12, yAvg)));
  ctx.fillText(fmtUSD(min,0), padX, h-padY-4);

  // last price pill (raw)
  if(lastRaw!=null){
    const last=pts[pts.length-1];
    const label=fmtUSD(lastRaw,0);
    const tw=ctx.measureText(label).width+18, th=22;
    const bx=Math.min(w-tw-8, Math.max(8, last.x - tw/2)), by=Math.max(8, last.y - th - 8);
    ctx.fillStyle='rgba(0,0,0,.8)'; ctx.strokeStyle='rgba(255,255,255,.25)';
    roundRect(ctx,bx,by,tw,th,10,true,true);
    ctx.fillStyle='#fff'; ctx.textBaseline='middle'; ctx.fillText(label, bx+9, by+th/2);
  }
}

/* ===== Gauge draw ===== */
function drawGauge(){
  const ctx = sizeCanvas(gaugeCanvas);
  const w = gaugeCanvas.clientWidth, h = gaugeCanvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  const now = Date.now(), startT = now - RANGE_MS;
  let buy=0, sell=0;
  for(const t of trades){ if(t.t>=startT){ if(t.side==='buy') buy+=t.s; else sell+=t.s; } }
  const tot = buy+sell;
  const pos = tot ? buy/tot : .5;

  // split gradient dn→up
  const up = getComputedStyle(document.body).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.body).getPropertyValue('--down').trim();
  const g = ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0, dn);
  g.addColorStop(Math.max(0,pos-0.001), dn);
  g.addColorStop(Math.min(1,pos+0.001), up);
  g.addColorStop(1, up);

  const r = (h-2)/2;
  ctx.fillStyle=g; roundRect(ctx,1,1,w-2,h-2,r,true,false);

  // needle + pill
  const nx = Math.round(w*pos);
  ctx.beginPath();
  ctx.moveTo(nx, 2); ctx.lineTo(nx-7, 2+12); ctx.lineTo(nx+7, 2+12); ctx.closePath();
  ctx.fillStyle='#fff'; ctx.fill();

  const pct = tot ? ((buy-sell)/tot)*100 : 0;
  const txt = `${pct>=0?'+':''}${pct.toFixed(0)}%`;
  const tw = ctx.measureText(txt).width+14, th=18;
  const bx = Math.min(w-tw-4, Math.max(4, nx - tw/2)), by = -24;
  ctx.fillStyle='rgba(0,0,0,.8)'; ctx.strokeStyle='rgba(255,255,255,.25)';
  roundRect(ctx,bx,by,tw,th,9,true,true);
  ctx.fillStyle='#fff'; ctx.textBaseline='middle'; ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.fillText(txt, bx+7, by+th/2);
}

/* ===== Volume draw (auto-binned to ~60 bars) ===== */
function drawVol(){
  const ctx = sizeCanvas(volCanvas);
  const w = volCanvas.clientWidth, h = volCanvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  const now = Date.now(), startT = now - RANGE_MS;
  const windowTrades = trades.filter(t=> t.t>=startT);
  if(windowTrades.length===0) return;

  const targetBars = 60;
  const binMs = Math.max(60000, Math.floor(RANGE_MS / targetBars)); // ≥1m
  const binCount = Math.ceil(RANGE_MS / binMs);
  const bins = Array.from({length:binCount}, (_,i)=>({buy:0,sell:0,ts:startT+i*binMs}));

  for(const t of windowTrades){
    const idx = Math.min(binCount-1, Math.max(0, Math.floor((t.t-startT)/binMs)));
    if(t.side==='buy') bins[idx].buy += t.s; else bins[idx].sell += t.s;
  }

  const max = Math.max(0.01, ...bins.map(b=> b.buy+b.sell));
  maxVolPill.textContent = `max ₿${max.toFixed(2)}`;

  const padX=24, padTop=14, padBottom=28;
  const chartH = h - padTop - padBottom;
  const step = (w - padX*2) / bins.length;
  const barW = Math.max(3, step*0.66);

  // faint grid
  ctx.strokeStyle='var(--grid-2)';
  for(let i=1;i<=3;i++){
    const y=padTop + chartH*(i/4*(4/3));
    ctx.beginPath(); ctx.moveTo(padX-6,y); ctx.lineTo(w-padX+6,y); ctx.stroke();
  }

  const up = getComputedStyle(document.body).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.body).getPropertyValue('--down').trim();

  for(let i=0;i<bins.length;i++){
    const b=bins[i]; const xC = padX + i*step + step/2;
    const tot=b.buy+b.sell; const hT = Math.max(2,(tot/max)*chartH);
    const hBuy = tot?(b.buy/tot)*hT:0, hSell=hT-hBuy; const yB=padTop+chartH;

    ctx.fillStyle=dn; ctx.fillRect(xC-barW/2, yB-hSell, barW, hSell);
    ctx.fillStyle=up; ctx.fillRect(xC-barW/2, yB-hSell-hBuy, barW, hBuy);
  }
}

/* ===== Top trades ===== */
function drawTops(){
  const now = Date.now(), startT = now - RANGE_MS;
  const windowTrades = trades.filter(t=> t.t>=startT);
  const items = windowTrades.map(t=>({...t, usd: t.p * t.s}));

  const buys = items.filter(i=>i.side==='buy').sort((a,b)=>b.usd-a.usd).slice(0,20);
  const sells= items.filter(i=>i.side==='sell').sort((a,b)=>b.usd-a.usd).slice(0,20);

  const li = (t,cls) => {
    const time=new Date(t.t).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
    return `<li class="topItem ${cls}">
      <span class="usd">${fmtUSD(t.usd,0)}</span>
      <span class="btc">(${t.s.toFixed(2)} BTC)</span>
      <span class="t">${time}</span>
    </li>`;
  };

  ulTopBuys.innerHTML = buys.length ? buys.map(t=>li(t,'buy')).join('') : '<li class="topItem">—</li>';
  ulTopSells.innerHTML = sells.length ? sells.map(t=>li(t,'sell')).join('') : '<li class="topItem">—</li>';
}

/* ===== frame loop ===== */
function frame(){
  prune();
  drawPrice();
  drawGauge();
  drawVol();
  drawTops();
  requestAnimationFrame(frame);
}
new ResizeObserver(()=>{ drawPrice(); drawGauge(); drawVol(); }).observe(document.body);
requestAnimationFrame(frame);
</script>
</body>
</html>