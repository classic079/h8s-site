<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BTC Dashboard — 24h · 8h · 10m · 1h</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<style>
  :root{
    --bg:#0e0f13; --panel:#151823; --panel-2:#10131b; --text:#e5e7eb; --muted:#9aa3b2;
    --accent:#4da3ff; --up:#16c784; --down:#ff4d4d; --grid-gap:16px; --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:radial-gradient(1200px 600px at 50% -50%, #1a2031 0%, var(--bg) 55%) fixed;
    color:var(--text);font:14px/1.45 Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial
  }
  .wrap{max-width:1720px;margin:20px auto 40px;padding:0 16px}
  header{display:flex;align-items:baseline;justify-content:space-between;margin-bottom:14px}
  header h1{font-size:18px;font-weight:700;margin:0}
  header .sub{color:var(--muted);font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:var(--grid-gap)}

  .col{
    background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);
    border-radius:var(--radius);padding:12px 12px 10px;
    box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.02);
    display:grid;grid-template-rows:auto 12px auto 10px auto 1fr;min-height:520px;
  }
  .title{display:flex;align-items:baseline;justify-content:space-between;padding:4px 2px 0}
  .tf{font-weight:700;text-transform:uppercase;letter-spacing:.6px;font-size:12px;color:var(--muted)}
  .price{font-variant-numeric:tabular-nums;font-weight:700;letter-spacing:.2px}
  .chartCard{position:relative;height:220px;background:rgba(255,255,255,.02);border-radius:12px;overflow:hidden}
  .volumeCard{height:140px;background:rgba(255,255,255,.02);border-radius:12px;overflow:hidden}
  .legend{display:flex;gap:8px;align-items:center;padding:6px 2px 0;font-size:12px;color:var(--muted)}
  .dot{width:8px;height:8px;border-radius:50%;display:inline-block;background:var(--accent)}
  .dot.vol{background:#b9c2d0}
  .spacer{min-height:40px} /* reserved for future Top Buy/Sell */
  @media (max-width:1280px){.grid{grid-template-columns:repeat(2,1fr)}}
  @media (max-width:740px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>BTC Overview</h1>
      <div class="sub">Reversed columns · Price (top) · Volume histogram (bottom, max 12 bars)</div>
    </header>
    <section class="grid" id="dashboard"></section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" crossorigin="anonymous"></script>
  <script>
  /******** CONFIG ********/
  const USE_MOCK_DATA = true;     // set to false for live REST polling
  const PRODUCT_ID = "BTC-USD";
  const REST_TICKER_URL = `https://api.exchange.coinbase.com/products/${PRODUCT_ID}/ticker`;

  // Reversed order: 24h (left) → 1h (right)
  const TIMEFRAMES = [
    { key:'24h', label:'24 HOURS', windowMs:24*60*60*1000, sampleEveryMs:30000 },
    { key:'8h',  label:'8 HOURS',  windowMs: 8*60*60*1000, sampleEveryMs:15000 },
    { key:'10m', label:'10 MIN',   windowMs:10*60*1000,    sampleEveryMs:2000  },
    { key:'1h',  label:'1 HOUR',   windowMs:60*60*1000,    sampleEveryMs:5000  },
  ];
  const VOLUME_BIN_MAX = 12; // <= 12 columns in the volume panel

  const CHART_LINE_OPTIONS = { tension:0, pointRadius:0, segment:{borderWidth:2} };

  /******** DOM ********/
  const dash = document.getElementById('dashboard');
  dash.innerHTML = TIMEFRAMES.map(tf => `
    <div class="col" id="col-${tf.key}">
      <div class="title">
        <div class="tf">${tf.label}</div>
        <div class="price" id="price-${tf.key}">$—</div>
      </div>

      <div class="chartCard">
        <canvas id="priceChart-${tf.key}" aria-label="${tf.label} price chart"></canvas>
      </div>
      <div class="legend"><span class="dot"></span> Price</div>

      <div class="volumeCard">
        <canvas id="volChart-${tf.key}" aria-label="${tf.label} volume histogram"></canvas>
      </div>
      <div class="legend"><span class="dot vol"></span> Volume (binned)</div>

      <div class="spacer"></div>
    </div>
  `).join('');

  /******** STATE ********/
  const state = {};
  let lastPrice = 65000, lastVolume = 1.0;

  TIMEFRAMES.forEach(tf => state[tf.key] = { series: [], lastSampleTs: 0, priceChart: null, volChart: null });

  /******** CHARTS ********/
  function makeLineChart(canvas){
    const ctx = canvas.getContext('2d');
    return new Chart(ctx,{
      type:'line',
      data:{ labels:[], datasets:[{ label:'Price', data:[], borderColor:getVar('--accent')||'#4da3ff', borderWidth:2, fill:false, ...CHART_LINE_OPTIONS }]},
      options:{
        responsive:true, maintainAspectRatio:false, animation:{duration:0},
        plugins:{ legend:{display:false}, tooltip:{intersect:false,mode:'index',displayColors:false,callbacks:{label:c=>`$${Number(c.formattedValue).toLocaleString()}`}}},
        scales:{
          x:{ticks:{display:false},grid:{display:false},border:{display:false}},
          y:{ticks:{display:true,color:'#7f8796',callback:v=>'$'+Number(v).toLocaleString()},grid:{color:'rgba(255,255,255,.06)'},border:{display:false}},
        }
      }
    });
  }
  function makeBarChart(canvas){
    const ctx = canvas.getContext('2d');
    return new Chart(ctx,{
      type:'bar',
      data:{ labels:[], datasets:[{ label:'Volume', data:[], borderWidth:0, backgroundColor:[] }]},
      options:{
        responsive:true, maintainAspectRatio:false, animation:{duration:0},
        plugins:{ legend:{display:false}, tooltip:{callbacks:{label:c=>`Vol: ${Number(c.raw).toLocaleString()}`}}},
        scales:{
          x:{ticks:{display:true,color:'#7f8796'},grid:{display:false},border:{display:false}},
          y:{ticks:{display:false},grid:{color:'rgba(255,255,255,.06)'},border:{display:false}}
        }
      }
    });
  }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  TIMEFRAMES.forEach(tf=>{
    state[tf.key].priceChart = makeLineChart(document.getElementById(`priceChart-${tf.key}`));
    state[tf.key].volChart   = makeBarChart(document.getElementById(`volChart-${tf.key}`));
  });

  /******** HELPERS ********/
  function prune(tfKey){
    const tf = TIMEFRAMES.find(t=>t.key===tfKey), cutoff = Date.now()-tf.windowMs;
    state[tfKey].series = state[tfKey].series.filter(p=>p.t>=cutoff);
  }
  function resample(tfKey, price, volume){
    const tf = TIMEFRAMES.find(t=>t.key===tfKey);
    const bucket = state[tfKey], now = Date.now();
    if(now - bucket.lastSampleTs >= tf.sampleEveryMs){
      bucket.series.push({t:now, price, vol:volume});
      bucket.lastSampleTs = now;
    }
  }
  function redrawPrice(tfKey){
    const b = state[tfKey];
    const labels = b.series.map(p=>new Date(p.t).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}));
    const prices = b.series.map(p=>p.price);
    const line = b.priceChart;
    line.data.labels = labels; line.data.datasets[0].data = prices; line.update('none');
  }
  // Build 12 (max) bins over the timeframe, summing volume; color by price change within each bin.
  function redrawVolume(tfKey){
    const tf = TIMEFRAMES.find(t=>t.key===tfKey);
    const b = state[tfKey];
    if(b.series.length === 0){ return; }

    const now = Date.now();
    const start = now - tf.windowMs;
    const binCount = Math.min(VOLUME_BIN_MAX, Math.max(3, Math.floor(tf.windowMs / tf.sampleEveryMs / 5))); // adaptive, cap at 12
    const binWidth = tf.windowMs / binCount;

    const bins = Array.from({length:binCount}, (_,i)=>({
      tStart: start + i*binWidth, tEnd: start + (i+1)*binWidth,
      vol: 0, firstPrice: null, lastPrice: null
    }));

    for(const pt of b.series){
      const idx = Math.min(binCount-1, Math.max(0, Math.floor((pt.t - start) / binWidth)));
      const bin = bins[idx];
      bin.vol += pt.vol;
      if(bin.firstPrice === null) bin.firstPrice = pt.price;
      bin.lastPrice = pt.price;
    }

    const labels = bins.map(bin => {
      const d = new Date(bin.tStart);
      return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    });
    const vols = bins.map(bin => bin.vol);
    const colors = bins.map(bin => {
      if(bin.firstPrice === null || bin.lastPrice === null) return '#b9c2d0';
      return (bin.lastPrice >= bin.firstPrice) ? getVar('--up') : getVar('--down');
    });

    const bar = b.volChart;
    bar.data.labels = labels;
    bar.data.datasets[0].data = vols;
    bar.data.datasets[0].backgroundColor = colors;
    bar.update('none');
  }
  function setPriceBadge(tfKey, price, prev){
    const el = document.getElementById(`price-${tfKey}`);
    const color = (price - prev) >= 0 ? getVar('--up') : getVar('--down');
    el.style.color = color; el.textContent = '$' + Number(price).toLocaleString(undefined,{maximumFractionDigits:2});
  }

  /******** DATA ********/
  function onQuote(price, volume){
    const prev = lastPrice;
    lastPrice = price; lastVolume = volume || lastVolume;
    TIMEFRAMES.forEach(tf=>{
      prune(tf.key);
      resample(tf.key, price, volume);
      redrawPrice(tf.key);
      redrawVolume(tf.key);
      setPriceBadge(tf.key, price, prev);
    });
  }

  // Mock: random walk
  function startMock(){
    setInterval(()=>{
      const shock = (Math.random()-0.5)*40;
      const meanRevert = (65000 - lastPrice)*0.002;
      const next = Math.max(1000, lastPrice + shock + meanRevert);
      const vol = Math.max(0.1, (Math.random()*2.0)**2);
      onQuote(next, vol);
    }, 800);
  }

  // Live: public REST poll (no auth)
  async function pollOnce(){
    try{
      const r = await fetch(REST_TICKER_URL, { headers: { 'Accept': 'application/json' }});
      if(!r.ok) return;
      const j = await r.json();
      const price = parseFloat(j.price || j.last || j.ask || j.bid);
      const size  = parseFloat(j.size || j.volume || j.last_size || 0.2) || 0.2;
      if(Number.isFinite(price)) onQuote(price, size);
    }catch(e){ /* ignore */ }
  }
  function startREST(){
    pollOnce();
    setInterval(pollOnce, 2000);
  }

  // Seed each chart with ~60 points so it’s not empty on load
  (function seed(){
    const now = Date.now();
    TIMEFRAMES.forEach(tf=>{
      const step = Math.max(2000, Math.floor(tf.windowMs/60));
      const arr=[], start = now - tf.windowMs;
      let p = lastPrice;
      for(let t=start; t<=now; t+=step){
        p += (Math.random()-0.5)*15;
        arr.push({t, price:p, vol:Math.random()*2});
      }
      const bucket = state[tf.key];
      bucket.series = arr; bucket.lastSampleTs = now;
      redrawPrice(tf.key);
      redrawVolume(tf.key);
      setPriceBadge(tf.key, p, p);
    });
  })();

  // Start feed
  if(USE_MOCK_DATA){ startMock(); } else { startREST(); }
  </script>
</body>
</html>
