<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>h8s — desktop (4-up, classic 10m + headroom & smoothing)</title>
<style>
  :root{
    --bg:#0a0a0a; --panel:#111; --panel-2:#0d0d0d;
    --text:#e9fef7; --muted:#c8d6cf;
    --up:#2dd4bf; --down:#f59e0b;
    --grid:rgba(255,255,255,.08); --grid-2:rgba(255,255,255,.06);
    --pill-bg:rgba(0,0,0,.8); --pill-bd:rgba(255,255,255,.25);
    --glow:0 0 0 1px rgba(255,255,255,.06), 0 18px 40px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
  .wrap{padding:16px;max-width:1900px;margin:0 auto}
  .grid{display:grid;gap:14px;grid-template-columns:repeat(4,minmax(320px,1fr))}
  @media (max-width:1600px){ .grid{grid-template-columns:repeat(3,minmax(320px,1fr));} }
  @media (max-width:1200px){ .grid{grid-template-columns:repeat(2,minmax(320px,1fr));} }
  @media (max-width:800px){  .grid{grid-template-columns:1fr;} }

  .card{background:var(--panel);border-radius:14px;box-shadow:var(--glow);overflow:hidden}
  .hdr{display:flex;align-items:center;gap:10px;padding:10px 12px 6px}
  .title{font-weight:800;letter-spacing:.4px}
  .sub{opacity:.85;font-size:12px;margin-left:auto}
  canvas{display:block;width:100%;border-radius:12px;background:var(--panel-2)}
  .priceCanvas{height:220px;margin:8px 10px}
  .volCanvas{height:160px;margin:6px 10px 10px}
  .gaugeRow{display:flex;align-items:center;gap:10px;padding:0 12px 8px}
  #connPill{position:fixed;left:14px;bottom:14px;z-index:40}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;
        background:var(--pill-bg);border:1px solid var(--pill-bd);font-size:12px;color:#fff;white-space:nowrap}

  /* mirrored tops (outside → center) */
  .topsCanvas{height:240px;margin:0 10px 10px}

  .legend{display:flex;align-items:center;gap:10px;padding:0 12px 4px}
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .dot.up{background:var(--up)} .dot.down{background:var(--down)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="grid" id="panelGrid"></div>
    <span id="connPill" class="pill">Connecting…</span>
  </div>

<script>
/* ===== utils ===== */
const fmtUSD=(v,fd=0)=>new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:fd}).format(v);
function sizeCanvas(c){
  const dpr=Math.min(3,window.devicePixelRatio||1);
  c.width=Math.max(1,c.clientWidth*dpr);
  c.height=Math.max(1,c.clientHeight*dpr);
  c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
  return c.getContext('2d');
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);
  if(fill)ctx.fill(); if(stroke)ctx.stroke();
}

/* ===== time consts ===== */
const MS={ M1:60000,M2:120000,M5:300000,M10:600000,M20:1200000,M30:1800000,
           H1:3600000,H8:28800000,D1:86400000 };

/* ===== global trades buffer ===== */
let trades=[]; // {t, price, size, side}

/* ===== panel specs =====
  10m  : classic left→right stretch, 2m bins (5 bars)
  1h   : smoothed (time-normalized), 5m bins (12 bars)
  8h   : smoothed, 12 bars total => 40m bins, sqrt vol scaling
  24h  : smoothed, 12 bars total => 2h bins, sqrt vol scaling
*/
const PANEL_SPECS=[
  { label:'10 MIN', span:MS.M10, binMs:MS.M2,         volScale:'linear', topN:10, classic:true,  preload:false, granSec:60 },
  { label:'1 HOUR', span:MS.H1,  binMs:MS.M5,         volScale:'linear', topN:12, classic:false, preload:true,  granSec:60 },
  { label:'8 HOURS',span:MS.H8,  binMs:MS.H8/12,      volScale:'sqrt',   topN:10, classic:false, preload:true,  granSec:300 },
  { label:'24 HOURS',span:MS.D1, binMs:MS.D1/12,      volScale:'sqrt',   topN:10, classic:false, preload:true,  granSec:900 },
];

/* ===== Coinbase candle preload (neutral buy/sell split) ===== */
async function preloadCandles(spanMs, granSec){
  const end = Math.floor(Date.now()/1000);
  const start = end - Math.ceil(spanMs/1000);
  const url = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=${granSec}&start=${start}&end=${end}`;
  try{
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) throw new Error(res.status+' '+res.statusText);
    const arr = await res.json(); // [[time, low, high, open, close, volume], ...] newest first
    const synth=[];
    for(const c of arr){
      const [ts, low, high, open, close, vol]=c;
      const t=ts*1000; if(!isFinite(close)||!isFinite(vol)) continue;
      const half=Math.max(0,vol/2);
      if(half>0){ synth.push({t,price:close,size:half,side:'buy'}); synth.push({t,price:close,size:half,side:'sell'}); }
      else{ synth.push({t,price:close,size:0,side:'buy'}); }
    }
    synth.sort((a,b)=>a.t-b.t);
    const cutoff = Date.now() - spanMs - MS.M10;
    trades = trades.filter(tr=>tr.t > cutoff);
    trades = [...synth, ...trades];
  }catch(e){ console.warn('Preload failed', e); }
}

/* ===== RangePanel ===== */
class RangePanel{
  constructor(parent, spec){
    this.spec=spec;
    this.root=document.createElement('section'); this.root.className='card';
    this.root.innerHTML=`
      <div class="hdr">
        <div class="title">${spec.label}</div>
        <div class="sub" data-maxpill>max ₿—</div>
      </div>
      <canvas class="priceCanvas" data-price></canvas>
      <div class="gaugeRow">
        <span style="color:var(--up);font-size:12px">Buys</span>
        <canvas data-gauge style="height:22px;border-radius:999px;background:transparent;box-shadow:inset 0 0 0 1px rgba(255,255,255,.12)"></canvas>
        <span style="color:var(--down);font-size:12px">Sells</span>
      </div>
      <div class="legend">
        <span class="dot up"></span><span style="opacity:.85">Buys</span>
        <span class="dot down"></span><span style="opacity:.85">Sells</span>
      </div>
      <canvas class="volCanvas" data-vol></canvas>
      <canvas class="topsCanvas" data-tops></canvas>
    `;
    parent.appendChild(this.root);
    this.priceCanvas=this.root.querySelector('[data-price]');
    this.volCanvas=this.root.querySelector('[data-vol]');
    this.gaugeCanvas=this.root.querySelector('[data-gauge]');
    this.topsCanvas=this.root.querySelector('[data-tops]');
    this.maxPillEl=this.root.querySelector('[data-maxpill]');
    this.bins=[];
    this._needle=0.5;
    this._lastRawPrice=null;
  }

  rebuildBins(now){
    const {span,binMs}=this.spec;
    const bins=Math.ceil(span/binMs);
    const alignedNow=now - (now%binMs);
    const start=alignedNow - (bins-1)*binMs;
    this.bins = Array.from({length:bins},(_,i)=>({ts:start+i*binMs,buy:0,sell:0}));
    for(const t of trades){
      if(t.t<start || t.t>alignedNow) continue;
      const i=Math.floor((t.t-start)/binMs);
      if(i<0||i>=this.bins.length) continue;
      if(t.side==='sell') this.bins[i].sell+=t.size; else this.bins[i].buy+=t.size;
    }
  }

  /* time-normalized sampling for all charts (classic uses dynamic span) */
  _samplePoints(now){
    let startT,endT,span;
    if(this.spec.classic){
      if(trades.length<2) return null;
      const firstTs = trades[0].t;
      const elapsed = now - firstTs;
      const windowSpan = Math.max(2000, Math.min(this.spec.span, elapsed+1000));
      span = windowSpan; startT = now - windowSpan; endT = now;
    }else{
      span = this.spec.span; startT = now - span; endT = now;
    }

    // step based on span & canvas width (~<=600 samples)
    const w = this.priceCanvas.clientWidth || 800;
    const stepMs = Math.max(1000, Math.floor(span / Math.min(600, w)));
    const buckets=[];
    for(let t=startT;t<=endT;t+=stepMs){
      // pick latest trade <= t
      let chosen=null;
      for(let i=trades.length-1;i>=0;i--){
        const s=trades[i]; if(s.t<=t){ chosen=s; break; }
      }
      if(chosen) buckets.push({t:Math.max(chosen.t,startT), p:chosen.price});
    }
    if(buckets.length<2) return null;
    return {startT,endT,points:buckets};
  }

  drawPrice(now){
    const ctx=sizeCanvas(this.priceCanvas);
    const w=this.priceCanvas.clientWidth, h=this.priceCanvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
    ctx.fillRect(0,0,w,h);

    const samp=this._samplePoints(now);
    if(!samp) return;
    const {startT,endT,points:buckets}=samp;

    const padX=14,padY=18, usableW=w-2*padX;
    const min=Math.min(...buckets.map(p=>p.p));
    const max=Math.max(...buckets.map(p=>p.p));
    const range=(max-min)||1;

    const pts=[]; let lastX=-1;
    for(const d of buckets){
      const x=padX+((d.t-startT)/(endT-startT))*usableW;
      const y=padY+(h-2*padY)*(1-(d.p-min)/range);
      const xi=Math.round(x); if(xi<=lastX) continue; lastX=xi; pts.push({x:xi,y,p:d.p});
    }
    if(pts.length<2) return;

    // grid
    ctx.strokeStyle='var(--grid)';
    for(let i=1;i<=3;i++){
      const y=padY+(h-2*padY)*(i/4*(4/3));
      ctx.beginPath(); ctx.moveTo(padX,y); ctx.lineTo(w-padX,y); ctx.stroke();
    }

    // avg line
    const avg = buckets.reduce((a,d)=>a+d.p,0)/buckets.length;
    const yAvg = padY + (h-2*padY)*(1-(avg-min)/range);
    ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,.35)';
    ctx.beginPath(); ctx.moveTo(padX,yAvg); ctx.lineTo(w-padX,yAvg); ctx.stroke(); ctx.setLineDash([]);

    // Catmull–Rom → Bézier
    const cr2bz=(p0,p1,p2,p3,t=0.5)=>{const d1x=(p2.x-p0.x)*t,d1y=(p2.y-p0.y)*t,d2x=(p3.x-p1.x)*t,d2y=(p3.y-p1.y)*t;
      return [{x:p1.x+d1x/3,y:p1.y+d1y/3},{x:p2.x-d2x/3,y:p2.y-d2y/3}];};
    const up=getComputedStyle(document.body).getPropertyValue('--up').trim();
    ctx.strokeStyle=up; ctx.lineWidth=2.25; ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=0;i<pts.length-1;i++){
      const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
      const [c1,c2]=cr2bz(p0,p1,p2,p3,.5);
      ctx.bezierCurveTo(c1.x,c1.y,c2.x,c2.y,p2.x,p2.y);
    }
    ctx.stroke();

    // labels
    ctx.fillStyle='rgba(255,255,255,.9)';
    ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.textBaseline='middle';
    ctx.fillText(fmtUSD(max,0), padX, padY+4);
    ctx.fillText(fmtUSD(avg,0), padX, Math.max(padY+12, Math.min(h-padY-12, yAvg)));
    ctx.fillText(fmtUSD(min,0), padX, h-padY-4);

    // last price pill
    const last=pts[pts.length-1]; this._lastRawPrice=last.p;
    const label=fmtUSD(last.p,0); const tw=ctx.measureText(label).width+18, th=22;
    const bx=Math.min(w-tw-8, Math.max(8, last.x - tw/2)), by=Math.max(8, last.y - th - 8);
    ctx.fillStyle='rgba(0,0,0,.8)'; ctx.strokeStyle='rgba(255,255,255,.25)';
    roundRect(ctx,bx,by,tw,th,10,true,true);
    ctx.fillStyle='#fff'; ctx.fillText(label,bx+9,by+th/2);
  }

  drawGauge(){
    const ctx=sizeCanvas(this.gaugeCanvas);
    const w=this.gaugeCanvas.clientWidth, h=this.gaugeCanvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    let buy=0,sell=0; for(const b of this.bins){ buy+=b.buy; sell+=b.sell; }
    const tot=buy+sell; const target = tot ? buy/tot : 0.5;
    this._needle += (target - this._needle)*0.25;

    const up=getComputedStyle(document.body).getPropertyValue('--up').trim();
    const dn=getComputedStyle(document.body).getPropertyValue('--down').trim();
    const g=ctx.createLinearGradient(0,0,w,0);
    const split=this._needle;
    g.addColorStop(0,dn); g.addColorStop(Math.max(0,split-0.001),dn);
    g.addColorStop(Math.min(1,split+0.001),up); g.addColorStop(1,up);
    const r=h/2; ctx.fillStyle=g; roundRect(ctx,1,1,w-2,h-2,r-1,true,false);

    ctx.globalAlpha=.18; ctx.fillStyle=(this._needle>=0.5)?up:dn;
    const domW=(this._needle>=0.5)?(w*this._needle):(w*(1-this._needle));
    const domX=(this._needle>=0.5)?0:(w*this._needle);
    roundRect(ctx,domX,1,domW,h-2,r-1,true,false);
    ctx.globalAlpha=1;
  }

  drawVol(){
    const ctx=sizeCanvas(this.volCanvas);
    const w=this.volCanvas.clientWidth, h=this.volCanvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
    ctx.fillRect(0,0,w,h);

    const totals=this.bins.map(b=>b.buy+b.sell);
    const sorted=[...totals].sort((a,b)=>a-b);
    const p95=sorted.length?sorted[Math.floor(.95*(sorted.length-1))]:0.01;
    const robust=(this.spec.volScale==='sqrt');
    // headroom so the top pill never collides (leave ~16% vertical space)
    const headroom=0.84;
    const baseMax = robust ? p95 : Math.max(...totals,0.01);
    const max = Math.max(0.01, baseMax / headroom);
    this.maxPillEl.textContent=`max ₿${baseMax.toFixed(2)}`;

    const padX=16, padTop=12, padBottom=26;
    const chartH=h-padTop-padBottom;
    const step=(w-padX*2)/this.bins.length;
    const barW=step*0.62;

    const up=getComputedStyle(document.body).getPropertyValue('--up').trim();
    const dn=getComputedStyle(document.body).getPropertyValue('--down').trim();

    // grid
    ctx.strokeStyle='var(--grid-2)';
    for(let i=1;i<=2;i++){
      const y=padTop+chartH*(i/3*(3/2));
      ctx.beginPath(); ctx.moveTo(padX-6,y); ctx.lineTo(w-padX+6,y); ctx.stroke();
    }

    // sparse time labels
    ctx.fillStyle='rgba(255,255,255,.85)'; ctx.font='11px system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.textBaseline='top';
    const labelEvery=Math.max(1,Math.floor(this.bins.length/5));
    for(let i=0;i<this.bins.length;i+=labelEvery){
      const xC=padX+i*step+step/2;
      const t=new Date(this.bins[i].ts).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
      ctx.fillText(t.replace(' ',''), xC-18, h-18);
    }

    for(let i=0;i<this.bins.length;i++){
      const b=this.bins[i], xC=padX+i*step+step/2, tot=b.buy+b.sell;
      const frac=Math.min(1, tot/max);
      const scaledFrac = robust ? Math.sqrt(frac) : frac;
      const hT=Math.max(4, scaledFrac * chartH * headroom);
      const hBuy=tot?(b.buy/tot)*hT:0, hSell=hT-hBuy;
      const yB=padTop+chartH;

      // bars
      ctx.fillStyle=dn; ctx.fillRect(xC-barW/2, yB-hSell, barW, hSell);
      ctx.fillStyle=up; ctx.fillRect(xC-barW/2, yB-hSell-hBuy, barW, hBuy);

      // TOTAL pill (only if > 0)
      if(tot>0){
        const txt=`₿${tot.toFixed(2)}`;
        const tw=ctx.measureText(txt).width+14, th=18;
        const bx=Math.round(xC - tw/2), by=Math.round(yB - hT - th - 4);
        ctx.fillStyle='rgba(0,0,0,.85)'; ctx.strokeStyle='rgba(255,255,255,.25)';
        roundRect(ctx,bx,by,tw,th,9,true,true);
        ctx.fillStyle='#fff'; ctx.textBaseline='middle'; ctx.fillText(txt,bx+7,by+th/2);
      }

      // +/- pill
      const diff=b.buy - b.sell;
      if(Math.abs(diff)>=0.01 && hT>28){
        const dTxt=`${diff>=0?'+':''}${diff.toFixed(2)}`;
        const tw=ctx.measureText(dTxt).width+14, th=18;
        const bx=Math.round(xC - tw/2), by=Math.round(yB - hT + 4);
        ctx.fillStyle='rgba(0,0,0,.88)'; ctx.strokeStyle='rgba(255,255,255,.25)';
        roundRect(ctx,bx,by,tw,th,9,true,true);
        ctx.fillStyle = diff>=0 ? up : dn;
        ctx.textBaseline='middle'; ctx.fillText(dTxt,bx+7,by+th/2);
      }
    }
  }

  drawTops(){
    const ctx=sizeCanvas(this.topsCanvas);
    const w=this.topsCanvas.clientWidth, h=this.topsCanvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
    ctx.fillRect(0,0,w,h);

    const start=Date.now()-this.spec.span;
    const items=trades.filter(t=>t.t>=start).map(t=>({...t,usd:t.price*t.size}));
    const buys=items.filter(i=>i.side==='buy').sort((a,b)=>b.usd-a.usd).slice(0,this.spec.topN);
    const sells=items.filter(i=>i.side==='sell').sort((a,b)=>b.usd-a.usd).slice(0,this.spec.topN);

    const rows=Math.max(buys.length,sells.length);
    const padX=10,padY=12,gap=6,rowH=22,midX=Math.floor(w/2);
    const up=getComputedStyle(document.body).getPropertyValue('--up').trim();
    const dn=getComputedStyle(document.body).getPropertyValue('--down').trim();

    // divider
    ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.moveTo(midX+.5,padY-6); ctx.lineTo(midX+.5,h-padY+6); ctx.stroke();

    const maxUSD=Math.max(1, ...buys.map(b=>b.usd), ...sells.map(s=>s.usd));
    const leftMaxW=midX - padX - 10, rightMaxW=w - midX - padX - 10;

    ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
    ctx.textBaseline='middle';

    for(let i=0;i<rows;i++){
      const y=padY + i*(rowH+gap) + rowH/2;

      const s=sells[i];
      if(s){
        const frac=Math.min(1, s.usd/maxUSD);
        const barW=Math.max(4, frac*leftMaxW);
        const x0=midX - barW;
        ctx.fillStyle=dn; roundRect(ctx,x0,y-rowH/2,barW,rowH,6,true,false);
        const labelW=Math.min(barW,160);
        ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(midX-labelW, y-rowH/2, labelW, rowH);
        ctx.fillStyle='#fff'; ctx.textAlign='right';
        ctx.fillText(`${fmtUSD(s.usd,0)}  (${s.size.toFixed(2)} BTC)`, midX-8, y);
      }

      const b=buys[i];
      if(b){
        const frac=Math.min(1, b.usd/maxUSD);
        const barW=Math.max(4, frac*rightMaxW);
        ctx.fillStyle=up; roundRect(ctx,midX,y-rowH/2,barW,rowH,6,true,false);
        const labelW=Math.min(barW,160);
        ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(midX, y-rowH/2, labelW, rowH);
        ctx.fillStyle='#fff'; ctx.textAlign='left';
        ctx.fillText(`${fmtUSD(b.usd,0)}  (${b.size.toFixed(2)} BTC)`, midX+8, y);
      }
    }
  }

  render(now){
    this.rebuildBins(now);
    this.drawPrice(now);
    this.drawGauge();
    this.drawVol();
    this.drawTops();
  }
}

/* ===== build grid ===== */
const grid=document.getElementById('panelGrid');
const panels=PANEL_SPECS.map(spec=>new RangePanel(grid,spec));

/* ===== preload historical for non-10m panels ===== */
(async function preloadAll(){
  for(const s of PANEL_SPECS){
    if(s.preload){
      await preloadCandles(s.span, s.granSec);
    }
  }
})();

/* ===== WS feed ===== */
const connPill=document.getElementById('connPill');
let ws,recon;
function setConn(t){ connPill.textContent=t; }
function startWS(){
  try{ ws&&ws.close(); }catch{}
  ws=new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('Connecting…');
  ws.onopen=()=>{
    ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
    setConn('Live');
  };
  ws.onmessage=(e)=>{
    try{
      const m=JSON.parse(e.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        trades.push({t:new Date(m.time).getTime(), price:+m.price, size:+m.size, side:(m.side==='sell'?'sell':'buy')});
        // keep roughly a day
        const cutoff=Date.now()-MS.D1-MS.M10;
        if(trades.length>60000 || (trades[0]?.t<cutoff)){
          trades=trades.filter(t=>t.t>=cutoff);
        }
      }
    }catch{}
  };
  ws.onclose=()=>{ setConn('Reconnecting…'); recon=setTimeout(startWS,1200); };
  ws.onerror =()=>{ try{ws.close()}catch{}; setConn('Error'); };
}
startWS();

/* ===== loop ===== */
function frame(){
  const now=Date.now();
  for(const p of panels) p.render(now);
  requestAnimationFrame(frame);
}
new ResizeObserver(()=>{ for(const p of panels) p.render(Date.now()); }).observe(document.body);
requestAnimationFrame(frame);
</script>
</body>
</html>