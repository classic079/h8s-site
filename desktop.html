<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BTC Overview — v1.3</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root{
    --bg:#0e0f13; --panel:#151823; --panel-2:#10131b; --text:#e5e7eb; --muted:#9aa3b2;
    --accent:#4da3ff; --up:#16c784; --down:#ff4d4d; --gap:16px; --radius:16px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 Inter,ui-sans-serif,system-ui}
  .wrap{max-width:1720px;margin:20px auto 40px;padding:0 16px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
  header h1{margin:0;font-size:18px;font-weight:700}
  .meta{display:flex;gap:10px;align-items:center}
  .chip{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #27324a;background:#0b1220;color:#cbd5e1}
  .badge{font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:var(--gap)}
  .col{background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);border-radius:var(--radius);
       padding:12px;display:flex;flex-direction:column;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  .title{display:flex;justify-content:space-between}
  .tf{color:var(--muted);font-weight:700;font-size:12px}
  .price{font-weight:700}
  .chartCard{background:rgba(255,255,255,.02);border-radius:12px;height:200px;margin-top:8px}
  .volumeCard{background:rgba(255,255,255,.02);border-radius:12px;height:110px;margin-top:6px}
  @media (max-width:1280px){.grid{grid-template-columns:repeat(2,1fr)}}
  @media (max-width:740px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>BTC Overview</h1>
    <div class="meta">
      <span class="chip" id="ver">v1.3</span>
      <span class="badge" id="histStatus">History: loading…</span>
      <span class="badge" id="liveStatus">Live: starting…</span>
    </div>
  </header>
  <section class="grid" id="dashboard"></section>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/* ================== VERSION ================== */
const APP_VERSION = 'v1.3';
console.log('BTC Dashboard', APP_VERSION);

/* ================== CONFIG ================== */
const TF = [
  { key:'24h', label:'24 HOURS', win:24*60*60*1000, sample:30000, granEX:3600, bin:12, bitstampStep:3600 },
  { key:'8h',  label:'8 HOURS',  win: 8*60*60*1000, sample:15000, granEX: 900, bin:12, bitstampStep: 900 },
  { key:'1h',  label:'1 HOUR',   win: 1*60*60*1000, sample: 5000, granEX:  60, bin:12, bitstampStep:  60 },
  { key:'10m', label:'10 MIN',   win:10*60*1000,    sample: 2000, granEX:  60, bin:12, bitstampStep:  60 } // area style
];

const dash = document.getElementById('dashboard');
(function buildColumns(){
  var html = '';
  for (var i=0;i<TF.length;i++){
    var t = TF[i];
    html += ''
      + '<div class="col">'
      +   '<div class="title"><div class="tf">'+t.label+'</div><div class="price" id="p-'+t.key+'">$—</div></div>'
      +   '<div class="chartCard"><canvas id="c-'+t.key+'"></canvas></div>'
      +   '<div class="volumeCard"><canvas id="v-'+t.key+'"></canvas></div>'
      + '</div>';
  }
  dash.innerHTML = html;
})();

const cssVar = function(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); };
const state = {};
var lastPrice = 65000, lastVol = 1;

/* ================== CHART FACTORIES ================== */
function makeLineChart(ctx, tfKey){
  var is10 = (tfKey === '10m');
  return new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      data: [],
      borderColor: cssVar('--accent') || '#4da3ff',
      borderWidth: 2,
      pointRadius: 0,
      tension: is10 ? 0.25 : 0,
      fill: is10 ? true : false,
      backgroundColor: is10 ? 'transparent' : 'transparent' // gradient applied on redraw
    }]},
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      plugins: { legend: { display: false }, tooltip: { mode:'index', intersect:false, displayColors:false } },
      scales: {
        x: { ticks: { display:false }, grid: { display:false } },
        y: { ticks: { color:'#7f8796' }, grid: { color:'rgba(255,255,255,.05)' } }
      }
    }
  });
}

function makeBarChart(ctx){
  return new Chart(ctx, {
    type: 'bar',
    data: { labels: [], datasets: [{ data: [], backgroundColor: [] }] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      plugins: { legend: { display:false } },
      scales: {
        x: { ticks: { color:'#7f8796' } },
        y: { ticks: { display:false } }
      }
    }
  });
}

function toRGBA(hex, a){
  var h = (hex || '#4da3ff').replace('#','');
  if (h.length !== 6) return 'rgba(77,163,255,'+a+')';
  var r = parseInt(h.substring(0,2),16),
      g = parseInt(h.substring(2,4),16),
      b = parseInt(h.substring(4,6),16);
  return 'rgba('+r+','+g+','+b+','+a+')';
}

TF.forEach(function(t){
  state[t.key] = {
    arr: [],
    tLast: 0,
    trendColor: cssVar('--accent') || '#4da3ff',
    pc: makeLineChart(document.getElementById('c-'+t.key).getContext('2d'), t.key),
    vc: makeBarChart(document.getElementById('v-'+t.key).getContext('2d'))
  };
});

/* ================== RENDER ================== */
function computeTrendColor(tfKey){
  var arr = state[tfKey].arr;
  if (arr.length < 2) return cssVar('--accent') || '#4da3ff';
  var first = arr[0].price, last = arr[arr.length-1].price;
  return (last >= first) ? cssVar('--up') : cssVar('--down');
}

function applyAreaGradientIfNeeded(tfKey){
  if (tfKey !== '10m') return;
  var b = state[tfKey];
  var chart = b.pc;
  var area = chart.chartArea;
  if (!area) return; // not ready yet
  var ctx = chart.ctx;
  var color = b.trendColor || (cssVar('--accent') || '#4da3ff');
  // convert CSS var to hex if needed
  if (color.indexOf('#') !== 0){
    // read computed color (rgb) and convert to rgba with alpha directly
    // fallback: just use accent hex
    color = (cssVar('--accent') || '#4da3ff');
  }
  var grad = ctx.createLinearGradient(0, area.top, 0, area.bottom);
  grad.addColorStop(0, toRGBA(color.replace('#',''), 0.25));
  grad.addColorStop(1, toRGBA(color.replace('#',''), 0.02));
  chart.data.datasets[0].backgroundColor = grad;
}

function redraw(tfKey){
  var t = TF.find(function(x){ return x.key===tfKey; });
  var b = state[tfKey];
  var now = Date.now();

  // prune
  b.arr = b.arr.filter(function(pt){ return pt.t >= (now - t.win); });

  // set trend color
  b.trendColor = computeTrendColor(tfKey);

  // price
  var labels = b.arr.map(function(pt){ return new Date(pt.t).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); });
  var prices = b.arr.map(function(pt){ return pt.price; });
  var pc = b.pc;
  pc.data.labels = labels;
  pc.data.datasets[0].data = prices;
  pc.data.datasets[0].borderColor = b.trendColor;
  applyAreaGradientIfNeeded(tfKey);
  pc.update('none');

  // volume (12 bins)
  var bins = t.bin;
  var start = now - t.win;
  var w = t.win / bins;
  var ag = [];
  for (var i=0;i<bins;i++){ ag.push({start:start+i*w, vol:0, first:null, last:null}); }
  for (var k=0;k<b.arr.length;k++){
    var pt = b.arr[k];
    var idx = Math.min(bins-1, Math.max(0, Math.floor((pt.t - start)/w)));
    var bin = ag[idx];
    bin.vol += (pt.vol || 0);
    if (bin.first === null) bin.first = pt.price;
    bin.last = pt.price;
  }
  var vc = b.vc;
  vc.data.labels = ag.map(function(x){ return new Date(x.start).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); });
  vc.data.datasets[0].data = ag.map(function(x){ return x.vol; });
  vc.data.datasets[0].backgroundColor = ag.map(function(x){
    if (x.first === null) return '#b9c2d0';
    return (x.last >= x.first) ? cssVar('--up') : cssVar('--down');
  });
  vc.update('none');
}

function setBadges(p){
  TF.forEach(function(t){
    var el = document.getElementById('p-'+t.key);
    el.textContent = '$' + p.toLocaleString(undefined,{maximumFractionDigits:2});
    el.style.color = (p >= lastPrice) ? cssVar('--up') : cssVar('--down');
  });
}

/* ================== LIVE ================== */
async function pollLive(){
  var liveEl = document.getElementById('liveStatus');

  // Coinbase
  try{
    var r1 = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/ticker', { headers: { Accept:'application/json' } });
    if (r1.ok){
      var j1 = await r1.json();
      var p1 = parseFloat(j1.price || j1.last || j1.bid || j1.ask);
      if (!isNaN(p1)){ onQuote(p1, parseFloat(j1.size || j1.volume || 0.1) || 0.1); liveEl.textContent = 'Live: Coinbase · ' + APP_VERSION; return; }
    }
  }catch(e){}

  // Bitstamp
  try{
    var r2 = await fetch('https://www.bitstamp.net/api/v2/ticker/btcusd/');
    if (r2.ok){
      var j2 = await r2.json();
      var p2 = parseFloat(j2.last);
      if (!isNaN(p2)){ onQuote(p2, parseFloat(j2.volume || 0.1) || 0.1); liveEl.textContent = 'Live: Bitstamp · ' + APP_VERSION; return; }
    }
  }catch(e){}

  // CoinCap
  try{
    var r3 = await fetch('https://api.coincap.io/v2/assets/bitcoin');
    if (r3.ok){
      var j3 = await r3.json();
      var p3 = parseFloat((j3 && j3.data && j3.data.priceUsd) ? j3.data.priceUsd : 'NaN');
      if (!isNaN(p3)){ onQuote(p3, 0.1); liveEl.textContent = 'Live: CoinCap · ' + APP_VERSION; return; }
    }
  }catch(e){}

  // Mock tick
  onQuote(lastPrice + (Math.random()-0.5)*20, Math.random()*2);
  liveEl.textContent = 'Live: mock · ' + APP_VERSION;
}

function onQuote(p,v){
  lastPrice = p;
  lastVol = v || lastVol;
  var n = Date.now();
  TF.forEach(function(t){
    var b = state[t.key];
    if (n - b.tLast >= t.sample){
      b.arr.push({ t:n, price:p, vol:v });
      b.tLast = n;
    }
    redraw(t.key);
  });
  setBadges(p);
}

/* ================== HISTORY (CoinGecko → Bitstamp → Coinbase EX → mock) ================== */
async function fetchCoinGecko(tf){
  var to = Math.floor(Date.now()/1000);
  var from = to - Math.ceil(tf.win/1000);
  var url = 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=usd&from='+from+'&to='+to;
  var r = await fetch(url, { headers:{ Accept:'application/json' } });
  if (!r.ok) throw 0;
  var j = await r.json();
  var P = j && j.prices;
  var V = j && j.total_volumes;
  if (!(P && V)) throw 0;
  var vmap = {};
  for (var i=0;i<V.length;i++){ var k = Math.round(V[i][0]); vmap[k] = Number(V[i][1]) || 0; }
  var arr = [];
  for (var k2=0;k2<P.length;k2++){
    var ts = Math.round(P[k2][0]);
    var ms = (ts < 1e12) ? ts*1000 : ts;
    arr.push({ t:ms, price:Number(P[k2][1]), vol:vmap[ts] || 0 });
  }
  arr.sort(function(a,b){ return a.t-b.t; });
  return { source:'CoinGecko', arr:arr };
}

async function fetchBitstamp(tf){
  var step = tf.bitstampStep;
  var limit = Math.min(1000, Math.ceil(tf.win/(step*1000)) + 2);
  var url = 'https://www.bitstamp.net/api/v2/ohlc/btcusd/?step='+step+'&limit='+limit;
  var r = await fetch(url, { headers:{ Accept:'application/json' } });
  if (!r.ok) throw 0;
  var j = await r.json();
  var rows = j && j.data && j.data.ohlc;
  if (!rows) throw 0;
  var out = [];
  for (var i=0;i<rows.length;i++){
    var c = rows[i];
    out.push({ t: Number(c.timestamp)*1000 + step*1000, price: Number(c.close), vol: Number(c.volume) || 0 });
  }
  out.sort(function(a,b){ return a.t-b.t; });
  return { source:'Bitstamp', arr: out };
}

async function fetchCoinbaseEX(tf){
  var end = Math.floor(Date.now()/1000);
  var start = end - Math.ceil(tf.win/1000);
  var url = 'https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity='+tf.granEX+'&start='+start+'&end='+end;
  var r = await fetch(url, { headers:{ Accept:'application/json' } });
  if (!r.ok) throw 0;
  var rows = await r.json();
  if (!Array.isArray(rows)) throw 0;
  rows.sort(function(a,b){ return a[0]-b[0]; });
  var out = [];
  for (var i=0;i<rows.length;i++){
    var x = rows[i];
    out.push({ t: x[0]*1000 + tf.granEX*1000, price: Number(x[4]), vol: Number(x[5]) || 0 });
  }
  return { source:'Coinbase EX', arr: out };
}

async function preload(){
  var histEl = document.getElementById('histStatus');
  var source = 'mock';
  for (var i=0;i<TF.length;i++){
    var tf = TF[i];
    var res = null;
    try{ res = await fetchCoinGecko(tf); }
    catch(e1){ try{ res = await fetchBitstamp(tf); }
               catch(e2){ try{ res = await fetchCoinbaseEX(tf); }
                          catch(e3){ res = null; } } }
    if (res && res.arr && res.arr.length){
      var b = state[tf.key];
      b.arr = res.arr;
      b.tLast = b.arr[b.arr.length-1].t || 0;
      redraw(tf.key);
      source = res.source;
    } else {
      // seed mock
      var now = Date.now();
      var b2 = state[tf.key];
      var p = lastPrice;
      b2.arr = [];
      var step = Math.max(2000, Math.floor(tf.win/60));
      for (var t=now-tf.win; t<=now; t+=step){
        p += (Math.random()-0.5)*15;
        b2.arr.push({ t:t, price:p, vol:Math.random()*2 });
      }
      b2.tLast = now;
      redraw(tf.key);
      source = 'mock';
    }
  }
  histEl.textContent = 'History: ' + source + ' · ' + APP_VERSION;
}

/* ================== BOOT ================== */
(function(){
  // 5s hard fallback so the page never stays blank
  var fs = setTimeout(function(){
    var histEl = document.getElementById('histStatus');
    var now = Date.now();
    for (var i=0;i<TF.length;i++){
      var tf = TF[i];
      var b = state[tf.key];
      var p = lastPrice;
      b.arr = [];
      var step = Math.max(2000, Math.floor(tf.win/60));
      for (var t=now-tf.win; t<=now; t+=step){
        p += (Math.random()-0.5)*15;
        b.arr.push({ t:t, price:p, vol:Math.random()*2 });
      }
      b.tLast = now;
      redraw(tf.key);
    }
    histEl.textContent = 'History: timeout/mock · ' + APP_VERSION;
  }, 5000);

  preload().then(function(){ clearTimeout(fs); }).catch(function(){ /* already handled */ });

  pollLive();
  setInterval(pollLive, 2000);
})();
</script>
</body>
</html>
