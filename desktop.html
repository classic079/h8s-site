<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>BTC Overview - v2.4 CORS FIXED</title>
<style>
:root{--bg:#0e0f13;--panel:#151823;--panel-2:#10131b;--text:#e5e7eb;--muted:#9aa3b2;--up:#16c784;--down:#ff4d4d}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui;overflow-x:hidden}
.wrap{max-width:1920px;margin:16px auto 28px;padding:0 24px}
header{display:grid;grid-template-columns:1fr minmax(360px,720px) 1fr;align-items:center;gap:8px;margin-bottom:10px}
.metaLeft,.metaRight{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
.metaRight{justify-self:end}
.chip{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #27324a;background:#0b1220;color:#cbd5e1}
.badge{font-size:12px;color:var(--muted)}
.pane{background:linear-gradient(180deg,var(--panel),var(--panel-2));border-radius:12px;padding:6px 12px;display:grid;grid-template-columns:auto 1fr auto;align-items:center;box-shadow:0 3px 10px rgba(0,0,0,.24)}
.pane label{color:#cbd5e1;font-weight:700;margin-right:12px}
#headerPrice{justify-self:center;font-weight:900;font-size:clamp(20px,3.2vw,36px);letter-spacing:.2px;transition:color .18s}
#headerPrice.up{color:var(--up)}
#headerPrice.down{color:var(--down)}
#headerClock{justify-self:end;color:var(--muted);font-weight:600}
.grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
@media(max-width:1500px){.grid{grid-template-columns:repeat(2,1fr)}}
@media(max-width:760px){.grid{grid-template-columns:1fr}}
.col{background:linear-gradient(180deg,var(--panel),var(--panel-2));border-radius:10px;padding:8px;display:flex;flex-direction:column;box-shadow:0 3px 12px rgba(0,0,0,.25)}
.title{display:flex;justify-content:space-between;align-items:center;gap:12px}
.tf{color:var(--muted);font-weight:800;font-size:12px}
.topbar{display:flex;gap:6px;flex-wrap:wrap}
.pill{font-size:12px;padding:3px 10px;border-radius:999px;border:1px solid #27324a;background:#0b1220;color:#cbd5e1;white-space:nowrap}
.pill.up{background:var(--up);border-color:transparent;color:#06140e}
.pill.down{background:var(--down);border-color:transparent;color:#140808}
.pill.muted{background:#0b1220;color:#cbd5e1;border:1px solid #27324a}
.chartCard{background:rgba(255,255,255,.02);border-radius:8px;height:210px;margin-top:6px}
.volumeCard{background:rgba(255,255,255,.02);border-radius:8px;height:170px;margin-top:6px}
.biasRow{display:flex;align-items:center;gap:10px;margin:8px 6px 0}
.gLabel{font-size:12px;opacity:.9}
.gLabel.buy{color:var(--up)}.gLabel.sell{color:#f59e0b}
.gaugeWrap{position:relative;flex:1}
#biasGauge{height:22px;width:100%;border-radius:999px;background:transparent;box-shadow:inset 0 0 0 1px rgba(255,255,255,.12)}
.needle{position:absolute;top:2px;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-top:10px solid #fff;filter:drop-shadow(0 2px 2px rgba(0,0,0,.35));transition:left .2s}
.needleValue{position:absolute;top:-14px;transform:translateX(-50%);background:rgba(0,0,0,.8);color:#fff;font-size:11px;padding:2px 6px;border-radius:10px;border:1px solid rgba(255,255,255,.25)}
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<div class="wrap">
<header>
<div class="metaLeft">
<span class="chip">v2.4 CORS FIXED</span>
<span class="badge" id="histStatus">History: Loading...</span>
<span class="badge" id="liveStatus">Live: Starting...</span>
</div>
<div class="pane">
<label>BTC/USD</label>
<div id="headerPrice">$—</div>
<div id="headerClock">—:—:—</div>
</div>
<div class="metaRight"><span class="chip" style="border-color:#2e7d32;color:#b7f5c8">JS: running</span></div>
</header>
<section class="grid" id="dashboard"></section>
</div>

<script>
const TF = [
  {key:'24h', label:'24 HOURS', win:86400000, sample:30000, bin:12, binanceInterval: '1h', binanceLimit: 24},
  {key:'8h', label:'8 HOURS', win:28800000, sample:15000, bin:12, binanceInterval: '15m', binanceLimit: 32},
  {key:'1h', label:'1 HOUR', win:3600000, sample:5000, bin:12, binanceInterval: '5m', binanceLimit: 12},
  {key:'10m', label:'10 MIN', win:600000, sample:2000, bin:12, binanceInterval: '1m', binanceLimit: 10}
];

const dash = document.getElementById('dashboard');
dash.innerHTML = TF.map(t => `
<div class="col">
  <div class="title">
    <div class="tf">${t.label}</div>
    <div class="topbar">
      <span class="pill muted" id="tfc-${t.key}">—</span>
      <span class="pill muted" id="hlc-${t.key}">H/L — / —</span>
      <span class="pill muted" id="volc-${t.key}">Vol —</span>
    </div>
  </div>
  <div class="chartCard"><canvas id="c-${t.key}"></canvas></div>
  ${t.key === '10m' ? `
  <div class="biasRow">
    <span class="gLabel buy">Buys</span>
    <div class="gaugeWrap">
      <canvas id="biasGauge"></canvas>
      <div id="needle" class="needle" style="left:50%"></div>
      <div id="needleValue" class="needleValue" style="left:50%">0%</div>
    </div>
    <span class="gLabel sell">Sells</span>
  </div>` : ''}
  <div class="volumeCard"><canvas id="v-${t.key}"></canvas></div>
</div>
`).join('');

const headClock = document.getElementById('headerClock');
function updateClock() {
  headClock.textContent = new Date().toLocaleTimeString();
}
updateClock();
setInterval(updateClock, 1000);
</script>

<script>
const histEl = document.getElementById('histStatus');
const liveEl = document.getElementById('liveStatus');
const headPrice = document.getElementById('headerPrice');
const stateMap = {};
let lastPriceGlobal = null;
let lastHeader = null;
let historyLoaded = false;

// CORS proxy URLs - try multiple
const CORS_PROXIES = [
  'https://api.allorigins.win/raw?url=',
  'https://corsproxy.io/?',
  ''  // Direct attempt last
];
let currentProxyIndex = 0;

function cssVar(v) {
  return getComputedStyle(document.documentElement).getPropertyValue(v).trim();
}

function makeLineChart(ctx, key) {
  const smooth = key === '10m';
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        data: [],
        borderColor: '#4da3ff',
        borderWidth: smooth ? 3 : 2,
        pointRadius: 0,
        tension: smooth ? 0.25 : 0,
        fill: smooth,
        backgroundColor: 'transparent'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {duration: 0},
      plugins: {
        legend: {display: false},
        tooltip: {mode: 'index', intersect: false, displayColors: false}
      },
      scales: {
        x: {ticks: {display: false}, grid: {display: false}},
        y: {ticks: {color: '#7f8796'}, grid: {color: key === '10m' ? 'transparent' : 'rgba(255,255,255,.05)'}}
      }
    }
  });
}

function makeBarChart(ctx) {
  return new Chart(ctx, {
    type: 'bar',
    data: {
      labels: [],
      datasets: [{data: [], backgroundColor: []}]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {duration: 0},
      plugins: {legend: {display: false}},
      scales: {
        x: {ticks: {color: '#7f8796'}},
        y: {ticks: {display: false}}
      }
    }
  });
}

function trendColor(arr) {
  if (arr.length < 2) return '#4da3ff';
  return arr[arr.length - 1].price >= arr[0].price ? cssVar('--up') : '#ff4d4d';
}

function fmtUSD(n) {
  return '$' + (n || 0).toLocaleString(undefined, {maximumFractionDigits: 2});
}

function fmtVOL(n) {
  return (n || 0).toLocaleString(undefined, {maximumFractionDigits: 3});
}

function setHeaderPrice(p) {
  headPrice.classList.remove('up', 'down');
  headPrice.textContent = fmtUSD(p);
  if (lastHeader != null) {
    if (p > lastHeader) headPrice.classList.add('up');
    else if (p < lastHeader) headPrice.classList.add('down');
  }
  lastHeader = p;
}

let needlePos = 0.5;
const biasGauge = document.getElementById('biasGauge');
const needle = document.getElementById('needle');
const needleValue = document.getElementById('needleValue');

function drawGauge(buy, sell) {
  if (!biasGauge) return;
  const ctx = biasGauge.getContext('2d');
  const w = biasGauge.width = biasGauge.offsetWidth;
  const h = biasGauge.height = biasGauge.offsetHeight;
  ctx.clearRect(0, 0, w, h);
  const tot = buy + sell;
  const target = tot ? buy / tot : 0.5;
  needlePos += (target - needlePos) * 0.25;
  const up = cssVar('--up');
  const dn = cssVar('--down');
  const g = ctx.createLinearGradient(0, 0, w, 0);
  g.addColorStop(0, up);
  g.addColorStop(Math.max(0, needlePos - 0.001), up);
  g.addColorStop(Math.min(1, needlePos + 0.001), dn);
  g.addColorStop(1, dn);
  const r = h / 2;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(r, 1);
  ctx.lineTo(w - r, 1);
  ctx.arcTo(w - 1, 1, w - 1, r, r);
  ctx.lineTo(w - 1, h - r);
  ctx.arcTo(w - 1, h - 1, w - r, h - 1, r);
  ctx.lineTo(r, h - 1);
  ctx.arcTo(1, h - 1, 1, h - r, r);
  ctx.lineTo(1, r);
  ctx.arcTo(1, 1, r, 1, r);
  ctx.fill();
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = needlePos >= 0.5 ? up : dn;
  const domW = needlePos >= 0.5 ? w * needlePos : w * (1 - needlePos);
  const domX = needlePos >= 0.5 ? 0 : w * needlePos;
  ctx.fillRect(domX, 1, domW, h - 2);
  ctx.globalAlpha = 1;
  const leftPx = Math.round(biasGauge.getBoundingClientRect().width * needlePos);
  needle.style.left = leftPx + 'px';
  const biasPct = tot ? ((buy - sell) / tot) * 100 : 0;
  needleValue.textContent = (biasPct >= 0 ? '+' : '') + biasPct.toFixed(0) + '%';
  needleValue.style.left = leftPx + 'px';
}

TF.forEach(t => {
  stateMap[t.key] = {
    arr: [],
    tLast: 0,
    pc: makeLineChart(document.getElementById('c-' + t.key).getContext('2d'), t.key),
    vc: makeBarChart(document.getElementById('v-' + t.key).getContext('2d'))
  };
});

function redraw(key) {
  const tf = TF.find(x => x.key === key);
  const s = stateMap[key];
  const now = Date.now();
  s.arr = s.arr.filter(pt => pt.t >= now - tf.win);
  const labels = s.arr.map(pt => new Date(pt.t).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}));
  const prices = s.arr.map(pt => pt.price);
  const vols = s.arr.map(pt => pt.vol || 0);
  
  const pc = s.pc;
  pc.data.labels = labels;
  pc.data.datasets[0].data = prices;
  const col = trendColor(s.arr);
  pc.data.datasets[0].borderColor = col;
  
  if (key === '10m' && pc.chartArea) {
    const ca = pc.chartArea;
    const g = pc.ctx.createLinearGradient(0, ca.top, 0, ca.bottom);
    g.addColorStop(0, col.replace('rgb', 'rgba').replace(')', ', 0.22)'));
    g.addColorStop(1, col.replace('rgb', 'rgba').replace(')', ', 0.02)'));
    pc.data.datasets[0].backgroundColor = g;
  }
  pc.update('none');
  
  const tfP = document.getElementById('tfc-' + key);
  const hlP = document.getElementById('hlc-' + key);
  const voP = document.getElementById('volc-' + key);
  
  if (prices.length) {
    const first = prices[0];
    const last = prices[prices.length - 1];
    const delta = last - first;
    const pct = first ? (delta / first) * 100 : 0;
    tfP.textContent = (delta >= 0 ? '▲ ' : '▼ ') + fmtUSD(Math.abs(delta)) + ' (' + Math.abs(pct).toFixed(2) + '%)';
    tfP.className = 'pill ' + (delta >= 0 ? 'up' : 'down');
    hlP.textContent = 'H/L ' + fmtUSD(Math.max(...prices)) + ' / ' + fmtUSD(Math.min(...prices));
    voP.textContent = 'Vol ' + fmtVOL(vols.reduce((a, b) => a + b, 0));
  } else {
    tfP.textContent = '—';
    tfP.className = 'pill muted';
    hlP.textContent = 'H/L — / —';
    voP.textContent = 'Vol —';
  }
  
  const bins = tf.bin;
  const start = now - tf.win;
  const w = tf.win / bins;
  const ag = Array.from({length: bins}, (_, i) => ({
    start: start + i * w,
    vol: 0,
    first: null,
    last: null
  }));
  
  s.arr.forEach(pt => {
    const i = Math.min(bins - 1, Math.max(0, Math.floor((pt.t - start) / w)));
    const b = ag[i];
    b.vol += pt.vol || 0;
    if (b.first === null) b.first = pt.price;
    b.last = pt.price;
  });
  
  const vc = s.vc;
  vc.data.labels = ag.map(x => new Date(x.start).toLocaleTimeString([], {minute: '2-digit'}));
  vc.data.datasets[0].data = ag.map(x => x.vol);
  vc.data.datasets[0].backgroundColor = ag.map(x => 
    x.first === null ? '#7f8796' : 
    x.last >= x.first ? cssVar('--up') : cssVar('--down')
  );
  vc.update('none');
  
  if (key === '10m') {
    let buy = 0;
    let sell = 0;
    ag.forEach(x => {
      if (x.first !== null) {
        if (x.last >= x.first) buy += x.vol;
        else sell += x.vol;
      }
    });
    drawGauge(buy, sell);
  }
}

async function fetchWithProxy(url) {
  for (let i = 0; i < CORS_PROXIES.length; i++) {
    try {
      const proxyUrl = CORS_PROXIES[i] + encodeURIComponent(url);
      console.log(`Trying proxy ${i}: ${CORS_PROXIES[i]}`);
      const response = await fetch(proxyUrl);
      if (response.ok) {
        console.log(`Success with proxy ${i}`);
        currentProxyIndex = i;
        return await response.json();
      }
    } catch (e) {
      console.log(`Proxy ${i} failed:`, e.message);
    }
  }
  throw new Error('All proxies failed');
}

async function fetchBinanceHistory(tf) {
  try {
    const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${tf.binanceInterval}&limit=${tf.binanceLimit}`;
    console.log(`Fetching history for ${tf.key}`);
    
    const data = await fetchWithProxy(url);
    
    if (Array.isArray(data) && data.length > 0) {
      const points = data.map(k => ({
        t: k[0],
        price: parseFloat(k[4]),
        vol: parseFloat(k[5])
      }));
      
      console.log(`Got ${points.length} points for ${tf.key}, price range: $${Math.min(...points.map(p=>p.price))} - $${Math.max(...points.map(p=>p.price))}`);
      return points;
    }
    throw new Error('No data');
  } catch (e) {
    console.error(`Failed to fetch history for ${tf.key}:`, e);
    return null;
  }
}

async function loadHistoricalData() {
  histEl.textContent = 'History: Loading via proxy...';
  console.log('Loading historical data...');
  
  const results = await Promise.all(TF.map(tf => fetchBinanceHistory(tf)));
  
  let successCount = 0;
  results.forEach((points, i) => {
    const tf = TF[i];
    const s = stateMap[tf.key];
    
    if (points && points.length > 0) {
      s.arr = points;
      if (lastPriceGlobal === null) {
        lastPriceGlobal = points[points.length - 1].price;
      }
      successCount++;
    }
    
    redraw(tf.key);
  });
  
  if (successCount > 0) {
    histEl.textContent = `History: Loaded (${successCount}/4)`;
    historyLoaded = true;
    if (lastPriceGlobal) {
      setHeaderPrice(lastPriceGlobal);
    }
  } else {
    histEl.textContent = 'History: Failed (CORS blocked)';
  }
}

function onQuote(p, v) {
  if (!Number.isFinite(p) || p <= 0) return;
  
  if (!historyLoaded) {
    return;
  }
  
  lastPriceGlobal = p;
  setHeaderPrice(p);
  const n = Date.now();
  TF.forEach(t => {
    const s = stateMap[t.key];
    if (n - s.tLast >= t.sample) {
      s.arr.push({
        t: n,
        price: p,
        vol: Number.isFinite(v) && v > 0 ? v : 0.1
      });
      s.tLast = n;
    }
    redraw(t.key);
  });
}

async function fetchPrice() {
  try {
    const url = 'https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT';
    const data = await fetchWithProxy(url);
    if (data && data.lastPrice) {
      onQuote(parseFloat(data.lastPrice), parseFloat(data.volume));
      liveEl.textContent = 'Live: Binance ✓';
    }
  } catch (e) {
    console.error('Price fetch failed:', e);
    liveEl.textContent = 'Live: Error';
  }
}

console.log('BTC Dashboard v2.4 starting with CORS proxy...');

loadHistoricalData().then(() => {
  console.log('Starting live updates');
  setTimeout(fetchPrice, 1000);
  setInterval(fetchPrice, 3000);
});
</script>
</body>
</html>
