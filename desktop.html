<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>10m Locked Chart + Volume</title>
<style>
  :root{
    --bg:#0a0a0a; --panel:#111; --panel-2:#0d0d0d;
    --text:#e9fef7; --muted:#c8d6cf;
    --up:#2dd4bf; --down:#f59e0b;
    --grid:rgba(255,255,255,.08); --grid-2:rgba(255,255,255,.06);
    --pill-bg:rgba(0,0,0,.75); --pill-bd:rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
  .wrap{padding:12px;max-width:1200px;margin:0 auto}
  .card{background:var(--panel);border-radius:14px;box-shadow:0 0 0 1px rgba(255,255,255,.06),0 18px 40px rgba(0,0,0,.45)}
  .header{display:flex;align-items:center;gap:10px;padding:10px 12px}
  .title{font-weight:800;letter-spacing:.3px;opacity:.9}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:var(--pill-bg);border:1px solid var(--pill-bd);font-size:12px;white-space:nowrap}
  .bigPrice{margin-left:auto;font-weight:900;font-size:clamp(20px,4.8vw,36px)}
  .bigPrice.up{color:var(--up)} .bigPrice.down{color:var(--down)}
  .box{padding:10px}
  canvas{display:block;width:100%;height:260px;border-radius:12px;background:var(--panel-2)}
  #volCanvas{height:190px;margin-top:8px}
  .conn{position:fixed;left:10px;bottom:10px}
</style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <div class="header">
        <span class="title">10 minute — locked bars</span>
        <span id="livePill" class="pill">Live</span>
        <div id="bigPrice" class="bigPrice">$—</div>
      </div>
      <div class="box">
        <canvas id="priceCanvas"></canvas>
        <canvas id="volCanvas"></canvas>
      </div>
    </section>
    <span id="conn" class="pill conn">Connecting…</span>
  </main>

<script>
/* Elements */
const priceCanvas = document.getElementById('priceCanvas');
const volCanvas   = document.getElementById('volCanvas');
const connPill    = document.getElementById('conn');
const priceEl     = document.getElementById('bigPrice');

/* Formatting */
const fmtUSD = (v,d=0)=>new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:d}).format(v);

/* State (minute buckets) */
const MS_MIN = 60_000, MS10 = 600_000;
let buckets = []; // each: {start, open, high, low, close, buy, sell, locked:true/false}
let lastPrice = null;

/* Helpers */
const floorMin = ts => ts - (ts % MS_MIN);

function ensureBuckets(nowTs){
  // Keep a 10-slot ring from (now - 9min) to now (aligned)
  const startAligned = floorMin(nowTs) - 9*MS_MIN;
  if (buckets.length === 0){
    for(let i=0;i<10;i++){
      buckets.push({ start:startAligned + i*MS_MIN, open:null, high:null, low:null, close:null, buy:0, sell:0, locked:false });
    }
    return;
  }
  // Slide window forward when world time advances past our last slot
  while (buckets[buckets.length-1].start < floorMin(nowTs)){
    // finalize the previous current minute (lock it)
    buckets[buckets.length-1].locked = true;
    // drop leftmost and push a new empty minute on the right
    buckets.shift();
    const lastStart = buckets[buckets.length-1].start;
    buckets.push({ start:lastStart + MS_MIN, open:null, high:null, low:null, close:null, buy:0, sell:0, locked:false });
  }
}

function ingestTrade(p, size, side, ts){
  ensureBuckets(ts);
  // find current minute slot
  const mStart = floorMin(ts);
  const b = buckets.find(x => x.start === mStart);
  if (!b) return;
  // only mutate the live (unlocked) bucket
  if (b.locked) return;

  if (b.open == null) b.open = p, b.high = p, b.low = p, b.close = p;
  b.close = p;
  if (p > b.high) b.high = p;
  if (p < b.low)  b.low  = p;
  if (side === 'sell') b.sell += size; else b.buy += size;

  // header price blip
  if (lastPrice != null){
    priceEl.classList.remove('up','down');
    if (p > lastPrice) priceEl.classList.add('up');
    else if (p < lastPrice) priceEl.classList.add('down');
  }
  lastPrice = p;
  priceEl.textContent = fmtUSD(p,2);
}

/* Drawing */
function sizeCanvas(c){
  const dpr = Math.min(3, window.devicePixelRatio || 1);
  c.width = Math.max(1, c.clientWidth*dpr);
  c.height= Math.max(1, c.clientHeight*dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}

function drawPrice(){
  const ctx = sizeCanvas(priceCanvas);
  const w = priceCanvas.clientWidth, h = priceCanvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if (!buckets.length) return;
  const vis = buckets; // exactly 10 fixed slots

  // build series from minute CLOSES (classic “normal” chart)
  const closes = vis.map(b => (b.close ?? b.open ?? null)).filter(v=>v!=null);
  if (closes.length < 2) return;

  const vals = vis.map(b => {
    const v = (b.close ?? b.open ?? null);
    return (v==null? null : v);
  });

  // min/max over visible numeric points
  const num = vals.filter(v=>v!=null);
  const min = Math.min(...num), max = Math.max(...num);
  const range = (max-min) || 1;

  const padX = 36, padY = 18;
  const grid = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();

  // grid
  ctx.strokeStyle = grid;
  for (let i=1;i<=3;i++){
    const y = padY + (h-2*padY)*(i/4*(4/3));
    ctx.beginPath(); ctx.moveTo(padX,y); ctx.lineTo(w-padX,y); ctx.stroke();
  }

  // avg line
  const avg = num.reduce((a,v)=>a+v,0)/num.length;
  const yAvg= padY + (h-2*padY)*(1-(avg-min)/range);
  ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,.35)';
  ctx.beginPath(); ctx.moveTo(padX,yAvg); ctx.lineTo(w-padX,yAvg); ctx.stroke();
  ctx.setLineDash([]);

  // x layout: 10 equal columns
  const cols = 10;
  const plotW = (w - 2*padX);
  const step = plotW / cols;

  // smooth line through close points at the center of each column
  const points = vis.map((b,i)=>{
    const v = (b.close ?? b.open);
    if (v==null) return null;
    const x = padX + i*step + step/2;
    const y = padY + (h-2*padY)*(1-(v-min)/range);
    return {x,y,v};
  }).filter(Boolean);

  if (points.length < 2) return;

  // Catmull–Rom → Bezier
  const up = getComputedStyle(document.body).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.body).getPropertyValue('--down').trim();
  ctx.lineWidth = 2.25; ctx.lineJoin='round'; ctx.lineCap='round';

  ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
  for(let i=0;i<points.length-1;i++){
    const p0=points[i-1]||points[i], p1=points[i], p2=points[i+1], p3=points[i+2]||p2;
    const t=.5;
    const d1x=(p2.x-p0.x)*t, d1y=(p2.y-p0.y)*t;
    const d2x=(p3.x-p1.x)*t, d2y=(p3.y-p1.y)*t;
    const c1={x:p1.x+d1x/3,y:p1.y+d1y/3}, c2={x:p2.x-d2x/3,y:p2.y-d2y/3};
    // segment color: above avg = up, below = down
    ctx.strokeStyle = ( (p1.v+p2.v)/2 >= avg ) ? up : dn;
    ctx.beginPath();
    ctx.moveTo(p1.x,p1.y);
    ctx.bezierCurveTo(c1.x,c1.y,c2.x,c2.y,p2.x,p2.y);
    ctx.stroke();
  }

  // y labels
  ctx.fillStyle='rgba(255,255,255,.9)'; ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.textBaseline='middle';
  ctx.fillText(fmtUSD(max,0), 8, padY+4);
  ctx.fillText(fmtUSD(avg,0), 8, Math.max(padY+12, Math.min(h-padY-12, yAvg)));
  ctx.fillText(fmtUSD(min,0), 8, h-padY-4);

  // x labels (minute ticks)
  ctx.fillStyle='rgba(255,255,255,.8)'; ctx.textAlign='center'; ctx.textBaseline='top';
  for(let i=0;i<cols;i+=2){
    const x = padX + i*step + step/2;
    const t = new Date(vis[i].start).toLocaleTimeString([],{minute:'2-digit'});
    ctx.fillText(':'+t, x, h-16);
  }
}

function drawVol(){
  const ctx = sizeCanvas(volCanvas);
  const w = volCanvas.clientWidth, h = volCanvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if (!buckets.length) return;
  const vis = buckets;

  // scale uses totals of finalized+current but capped so top pill won’t get clipped
  const totals = vis.map(b => (b.buy + b.sell));
  const max = Math.max(0.01, ...totals);
  const padX=28, padTop=10, padBottom=24;
  const plotH = h - padTop - padBottom;
  const cols = 10;
  const plotW = (w - 2*padX);
  const step = plotW / cols;
  const barW = step * 0.62;

  const up = getComputedStyle(document.body).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.body).getPropertyValue('--down').trim();

  // faint grid
  ctx.strokeStyle='var(--grid-2)';
  for(let i=1;i<=2;i++){
    const gy = padTop + plotH*(i/3*(3/2));
    ctx.beginPath(); ctx.moveTo(padX-6,gy); ctx.lineTo(w-padX+6,gy); ctx.stroke();
  }

  // draw bars
  ctx.font='11px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.textBaseline='bottom'; ctx.textAlign='center';

  for (let i=0;i<cols;i++){
    const b = vis[i];
    const xC = padX + i*step + step/2;
    const tot = b.buy + b.sell;
    const hT  = Math.max(4, (tot/max)*plotH);
    const yB  = padTop + plotH;

    const hBuy = tot ? (b.buy/tot)*hT : 0;
    const hSell= hT - hBuy;

    // stacked rectangles
    ctx.fillStyle = dn; ctx.fillRect(xC-barW/2, yB - hSell, barW, hSell);
    ctx.fillStyle = up; ctx.fillRect(xC-barW/2, yB - hSell - hBuy, barW, hBuy);

    // TOTAL pill on top only if non-zero
    if (tot > 0){
      const label = `₿${tot.toFixed(2)}`;
      const tw = ctx.measureText(label).width + 12, th=18;
      const bx = xC - tw/2, by = yB - hT - th - 4;
      // keep inside
      const safeBy = Math.max(4, by);
      ctx.fillStyle='rgba(0,0,0,.85)';
      ctx.strokeStyle='rgba(255,255,255,.25)';
      // rounded rect
      ctx.beginPath();
      const r=9;
      ctx.moveTo(bx+r,safeBy);
      ctx.arcTo(bx+tw,safeBy,bx+tw,safeBy+th,r);
      ctx.arcTo(bx+tw,safeBy+th,bx,safeBy+th,r);
      ctx.arcTo(bx,safeBy+th,bx,safeBy,r);
      ctx.arcTo(bx,safeBy,bx+tw,safeBy,r);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle='#fff';
      ctx.textBaseline='middle';
      ctx.fillText(label, xC, safeBy + th/2);
    }

    // +/- diff pill inside if bar tall enough
    if (hT > 26){
      const diff = b.buy - b.sell;
      const txt = `${diff>=0?'+':''}${diff.toFixed(2)}`;
      const tw = ctx.measureText(txt).width+12, th=18;
      const bx = xC - tw/2, by = yB - hT + 4;
      ctx.fillStyle='rgba(0,0,0,.85)';
      ctx.strokeStyle='rgba(255,255,255,.25)';
      ctx.beginPath();
      const r=9;
      ctx.moveTo(bx+r,by);
      ctx.arcTo(bx+tw,by,bx+tw,by+th,r);
      ctx.arcTo(bx+tw,by+th,bx,by+th,r);
      ctx.arcTo(bx,by+th,bx,by,r);
      ctx.arcTo(bx,by,bx+tw,by,r);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = diff>=0 ? up : dn;
      ctx.textBaseline='middle';
      ctx.fillText(txt, xC, by + th/2);
    }

    // bottom minute labels every other bar
    if (i%2===0){
      ctx.fillStyle='rgba(255,255,255,.85)'; ctx.textBaseline='top'; ctx.textAlign='center';
      const t = new Date(b.start).toLocaleTimeString([],{minute:'2-digit'});
      ctx.fillText(':'+t, xC, h-16);
    }
  }
}

/* Loop */
function frame(){
  drawPrice();
  drawVol();
  requestAnimationFrame(frame);
}

/* WS feed */
let ws, recon;
function connect(){
  try{ ws && ws.close(); }catch{}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  connPill.textContent = 'Connecting…';
  ws.onopen = ()=>{
    ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
    connPill.textContent = 'Live';
  };
  ws.onmessage = (e)=>{
    try{
      const m = JSON.parse(e.data);
      if (m.type==='match' && m.product_id==='BTC-USD'){
        ingestTrade(+m.price, +m.size, m.side, new Date(m.time).getTime());
      }
    }catch{}
  };
  ws.onclose = ()=>{
    connPill.textContent = 'Reconnecting…';
    recon = setTimeout(connect, 1000);
  };
  ws.onerror = ()=>{
    try{ ws.close(); }catch{}
  };
}
connect();

/* Minute boundary keeper — locks previous minute promptly even without trades */
setInterval(()=>{
  ensureBuckets(Date.now());
}, 1500);

/* Resize */
new ResizeObserver(()=>{ drawPrice(); drawVol(); }).observe(document.body);

/* Kick */
requestAnimationFrame(frame);
</script>
</body>
</html>