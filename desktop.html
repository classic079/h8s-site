<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>BTC Stalker - Multi-Timeframe v3.7</title>
<style>
:root{
  --bg:#0a0a0a; --panel:#111; --panel-2:#0d0d0d;
  --text:#e9fef7; --muted:#c8d6cf;
  --up:#2dd4bf; --down:#f59e0b;
  --grid:rgba(255,255,255,.08);
  --glow:0 0 0 1px rgba(255,255,255,.06), 0 18px 40px rgba(0,0,0,.45);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}

.wrap{max-width:1920px;margin:16px auto 28px;padding:0 16px}

/* Header */
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;flex-wrap:wrap;gap:10px}
.headerLeft{display:flex;gap:8px;align-items:center}
.headerCenter{flex:1;text-align:center}
.headerRight{display:flex;gap:8px;align-items:center}
#livePrice{font-weight:900;font-size:clamp(24px,4vw,42px);letter-spacing:.4px;transition:color .18s}
#livePrice.up{color:var(--up)}
#livePrice.down{color:var(--down)}

/* Pills */
.pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;
  border-radius:999px;background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.22);
  font-size:11px;white-space:nowrap;color:#fff;opacity:.92}
.pill.flash{animation:flashy .4s ease-out}
@keyframes flashy{0%{opacity:.5}60%{opacity:1}100%{opacity:.92}}
#connPill{position:fixed;left:12px;bottom:12px;z-index:50}
.conn-ok{color:var(--up);border-color:var(--up)}
.conn-warn{color:#fbbf24;border-color:#fbbf24}
.conn-err{color:#fb7185;border-color:#fb7185}

/* Grid */
.grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
@media(max-width:1500px){.grid{grid-template-columns:repeat(2,1fr)}}
@media(max-width:760px){.grid{grid-template-columns:1fr}}

/* Column cards */
.col{background:var(--panel);border-radius:14px;box-shadow:var(--glow);padding:10px;display:flex;flex-direction:column}
.colHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.tfLabel{font-weight:800;font-size:13px;letter-spacing:.5px;text-transform:uppercase;color:var(--muted)}
.statPills{display:flex;gap:6px;flex-wrap:wrap}
.statPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.6);color:#fff;white-space:nowrap}
.statPill.up{background:var(--up);border-color:transparent;color:#0a0a0a;font-weight:700}
.statPill.down{background:var(--down);border-color:transparent;color:#0a0a0a;font-weight:700}

/* Charts */
.chartBox{background:var(--panel-2);border-radius:10px;height:200px;margin-bottom:8px;position:relative}
.chartBox canvas{display:block;width:100%;height:100%;border-radius:10px}
.volBox{background:var(--panel-2);border-radius:10px;height:140px}
.volBox canvas{display:block;width:100%;height:100%;border-radius:10px}

/* Gauge (10m only) */
.gaugeRow{display:flex;align-items:center;gap:8px;padding:6px 8px;margin-top:8px}
.gLabel{font-size:11px;opacity:.9}
.gLabel.buy{color:var(--up)}.gLabel.sell{color:var(--down)}
[id^="biasGauge-"]{width:100%;height:20px;border-radius:999px;background:transparent;box-shadow:inset 0 0 0 1px rgba(255,255,255,.12)}
.gaugeWrap{position:relative;flex:1}
.needle{position:absolute;top:2px;width:0;height:0;border-left:6px solid transparent;
  border-right:6px solid transparent;border-top:9px solid #fff;
  filter:drop-shadow(0 2px 2px rgba(0,0,0,.35));transition:left .2s}
.needleValue{position:absolute;top:-13px;transform:translateX(-50%);
  background:rgba(0,0,0,.8);color:#fff;font-size:10px;padding:2px 6px;
  border-radius:8px;border:1px solid rgba(255,255,255,.25)}

/* Metric pills */
.metricPills{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin:8px 0}
.metricPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.1);background:rgba(0,0,0,.5);color:#cbd5e1;white-space:nowrap}

/* Top trades */
.topTrades{margin-top:10px;padding:8px}
.topHeader{font-size:11px;font-weight:700;margin-bottom:8px;opacity:.9}
.topGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.topCol{border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:6px 6px 4px}
.topCol h4{margin:2px 6px 6px;font-size:11px;letter-spacing:.4px;text-transform:uppercase;white-space:nowrap}
.buyCol{background:color-mix(in oklab, var(--up) 12%, transparent);border-color:color-mix(in oklab, var(--up) 35%, transparent)}
.sellCol{background:color-mix(in oklab, var(--down) 12%, transparent);border-color:color-mix(in oklab, var(--down) 35%, transparent)}
.topList{list-style:none;margin:0;padding:0;font-variant-numeric:tabular-nums}
.topItem{padding:7px 6px;border-radius:8px;font-size:13px;display:flex;gap:8px;align-items:baseline}
.topItem .usd{font-weight:800;color:#fff;flex:0 0 auto}
.topItem .btc{color:rgba(233,254,247,.85);flex:0 0 auto}
.topItem .t{color:rgba(233,254,247,.65);flex:0 0 auto;font-size:12px}
</style>
</head>
<body>
<span id="connPill" class="pill conn-warn">Connecting…</span>

<div class="wrap">
  <header>
    <div class="headerLeft">
      <span class="pill">BTC/USD</span>
      <span class="pill" style="opacity:.6">v3.7</span>
      <span id="d24Change" class="pill">24h Δ —</span>
    </div>
    <div class="headerCenter">
      <div id="livePrice">$—</div>
    </div>
    <div class="headerRight">
      <span id="d24HiLo" class="pill">H/L —</span>
      <span id="d24Vol" class="pill">Vol —</span>
    </div>
  </header>

  <section class="grid" id="dashboard"></section>
</div>

<script>
/* ===== Config ===== */
const TF = [
  {key:'24h', label:'24 HOURS', win:86400000, bins:12, binSize:7200000},  // 12 bars x 2hr each
  {key:'8h',  label:'8 HOURS',  win:28800000, bins:12, binSize:2400000},  // 12 bars x 40min each
  {key:'1h',  label:'1 HOUR',   win:3600000,  bins:12, binSize:300000},
  {key:'10m', label:'10 MIN',   win:600000,   bins:10, binSize:60000}
];

/* ===== Elements ===== */
const priceEl = document.getElementById('livePrice');
const connPill = document.getElementById('connPill');
const d24Change = document.getElementById('d24Change');
const d24HiLo = document.getElementById('d24HiLo');
const d24Vol = document.getElementById('d24Vol');

/* ===== Formatters ===== */
const fmtUSD = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtUSD0 = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
const fmtUSDChange = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2,signDisplay:'always'});
const fmtBTC = new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
const pct1 = new Intl.NumberFormat(undefined,{maximumFractionDigits:1});

/* ===== State ===== */
let lastPrice = null;
let win24h = [], win8h = [], win1h = [], win10m = [];
let win24hVol = [], win8hVol = [], win1hVol = [], win10mVol = []; // Separate volume tracking
let win24hLive = [], win8hLive = [], win1hLive = [], win10mLive = []; // Live trades only (for avg/median)
let last24hSample = 0, last8hSample = 0, last1hSample = 0, last10mSample = 0;
const SAMPLE_INTERVALS = {
  '24h': 300000,  // 5 minutes
  '8h': 120000,   // 2 minutes
  '1h': 60000,    // 1 minute
  '10m': 500      // 0.5 seconds
};

/* ===== Build DOM ===== */
const dash = document.getElementById('dashboard');
dash.innerHTML = TF.map(t => `
<div class="col" id="col-${t.key}">
  <div class="colHeader">
    <div class="tfLabel">${t.label}</div>
    <div class="statPills" id="pills-${t.key}">
      <span class="statPill" id="vol-${t.key}">Vol —</span>
      <span class="statPill" id="hl-${t.key}">H/L —</span>
    </div>
  </div>
  <div class="chartBox"><canvas id="chart-${t.key}"></canvas></div>
  ${(t.key==='1h' || t.key==='10m') ? `<div class="gaugeRow">
    <span class="gLabel buy">Buys</span>
    <div class="gaugeWrap">
      <canvas id="biasGauge-${t.key}"></canvas>
      <div id="needle-${t.key}" class="needle" style="left:50%"></div>
      <div id="needleValue-${t.key}" class="needleValue" style="left:50%">0%</div>
    </div>
    <span class="gLabel sell">Sells</span>
  </div>
  <div class="metricPills" id="metrics-${t.key}">
    <span class="metricPill" id="tpm-${t.key}">T/m —</span>
    <span class="metricPill" id="avg-${t.key}">Avg —</span>
    <span class="metricPill" id="med-${t.key}">Med —</span>
    <span class="metricPill" id="vwap-${t.key}">VWAP —</span>
  </div>` : ''}
  <div class="volBox"><canvas id="volChart-${t.key}"></canvas></div>
  <div class="topTrades">
    <div class="topHeader">Top Trades</div>
    <div class="topGrid">
      <div class="topCol buyCol">
        <h4>Buys</h4>
        <ul class="topList" id="topBuys-${t.key}"></ul>
      </div>
      <div class="topCol sellCol">
        <h4>Sells</h4>
        <ul class="topList" id="topSells-${t.key}"></ul>
      </div>
    </div>
  </div>
</div>
`).join('');

/* ===== Canvas helpers ===== */
function sizeCanvas(c){
  if(!c || !c.getContext) {
    console.warn('sizeCanvas: invalid canvas element', c);
    return null;
  }
  const dpr = Math.max(1, Math.min(devicePixelRatio||1, 3));
  c.width = Math.max(1, c.clientWidth*dpr);
  c.height = Math.max(1, c.clientHeight*dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}

/* ===== Stats calculation ===== */
function median(arr){
  const a=[...arr].sort((x,y)=>x-y);
  const n=a.length;
  return n?(n&1?a[(n-1)/2]:(a[n/2-1]+a[n/2])/2):NaN;
}

function calcStats(arr, windowMs){
  if(arr.length===0) return null;
  const prices = arr.map(t=>t.price);
  const hi = Math.max(...prices);
  const lo = Math.min(...prices);
  let buyVol=0, sellVol=0, buyUsd=0, sellUsd=0, totalVol=0;
  for(const t of arr){
    const usd = t.price * t.size;
    totalVol += t.size;
    if(t.side==='buy'){buyVol+=t.size; buyUsd+=usd}
    else{sellVol+=t.size; sellUsd+=usd}
  }
  const totalUsd = buyUsd + sellUsd;
  const buyRatio = totalUsd ? (buyUsd/totalUsd)*100 : 50;

  // VWAP (Volume Weighted Average Price)
  const vwap = totalVol > 0 ? totalUsd / totalVol : 0;

  // Trades per minute
  const minutes = windowMs / 60000;
  const tradesPerMin = minutes > 0 ? arr.length / minutes : 0;

  return {
    first: prices[0],
    last: prices[prices.length-1],
    hi, lo,
    buyVol, sellVol,
    buyRatio,
    count: arr.length,
    vwap,
    tradesPerMin
  };
}

// Calculate avg/median from LIVE trades only (not historical candles)
function calcLiveTradeStats(liveArr){
  if(liveArr.length === 0) return null;

  const usdTrades = [];
  for(const t of liveArr){
    const usd = t.price * t.size;
    usdTrades.push(usd);
  }

  // Avg trade size (USD)
  const totalUsd = usdTrades.reduce((sum, val) => sum + val, 0);
  const avgTradeUsd = usdTrades.length > 0 ? totalUsd / usdTrades.length : 0;

  // Median trade size (USD)
  usdTrades.sort((a,b)=>a-b);
  const medTradeUsd = usdTrades.length > 0 ? usdTrades[Math.floor(usdTrades.length/2)] : 0;

  return { avgTradeUsd, medTradeUsd };
}

/* ===== Trade ingestion ===== */
function onTrade(t){
  const p = t.price;
  const s = t.size;
  const side = t.side==='sell' ? 'sell' : 'buy';
  const time = t.time.getTime();

  // Update price display (always)
  if(lastPrice !== null){
    priceEl.classList.remove('up','down');
    if(p>lastPrice) priceEl.classList.add('up');
    else if(p<lastPrice) priceEl.classList.add('down');
  }
  lastPrice = p;
  priceEl.textContent = fmtUSD.format(p);

  // Sample at different rates for price charts
  const now = Date.now();
  const trade = {price:p, size:s, side, time};

  if(now - last24hSample >= SAMPLE_INTERVALS['24h']){
    win24h.push(trade);
    last24hSample = now;
  }
  if(now - last8hSample >= SAMPLE_INTERVALS['8h']){
    win8h.push(trade);
    last8hSample = now;
  }
  if(now - last1hSample >= SAMPLE_INTERVALS['1h']){
    win1h.push(trade);
    last1hSample = now;
  }
  if(now - last10mSample >= SAMPLE_INTERVALS['10m']){
    win10m.push(trade);
    last10mSample = now;
  }

  // Add ALL trades to volume windows (no sampling)
  win24hVol.push(trade);
  win8hVol.push(trade);
  win1hVol.push(trade);
  win10mVol.push(trade);

  // Add to LIVE trade arrays (for avg/median calculation)
  win24hLive.push(trade);
  win8hLive.push(trade);
  win1hLive.push(trade);
  win10mLive.push(trade);

  prune();
  updateAll();
}

function prune(){
  const now = Date.now();
  win24h = win24h.filter(t => t.time >= now - 86400000);
  win8h = win8h.filter(t => t.time >= now - 28800000);
  win1h = win1h.filter(t => t.time >= now - 3600000);
  win10m = win10m.filter(t => t.time >= now - 600000);

  win24hVol = win24hVol.filter(t => t.time >= now - 86400000);
  win8hVol = win8hVol.filter(t => t.time >= now - 28800000);
  win1hVol = win1hVol.filter(t => t.time >= now - 3600000);
  win10mVol = win10mVol.filter(t => t.time >= now - 600000);

  win24hLive = win24hLive.filter(t => t.time >= now - 86400000);
  win8hLive = win8hLive.filter(t => t.time >= now - 28800000);
  win1hLive = win1hLive.filter(t => t.time >= now - 3600000);
  win10mLive = win10mLive.filter(t => t.time >= now - 600000);
}

/* ===== Update stats & charts ===== */
function updateAll(){
  TF.forEach(tf => {
    const arr = tf.key==='24h' ? win24h : tf.key==='8h' ? win8h : tf.key==='1h' ? win1h : win10m;
    const volArr = tf.key==='24h' ? win24hVol : tf.key==='8h' ? win8hVol : tf.key==='1h' ? win1hVol : win10mVol;
    const liveArr = tf.key==='24h' ? win24hLive : tf.key==='8h' ? win8hLive : tf.key==='1h' ? win1hLive : win10mLive;

    const stats = calcStats(volArr, tf.win); // Use volume array for stats, pass window size
    const liveStats = calcLiveTradeStats(liveArr); // Calculate avg/median from live trades only

    if(stats){
      document.getElementById(`vol-${tf.key}`).textContent = `Vol ₿${fmtBTC.format(stats.buyVol + stats.sellVol)}`;
      document.getElementById(`hl-${tf.key}`).textContent = `H/L ${fmtUSD0.format(stats.hi)} / ${fmtUSD0.format(stats.lo)}`;

      // Update metric pills (only for 1h and 10m)
      if(tf.key === '1h' || tf.key === '10m'){
        document.getElementById(`tpm-${tf.key}`).textContent = `T/m ${stats.tradesPerMin.toFixed(1)}`;
        document.getElementById(`vwap-${tf.key}`).textContent = `VWAP ${fmtUSD0.format(stats.vwap)}`;

        // Show avg/median from live trades only
        if(liveStats && liveArr.length > 0){
          document.getElementById(`avg-${tf.key}`).textContent = `Avg ${fmtUSD0.format(liveStats.avgTradeUsd)}`;
          document.getElementById(`med-${tf.key}`).textContent = `Med ${fmtUSD0.format(liveStats.medTradeUsd)}`;
        } else {
          document.getElementById(`avg-${tf.key}`).textContent = `Avg —`;
          document.getElementById(`med-${tf.key}`).textContent = `Med —`;
        }
      }
    }

    drawChart(tf.key, arr); // Use sampled array for price chart
    drawVolume(tf.key, volArr, tf); // Use full volume array for volume chart

    // Only draw gauge for 1h and 10m (where live data is accurate)
    if(stats && (tf.key === '1h' || tf.key === '10m')){
      drawGauge(tf.key, stats.buyVol, stats.sellVol);
    }

    // Update top trades list
    updateTopTrades(tf.key, liveArr);
  });
}

/* ===== Update top trades ===== */
function updateTopTrades(key, liveArr){
  if(!liveArr || liveArr.length === 0) return;

  // Separate buys and sells, calculate USD value
  const buys = liveArr.filter(t => t.side === 'buy').map(t => ({
    ...t,
    usd: t.price * t.size
  }));
  const sells = liveArr.filter(t => t.side === 'sell').map(t => ({
    ...t,
    usd: t.price * t.size
  }));

  // Sort by USD value, show more for 24h/8h to fill space
  buys.sort((a,b) => b.usd - a.usd);
  sells.sort((a,b) => b.usd - a.usd);
  const limit = (key === '24h' || key === '8h') ? 12 : 10;
  const top10Buys = buys.slice(0, limit);
  const top10Sells = sells.slice(0, limit);

  // Format time helper
  const formatTime = (ms) => {
    const d = new Date(ms);
    return d.toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', hour12:true}).toLowerCase();
  };

  // Update buy list
  const buyList = document.getElementById(`topBuys-${key}`);
  if(buyList){
    buyList.innerHTML = top10Buys.length > 0
      ? top10Buys.map(t => `
        <li class="topItem buy">
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`).join('')
      : '<li class="topItem" style="opacity:.5">No buys yet</li>';
  }

  // Update sell list
  const sellList = document.getElementById(`topSells-${key}`);
  if(sellList){
    sellList.innerHTML = top10Sells.length > 0
      ? top10Sells.map(t => `
        <li class="topItem sell">
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`).join('')
      : '<li class="topItem" style="opacity:.5">No sells yet</li>';
  }
}

/* ===== Chart drawing (simple line) ===== */
function drawChart(key, arr){
  const canvas = document.getElementById(`chart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length < 2) return;

  const prices = arr.map(t => t.price);
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const range = (max - min) || 1;
  const avg = prices.reduce((a,b)=>a+b,0) / prices.length;

  const padX = 10, padY = 16;

  // Average line
  const yAvg = padY + (h - 2*padY) * (1 - (avg - min)/range);
  ctx.setLineDash([4,4]);
  ctx.strokeStyle = 'rgba(200,214,207,.4)';
  ctx.beginPath();
  ctx.moveTo(padX, yAvg);
  ctx.lineTo(w-padX, yAvg);
  ctx.stroke();
  ctx.setLineDash([]);

  // Line (colored based on price vs average)
  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Draw line segments, changing color based on whether price is above/below average
  for(let i = 1; i < arr.length; i++){
    const t0 = arr[i-1];
    const t1 = arr[i];
    const x0 = padX + ((i-1)/(arr.length-1)) * (w - 2*padX);
    const y0 = padY + (h - 2*padY) * (1 - (t0.price - min)/range);
    const x1 = padX + (i/(arr.length-1)) * (w - 2*padX);
    const y1 = padY + (h - 2*padY) * (1 - (t1.price - min)/range);

    // Color based on current price vs average
    ctx.strokeStyle = t1.price >= avg ? up : dn;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  // Labels
  ctx.fillStyle = 'rgba(255,255,255,.85)';
  ctx.font = '11px system-ui';
  ctx.textBaseline = 'top';
  ctx.fillText(fmtUSD0.format(max), padX, padY);
  ctx.textBaseline = 'bottom';
  ctx.fillText(fmtUSD0.format(min), padX, h-padY);
}

/* ===== Volume bars ===== */
function drawVolume(key, arr, tf){
  const canvas = document.getElementById(`volChart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length === 0) return;

  // Create bins
  const now = Date.now();
  const start = now - tf.win;
  const bins = Array.from({length: tf.bins}, (_,i) => ({
    ts: start + i*tf.binSize,
    buy: 0,
    sell: 0
  }));

  // For 10m chart, lock completed minutes (exclude current incomplete minute)
  const lockCurrentBin = (key === '10m');
  const currentBinIdx = lockCurrentBin ? Math.floor((now - start) / tf.binSize) : -1;

  arr.forEach(t => {
    const idx = Math.min(tf.bins-1, Math.max(0, Math.floor((t.time - start) / tf.binSize)));

    // Skip current bin for 10m chart (incomplete minute)
    if(lockCurrentBin && idx === currentBinIdx) return;

    if(t.side==='buy') bins[idx].buy += t.size;
    else bins[idx].sell += t.size;
  });

  const sums = bins.map(b => b.buy + b.sell);
  const max = Math.max(1, ...sums);

  const padX = 8, padY = 8;
  const chartH = h - 2*padY;
  const barW = (w - 2*padX) / bins.length * 0.7;
  const step = (w - 2*padX) / bins.length;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  bins.forEach((b, i) => {
    const x = padX + i*step + step/2;
    const tot = b.buy + b.sell;
    const hT = Math.max(4, (tot/max) * chartH);
    const hBuy = tot ? (b.buy/tot) * hT : 0;
    const hSell = hT - hBuy;
    const yB = h - padY;

    ctx.fillStyle = dn;
    ctx.fillRect(x - barW/2, yB - hSell, barW, hSell);
    ctx.fillStyle = up;
    ctx.fillRect(x - barW/2, yB - hSell - hBuy, barW, hBuy);

    // Add volume label pills on top of bars (with max height cap)
    if(tot > 0.01){
      const label = tot >= 1 ? `₿${tot.toFixed(1)}` : `₿${tot.toFixed(2)}`;

      // Draw pill background on top of bar (capped at 80% of chart height)
      ctx.font = '9px system-ui';
      const metrics = ctx.measureText(label);
      const pillW = metrics.width + 8;
      const pillH = 14;
      const pillX = x - pillW/2;
      const maxY = padY + chartH * 0.15; // Don't go higher than 15% from top
      const pillY = Math.max(maxY, yB - hT - pillH - 2);

      ctx.fillStyle = 'rgba(0,0,0,.85)';
      ctx.beginPath();
      ctx.moveTo(pillX + 7, pillY);
      ctx.arcTo(pillX + pillW, pillY, pillX + pillW, pillY + pillH, 7);
      ctx.arcTo(pillX + pillW, pillY + pillH, pillX, pillY + pillH, 7);
      ctx.arcTo(pillX, pillY + pillH, pillX, pillY, 7);
      ctx.arcTo(pillX, pillY, pillX + pillW, pillY, 7);
      ctx.fill();

      // Draw label text
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, pillY + pillH/2);
    }

    // Add +/- DIFF pill inside bar (actual BTC difference, like mobile.html)
    if(hT > 26 && tot > 0.0001){
      const diff = b.buy - b.sell; // Actual BTC difference
      if(Math.abs(diff) > 0.0001){
        const diffLabel = `${diff>=0?'+':''}${diff.toFixed(2)}`;

        ctx.font = '10px system-ui';
        const diffMetrics = ctx.measureText(diffLabel);
        const diffPillW = diffMetrics.width + 10;
        const diffPillH = 16;
        const diffPillX = x - diffPillW/2;
        const diffPillY = yB - hT/2 - diffPillH/2; // Center of bar

        // Draw pill background (dark with border)
        ctx.fillStyle = 'rgba(0,0,0,.85)';
        ctx.strokeStyle = 'rgba(255,255,255,.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(diffPillX + 7, diffPillY);
        ctx.arcTo(diffPillX + diffPillW, diffPillY, diffPillX + diffPillW, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX + diffPillW, diffPillY + diffPillH, diffPillX, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX, diffPillY + diffPillH, diffPillX, diffPillY, 7);
        ctx.arcTo(diffPillX, diffPillY, diffPillX + diffPillW, diffPillY, 7);
        ctx.fill();
        ctx.stroke();

        // Draw diff text (colored: teal for +, orange for -)
        ctx.fillStyle = diff >= 0 ? up : dn;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(diffLabel, x, diffPillY + diffPillH/2);
      }
    }
  });
}

/* ===== Gauge ===== */
const needlePos = {};
function drawGauge(key, buyVol, sellVol){
  const canvas = document.getElementById(`biasGauge-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);

  const tot = buyVol + sellVol;
  const target = tot ? (buyVol/tot) : 0.5;

  if(!needlePos[key]) needlePos[key] = 0.5;
  needlePos[key] += (target - needlePos[key]) * 0.25;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  const g = ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0, up);
  g.addColorStop(Math.max(0, needlePos[key]-0.001), up);
  g.addColorStop(Math.min(1, needlePos[key]+0.001), dn);
  g.addColorStop(1, dn);

  const r = h/2;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(r,1);
  ctx.arcTo(w-1,1,w-1,h-1,r);
  ctx.arcTo(w-1,h-1,0,h-1,r);
  ctx.arcTo(0,h-1,0,1,r);
  ctx.arcTo(0,1,w-1,1,r);
  ctx.fill();

  const needle = document.getElementById(`needle-${key}`);
  const needleValue = document.getElementById(`needleValue-${key}`);
  if(!needle || !needleValue) return;

  const leftPx = Math.round(canvas.getBoundingClientRect().width * needlePos[key]);
  needle.style.left = leftPx + 'px';
  const biasPct = tot ? ((buyVol - sellVol)/tot)*100 : 0;
  needleValue.textContent = (biasPct>=0?'+':'') + biasPct.toFixed(0) + '%';
  needleValue.style.left = leftPx + 'px';
}

/* ===== WebSocket + fallback ===== */
let ws, recon, lastWs=0, lastRest=0;
function setConn(state, msg){
  connPill.classList.remove('conn-ok','conn-warn','conn-err');
  connPill.classList.add(state==='ok'?'conn-ok':state==='warn'?'conn-warn':'conn-err');
  connPill.textContent = msg;
}

function startWS(){
  clearTimeout(recon);
  try{ws && ws.close()}catch{}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('warn','Connecting…');

  ws.onopen = () => {
    ws.send(JSON.stringify({
      type:'subscribe',
      product_ids:['BTC-USD'],
      channels:['matches']
    }));
  };

  ws.onmessage = e => {
    lastWs = Date.now();
    setConn('ok','Live');
    try{
      const m = JSON.parse(e.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        onTrade({
          price: +m.price,
          size: +m.size,
          side: String(m.side||'').toLowerCase(),
          time: new Date(m.time)
        });
      }
    }catch{}
  };

  ws.onclose = () => {
    setConn('warn','Reconnecting…');
    recon = setTimeout(startWS, 1000);
  };

  ws.onerror = () => {
    setConn('err','Fallback');
    try{ws.close()}catch{}
  };
}

async function restFallback(){
  const QUIET = 3500;
  const now = Date.now();

  try{
    if(now - lastWs >= QUIET){
      const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/trades?limit=20', {
        headers: {Accept:'application/json'}
      });
      if(r.ok){
        const arr = await r.json();
        for(let i=arr.length-1; i>=0; i--){
          const t = arr[i];
          onTrade({
            price: +t.price,
            size: +t.size,
            side: String(t.side||'').toLowerCase(),
            time: new Date(t.time||now)
          });
        }
        lastRest = now;
        setConn('err','Fallback');
        return;
      }
    }

    if(now - Math.max(lastWs, lastRest) >= QUIET){
      const r2 = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/ticker', {
        headers: {Accept:'application/json'}
      });
      if(r2.ok){
        const t = await r2.json();
        onTrade({
          price: +t.price,
          size: +(t.size||0.001),
          side: 'buy',
          time: new Date(t.time||now)
        });
        lastRest = now;
        setConn('err','Fallback');
      }
    }
  }catch{
    setConn('err','Fallback');
  }
}

/* ===== 24h stats from API ===== */
async function fetch24h(){
  try{
    const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/stats', {
      headers: {Accept:'application/json'}
    });
    if(!r.ok) throw 0;
    const j = await r.json();

    const open = +j.open;
    const last = +j.last;
    const high = +j.high;
    const low = +j.low;
    const vol = +j.volume;

    if(Number.isFinite(open) && Number.isFinite(last)){
      const diff = last - open;
      const pct = open ? (diff/open*100) : 0;
      d24Change.textContent = `24h Δ ${fmtUSDChange.format(diff)} (${pct1.format(pct)}%)`;
      d24Change.style.color = diff>0 ? 'var(--up)' : (diff<0 ? 'var(--down)' : 'var(--muted)');
    }

    if(isFinite(high) && isFinite(low)){
      d24HiLo.textContent = `H/L ${fmtUSD0.format(high)} / ${fmtUSD0.format(low)}`;
    }

    if(Number.isFinite(vol)){
      d24Vol.textContent = `Vol ${vol.toLocaleString()}`;
    }
  }catch{
    d24Change.textContent = '24h Δ —';
    d24HiLo.textContent = 'H/L —';
    d24Vol.textContent = 'Vol —';
  }
}

/* ===== Resize ===== */
let resizePending = false;
function throttledResize(){
  if(resizePending) return;
  resizePending = true;
  requestAnimationFrame(() => {
    resizePending = false;
    updateAll();
  });
}
new ResizeObserver(throttledResize).observe(document.body);
window.addEventListener('resize', throttledResize);

/* ===== Historical data from API ===== */
const iso = ms => new Date(ms).toISOString();

async function fetchHistoricalCandles(){
  try{
    // Fetch 1h of 1-min candles for 1h and 10m windows
    const end = Date.now();
    const start1h = end - 3600000;
    const url1h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=60&start=${encodeURIComponent(iso(start1h))}&end=${encodeURIComponent(iso(end))}`;

    const r1h = await fetch(url1h, {headers: {Accept:'application/json'}});
    if(r1h.ok){
      const candles = await r1h.json();
      // Candles format: [timestamp, low, high, open, close, volume]
      // Sort oldest first
      candles.sort((a,b) => a[0] - b[0]);

      candles.forEach(c => {
        const vol = +c[5]; // actual volume from candle
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};

        // Add to price arrays (sampled)
        win1h.push(buyTrade);
        win1h.push(sellTrade);
        win10m.push(buyTrade);
        win10m.push(sellTrade);

        // Add to volume arrays (for accurate volume tracking)
        win1hVol.push(buyTrade);
        win1hVol.push(sellTrade);
        win10mVol.push(buyTrade);
        win10mVol.push(sellTrade);
      });

      console.log('✅ Loaded', candles.length, '1h candles');
    }

    // Fetch 24h of 5-min candles for 24h and 8h windows
    const start24h = end - 86400000;
    const url24h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=300&start=${encodeURIComponent(iso(start24h))}&end=${encodeURIComponent(iso(end))}`;

    const r24h = await fetch(url24h, {headers: {Accept:'application/json'}});
    if(r24h.ok){
      const candles = await r24h.json();
      candles.sort((a,b) => a[0] - b[0]);

      candles.forEach(c => {
        const vol = +c[5]; // actual volume from candle
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};

        // Add to price arrays (sampled)
        win24h.push(buyTrade);
        win24h.push(sellTrade);
        win8h.push(buyTrade);
        win8h.push(sellTrade);

        // Add to volume arrays (for accurate volume tracking)
        win24hVol.push(buyTrade);
        win24hVol.push(sellTrade);
        win8hVol.push(buyTrade);
        win8hVol.push(sellTrade);
      });

      console.log('✅ Loaded', candles.length, '24h candles');
    }

    // Prune and update all charts
    prune();
    updateAll();

  }catch(e){
    console.error('Failed to load historical data:', e);
  }
}

/* ===== Start ===== */
// Wait for DOM to be fully ready before drawing
setTimeout(() => {
  fetchHistoricalCandles();
  startWS();
  fetch24h();
  setInterval(restFallback, 1200);
  setInterval(fetch24h, 60000);
}, 100);
</script>
</body>
</html>
