<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>BTC Stalker - Multi-Timeframe v9.9</title>
<style>
:root{
  --bg:#0a0a0a; --panel:#111; --panel-2:#0d0d0d;
  --text:#e9fef7; --muted:#c8d6cf;
  --up:#2dd4bf; --down:#f59e0b;
  --grid:rgba(255,255,255,.08);
  --glow:0 0 0 1px rgba(255,255,255,.06), 0 18px 40px rgba(0,0,0,.45);
}
:root[data-theme="light"]{
  --bg:#f5f7fa; --panel:#ffffff; --panel-2:#f8f9fb;
  --text:#1a1d23; --muted:#64748b;
  --up:#059669; --down:#dc2626;
  --grid:rgba(0,0,0,.08);
  --glow:0 0 0 1px rgba(0,0,0,.06), 0 8px 24px rgba(0,0,0,.08);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}

.wrap{max-width:1920px;margin:8px auto 8px;padding:0 16px}

/* Header */
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;gap:10px}
.headerLeft{display:flex;gap:8px;align-items:center}
.headerCenter{flex:1;text-align:center}
.headerRight{display:flex;gap:8px;align-items:center}
#livePrice{font-weight:900;font-size:clamp(22px,3.5vw,36px);letter-spacing:.4px;transition:color .18s}
#livePrice.up{color:var(--up)}
#livePrice.down{color:var(--down)}

/* Pills */
.pill{display:inline-flex;align-items:center;gap:6px;padding:3px 10px;
  border-radius:999px;background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.22);
  font-size:15px;white-space:nowrap;color:#fff;opacity:.92}
[data-theme="light"] .pill{background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.15);color:var(--text)}
.pill.flash{animation:flashy .4s ease-out}
@keyframes flashy{0%{opacity:.5}60%{opacity:1}100%{opacity:.92}}
#connPill{position:fixed;left:12px;bottom:12px;z-index:50}
.conn-ok{color:var(--up);border-color:var(--up)}
.conn-warn{color:#fbbf24;border-color:#fbbf24}
.conn-err{color:#fb7185;border-color:#fb7185}

/* Settings button */
.settingsBtn{cursor:pointer;transition:all .2s;user-select:none}
.settingsBtn:hover{opacity:1;transform:scale(1.05);border-color:rgba(255,255,255,.4)}
.settingsBtn:active{transform:scale(0.98)}

/* Settings modal */
.settingsModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);
  display:none;align-items:center;justify-content:center;z-index:100}
.settingsModal.open{display:flex}
.settingsContent{background:var(--panel);border-radius:16px;padding:24px;
  max-width:500px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.1)}
.settingsHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
.settingsHeader h2{margin:0;font-size:20px}
.closeBtn{cursor:pointer;font-size:24px;opacity:.7;transition:opacity .2s}
.closeBtn:hover{opacity:1}
.settingsSection{margin-bottom:20px}
.settingsSection h3{font-size:14px;margin:0 0 10px;opacity:.8;text-transform:uppercase;letter-spacing:.5px}
.settingOption{display:flex;justify-content:space-between;align-items:center;padding:10px;
  border-radius:8px;background:rgba(255,255,255,.03);margin-bottom:8px}
.settingOption:hover{background:rgba(255,255,255,.06)}
.settingOption input[type="checkbox"]{cursor:pointer;width:18px;height:18px}
.settingsActions{display:flex;gap:10px;justify-content:flex-end;margin-top:20px}
.btn{padding:10px 20px;border-radius:8px;border:none;cursor:pointer;font-size:14px;font-weight:600;transition:all .2s}
.btnPrimary{background:var(--up);color:#000}
.btnPrimary:hover{opacity:.9;transform:scale(1.02)}
.btnSecondary{background:rgba(255,255,255,.1);color:#fff;border:1px solid rgba(255,255,255,.2)}
.btnSecondary:hover{background:rgba(255,255,255,.15)}

/* Grid */
.grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
@media(max-width:1500px){.grid{grid-template-columns:repeat(2,1fr)}}
@media(max-width:760px){.grid{grid-template-columns:1fr}}

/* Column cards */
.col{background:var(--panel);border-radius:14px;box-shadow:var(--glow);padding:10px;display:flex;flex-direction:column}
.colHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.tfLabel{font-weight:800;font-size:13px;letter-spacing:.5px;text-transform:uppercase;color:var(--muted)}
.statPills{display:flex;gap:6px;flex-wrap:wrap}
.statPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.6);color:#fff;white-space:nowrap}
.statPill.up{background:var(--up);border-color:transparent;color:#0a0a0a;font-weight:700}
.statPill.down{background:var(--down);border-color:transparent;color:#0a0a0a;font-weight:700}

/* Charts */
.chartBox{background:var(--panel-2);border-radius:10px;height:200px;margin-bottom:8px;position:relative}
.chartBox canvas{display:block;width:100%;height:100%;border-radius:10px}
.volBox{background:var(--panel-2);border-radius:10px;height:120px}
.volBox canvas{display:block;width:100%;height:100%;border-radius:10px}

/* Gauge (10m only) */
.gaugeRow{display:flex;align-items:center;gap:8px;padding:6px 8px;margin-top:8px}
.gLabel{font-size:11px;opacity:.9}
.gLabel.buy{color:var(--up)}.gLabel.sell{color:var(--down)}
[id^="biasGauge-"]{width:100%;height:20px;border-radius:999px;background:transparent;box-shadow:inset 0 0 0 1px rgba(255,255,255,.12)}
.gaugeWrap{position:relative;flex:1}
.needle{position:absolute;top:2px;width:0;height:0;border-left:6px solid transparent;
  border-right:6px solid transparent;border-top:9px solid #fff;
  filter:drop-shadow(0 2px 2px rgba(0,0,0,.35));transition:left .2s}
.needleValue{position:absolute;top:-13px;transform:translateX(-50%);
  background:rgba(0,0,0,.8);color:#fff;font-size:10px;padding:2px 6px;
  border-radius:8px;border:1px solid rgba(255,255,255,.25)}

/* Metric pills */
.metricPills{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin:8px 0}
.metricPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.1);background:rgba(0,0,0,.5);color:#cbd5e1;white-space:nowrap}

/* Top trades */
.topTrades{margin-top:10px;padding:8px}
.topHeader{font-size:11px;font-weight:700;margin-bottom:8px;opacity:.9}
.topGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.topCol{border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:6px 6px 4px}
.topCol h4{margin:2px 6px 6px;font-size:11px;letter-spacing:.4px;text-transform:uppercase;white-space:nowrap}
.buyCol{background:color-mix(in oklab, var(--up) 12%, transparent);border-color:color-mix(in oklab, var(--up) 35%, transparent)}
.sellCol{background:color-mix(in oklab, var(--down) 12%, transparent);border-color:color-mix(in oklab, var(--down) 35%, transparent)}
[data-theme="light"] .buyCol{background:rgba(5,150,105,.08);border-color:rgba(5,150,105,.25)}
[data-theme="light"] .sellCol{background:rgba(220,38,38,.08);border-color:rgba(220,38,38,.25)}
.topList{list-style:none;margin:0;padding:0;font-variant-numeric:tabular-nums}
.topItem{padding:7px 6px;border-radius:8px;font-size:13px;display:flex;gap:8px;align-items:baseline}
.topItem .usd{font-weight:800;color:var(--text);flex:0 0 auto}
.topItem .btc{color:var(--muted);flex:0 0 auto}
.topItem .t{color:var(--muted);flex:0 0 auto;font-size:12px;opacity:.75}
.topItem.newTrade{animation:blinkTrade var(--blink-duration, 5s) ease-in-out}
@keyframes blinkTrade{
  0%{background:transparent;transform:scale(1);box-shadow:none}
  5%{background:rgba(255,255,0,.8);transform:scale(1.1);box-shadow:0 0 30px rgba(255,255,0,1)}
  10%,90%{background:rgba(255,255,0,.8);transform:scale(1.1);box-shadow:0 0 30px rgba(255,255,0,1)}
  95%{background:rgba(255,255,0,.4);transform:scale(1.05);box-shadow:0 0 15px rgba(255,255,0,.5)}
  100%{background:transparent;transform:scale(1);box-shadow:none}
}
.volBox.spikeAlert{animation:volSpike 3s ease-out}
@keyframes volSpike{
  0%{box-shadow:0 0 30px rgba(255,255,255,.6);transform:scale(1.02)}
  15%{box-shadow:0 0 20px rgba(255,255,255,.4)}
  30%{box-shadow:0 0 30px rgba(255,255,255,.6)}
  45%{box-shadow:0 0 20px rgba(255,255,255,.4)}
  60%{box-shadow:0 0 30px rgba(255,255,255,.6)}
  80%{box-shadow:0 0 10px rgba(255,255,255,.2)}
  100%{box-shadow:none;transform:scale(1)}
}
</style>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
<span id="connPill" class="pill conn-warn">Connecting‚Ä¶</span>

<div class="wrap">
  <header>
    <div class="headerLeft">
      <span class="pill settingsBtn" onclick="openSettings()">‚öôÔ∏è Settings</span>
      <span class="pill">BTC/USD</span>
      <span class="pill" style="opacity:.6">v9.9</span>
      <span id="d24Change" class="pill">24h Œî ‚Äî</span>
    </div>
    <div class="headerCenter">
      <div id="livePrice">$‚Äî</div>
    </div>
    <div class="headerRight">
      <span id="ethPrice" class="pill">ETH ‚Äî</span>
      <span id="xrpPrice" class="pill">XRP ‚Äî</span>
      <span id="adaPrice" class="pill">ADA ‚Äî</span>
      <span id="goldPrice" class="pill">Gold ‚Äî</span>
      <span id="liveClock" class="pill">--:--:--</span>
    </div>
  </header>

  <section class="grid" id="dashboard"></section>
</div>

<!-- Settings Modal -->
<div class="settingsModal" id="settingsModal" onclick="if(event.target === this) closeSettings()">
  <div class="settingsContent">
    <div class="settingsHeader">
      <h2>Settings</h2>
      <span class="closeBtn" onclick="closeSettings()">&times;</span>
    </div>

    <div class="settingsSection">
      <h3>Theme</h3>
      <div class="settingOption" style="cursor:pointer" onclick="selectTheme('dark')">
        <span>üåô Dark Mode</span>
        <span id="themeDarkCheck"></span>
      </div>
      <div class="settingOption" style="cursor:pointer" onclick="selectTheme('light')">
        <span>‚òÄÔ∏è Light Mode</span>
        <span id="themeLightCheck"></span>
      </div>
    </div>

    <div class="settingsSection">
      <h3>Visible Charts</h3>
      <div class="settingOption">
        <span>30 Day</span>
        <input type="checkbox" id="chart30d" checked>
      </div>
      <div class="settingOption">
        <span>24 Hour</span>
        <input type="checkbox" id="chart24h" checked>
      </div>
      <div class="settingOption">
        <span>12 Hour</span>
        <input type="checkbox" id="chart12h">
      </div>
      <div class="settingOption">
        <span>8 Hour</span>
        <input type="checkbox" id="chart8h" checked>
      </div>
      <div class="settingOption">
        <span>1 Hour</span>
        <input type="checkbox" id="chart1h" checked>
      </div>
      <div class="settingOption">
        <span>10 Minute</span>
        <input type="checkbox" id="chart10m" checked>
      </div>
      <div class="settingOption">
        <span>5 Minute</span>
        <input type="checkbox" id="chart5m" checked>
      </div>
      <div class="settingOption">
        <span>1 Minute</span>
        <input type="checkbox" id="chart1m">
      </div>
    </div>

    <div class="settingsSection">
      <h3>Alerts</h3>
      <div class="settingOption">
        <span>Volume Spike Alerts</span>
        <input type="checkbox" id="alertVolSpike" checked>
      </div>
      <div class="settingOption">
        <span>Large Trade Blink</span>
        <input type="checkbox" id="alertTradeBlink" checked>
      </div>
    </div>

    <div class="settingsActions">
      <button class="btn btnSecondary" onclick="closeSettings()">Cancel</button>
      <button class="btn btnPrimary" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<script>
/* ===== Firebase Setup ===== */
const firebaseConfig = {
  apiKey: "AIzaSyAy7bMRwm98jdSgg40KUvXPuUONd8o6KLc",
  authDomain: "btc-stalker.firebaseapp.com",
  databaseURL: "https://btc-stalker-default-rtdb.firebaseio.com",
  projectId: "btc-stalker",
  storageBucket: "btc-stalker.firebasestorage.app",
  messagingSenderId: "127552164700",
  appId: "1:127552164700:web:c2e56579b4946b7d44e799"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ===== Config ===== */
const TF = [
  {key:'30d', label:'30 DAYS',  win:2592000000, bins:30, binSize:86400000},  // 30 bars x 1 day each
  {key:'24h', label:'24 HOURS', win:86400000, bins:12, binSize:7200000},  // 12 bars x 2hr each
  {key:'12h', label:'12 HOURS', win:43200000, bins:12, binSize:3600000},  // 12 bars x 1hr each
  {key:'8h',  label:'8 HOURS',  win:28800000, bins:12, binSize:2400000},  // 12 bars x 40min each
  {key:'1h',  label:'1 HOUR',   win:3600000,  bins:12, binSize:300000},
  {key:'10m', label:'10 MIN',   win:600000,   bins:10, binSize:60000},
  {key:'5m',  label:'5 MIN',    win:300000,   bins:10, binSize:30000},    // 10 bars x 30sec each
  {key:'1m',  label:'1 MIN',    win:60000,    bins:12, binSize:5000}      // 12 bars x 5sec each
];

/* ===== Elements ===== */
const priceEl = document.getElementById('livePrice');
const connPill = document.getElementById('connPill');
const d24Change = document.getElementById('d24Change');
const goldPrice = document.getElementById('goldPrice');
const ethPrice = document.getElementById('ethPrice');
const xrpPrice = document.getElementById('xrpPrice');
const adaPrice = document.getElementById('adaPrice');
const liveClock = document.getElementById('liveClock');

/* ===== Formatters ===== */
const fmtUSD = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtUSD0 = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
const fmtUSDChange = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2,signDisplay:'always'});
const fmtBTC = new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
const pct1 = new Intl.NumberFormat(undefined,{maximumFractionDigits:1});

/* ===== State ===== */
let lastPrice = null;
let win30d = [], win24h = [], win12h = [], win8h = [], win1h = [], win10m = [], win5m = [], win1m = [];
let win30dVol = [], win24hVol = [], win12hVol = [], win8hVol = [], win1hVol = [], win10mVol = [], win5mVol = [], win1mVol = [];
let win30dLive = [], win24hLive = [], win12hLive = [], win8hLive = [], win1hLive = [], win10mLive = [], win5mLive = [], win1mLive = [];
let last30dSample = 0, last24hSample = 0, last12hSample = 0, last8hSample = 0, last1hSample = 0, last10mSample = 0, last5mSample = 0, last1mSample = 0;
const SAMPLE_INTERVALS = {
  '30d': 3600000,  // 1 hour
  '24h': 300000,   // 5 minutes
  '12h': 120000,   // 2 minutes
  '8h': 120000,    // 2 minutes
  '1h': 60000,     // 1 minute
  '10m': 500,      // 0.5 seconds
  '5m': 300,       // 0.3 seconds
  '1m': 100        // 0.1 seconds
};

/* ===== Build DOM ===== */
const dash = document.getElementById('dashboard');
dash.innerHTML = TF.map(t => `
<div class="col" id="col-${t.key}">
  <div class="colHeader">
    <div class="tfLabel">${t.label}</div>
    <div class="statPills" id="pills-${t.key}">
      <span class="statPill" id="vol-${t.key}">Vol ‚Äî</span>
      <span class="statPill" id="hl-${t.key}">H/L ‚Äî</span>
    </div>
  </div>
  <div class="chartBox"><canvas id="chart-${t.key}"></canvas></div>
  ${(t.key==='1h' || t.key==='10m' || t.key==='5m' || t.key==='1m') ? `<div class="gaugeRow">
    <span class="gLabel buy">Buys</span>
    <div class="gaugeWrap">
      <canvas id="biasGauge-${t.key}"></canvas>
      <div id="needle-${t.key}" class="needle" style="left:50%"></div>
      <div id="needleValue-${t.key}" class="needleValue" style="left:50%">0%</div>
    </div>
    <span class="gLabel sell">Sells</span>
  </div>
  <div class="metricPills" id="metrics-${t.key}">
    <span class="metricPill" id="tpm-${t.key}">T/m ‚Äî</span>
    <span class="metricPill" id="avg-${t.key}">Avg ‚Äî</span>
    <span class="metricPill" id="med-${t.key}">Med ‚Äî</span>
    <span class="metricPill" id="vwap-${t.key}">VWAP ‚Äî</span>
  </div>` : ''}
  <div class="volBox"><canvas id="volChart-${t.key}"></canvas></div>
  <div class="topTrades">
    <div class="topHeader">Top Trades</div>
    <div class="topGrid">
      <div class="topCol buyCol">
        <h4>Buys</h4>
        <ul class="topList" id="topBuys-${t.key}"></ul>
      </div>
      <div class="topCol sellCol">
        <h4>Sells</h4>
        <ul class="topList" id="topSells-${t.key}"></ul>
      </div>
    </div>
  </div>
</div>
`).join('');

/* ===== Canvas helpers ===== */
function sizeCanvas(c){
  if(!c || !c.getContext) {
    console.warn('sizeCanvas: invalid canvas element', c);
    return null;
  }
  const dpr = Math.max(1, Math.min(devicePixelRatio||1, 3));
  c.width = Math.max(1, c.clientWidth*dpr);
  c.height = Math.max(1, c.clientHeight*dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}

/* ===== Stats calculation ===== */
function median(arr){
  const a=[...arr].sort((x,y)=>x-y);
  const n=a.length;
  return n?(n&1?a[(n-1)/2]:(a[n/2-1]+a[n/2])/2):NaN;
}

function calcStats(arr, windowMs){
  if(arr.length===0) return null;
  const prices = arr.map(t=>t.price);
  const hi = Math.max(...prices);
  const lo = Math.min(...prices);
  let buyVol=0, sellVol=0, buyUsd=0, sellUsd=0, totalVol=0;
  for(const t of arr){
    const usd = t.price * t.size;
    totalVol += t.size;
    if(t.side==='buy'){buyVol+=t.size; buyUsd+=usd}
    else{sellVol+=t.size; sellUsd+=usd}
  }
  const totalUsd = buyUsd + sellUsd;
  const buyRatio = totalUsd ? (buyUsd/totalUsd)*100 : 50;

  // VWAP (Volume Weighted Average Price)
  const vwap = totalVol > 0 ? totalUsd / totalVol : 0;

  // Trades per minute
  const minutes = windowMs / 60000;
  const tradesPerMin = minutes > 0 ? arr.length / minutes : 0;

  return {
    first: prices[0],
    last: prices[prices.length-1],
    hi, lo,
    buyVol, sellVol,
    buyRatio,
    count: arr.length,
    vwap,
    tradesPerMin
  };
}

// Calculate avg/median from LIVE trades only (not historical candles)
function calcLiveTradeStats(liveArr){
  if(liveArr.length === 0) return null;

  const usdTrades = [];
  for(const t of liveArr){
    const usd = t.price * t.size;
    usdTrades.push(usd);
  }

  // Avg trade size (USD)
  const totalUsd = usdTrades.reduce((sum, val) => sum + val, 0);
  const avgTradeUsd = usdTrades.length > 0 ? totalUsd / usdTrades.length : 0;

  // Median trade size (USD)
  usdTrades.sort((a,b)=>a-b);
  const medTradeUsd = usdTrades.length > 0 ? usdTrades[Math.floor(usdTrades.length/2)] : 0;

  return { avgTradeUsd, medTradeUsd };
}

/* ===== Trade ingestion ===== */
function onTrade(t){
  const p = t.price;
  const s = t.size;
  const side = t.side==='sell' ? 'sell' : 'buy';
  const time = t.time.getTime();

  // Update price display (always)
  if(lastPrice !== null){
    priceEl.classList.remove('up','down');
    if(p>lastPrice) priceEl.classList.add('up');
    else if(p<lastPrice) priceEl.classList.add('down');
  }
  lastPrice = p;
  priceEl.textContent = fmtUSD.format(p);

  // Sample at different rates for price charts
  const now = Date.now();
  const trade = {price:p, size:s, side, time};
  const lastSamples = {
    '30d': last30dSample, '24h': last24hSample, '12h': last12hSample, '8h': last8hSample,
    '1h': last1hSample, '10m': last10mSample, '5m': last5mSample, '1m': last1mSample
  };

  if(now - last30dSample >= SAMPLE_INTERVALS['30d']){ win30d.push(trade); last30dSample = now; }
  if(now - last24hSample >= SAMPLE_INTERVALS['24h']){ win24h.push(trade); last24hSample = now; }
  if(now - last12hSample >= SAMPLE_INTERVALS['12h']){ win12h.push(trade); last12hSample = now; }
  if(now - last8hSample >= SAMPLE_INTERVALS['8h']){ win8h.push(trade); last8hSample = now; }
  if(now - last1hSample >= SAMPLE_INTERVALS['1h']){ win1h.push(trade); last1hSample = now; }
  if(now - last10mSample >= SAMPLE_INTERVALS['10m']){ win10m.push(trade); last10mSample = now; }
  if(now - last5mSample >= SAMPLE_INTERVALS['5m']){ win5m.push(trade); last5mSample = now; }
  if(now - last1mSample >= SAMPLE_INTERVALS['1m']){ win1m.push(trade); last1mSample = now; }

  // Add ALL trades to volume windows (no sampling)
  win30dVol.push(trade);
  win24hVol.push(trade);
  win12hVol.push(trade);
  win8hVol.push(trade);
  win1hVol.push(trade);
  win10mVol.push(trade);
  win5mVol.push(trade);
  win1mVol.push(trade);

  // Add to LIVE trade arrays (for avg/median calculation)
  win30dLive.push(trade);
  win24hLive.push(trade);
  win12hLive.push(trade);
  win8hLive.push(trade);
  win1hLive.push(trade);
  win10mLive.push(trade);
  win5mLive.push(trade);
  win1mLive.push(trade);

  prune();
  updateAll();
}

function prune(){
  const now = Date.now();
  win30d = win30d.filter(t => t.time >= now - 2592000000);
  win24h = win24h.filter(t => t.time >= now - 86400000);
  win12h = win12h.filter(t => t.time >= now - 43200000);
  win8h = win8h.filter(t => t.time >= now - 28800000);
  win1h = win1h.filter(t => t.time >= now - 3600000);
  win10m = win10m.filter(t => t.time >= now - 600000);
  win5m = win5m.filter(t => t.time >= now - 300000);
  win1m = win1m.filter(t => t.time >= now - 60000);

  win30dVol = win30dVol.filter(t => t.time >= now - 2592000000);
  win24hVol = win24hVol.filter(t => t.time >= now - 86400000);
  win12hVol = win12hVol.filter(t => t.time >= now - 43200000);
  win8hVol = win8hVol.filter(t => t.time >= now - 28800000);
  win1hVol = win1hVol.filter(t => t.time >= now - 3600000);
  win10mVol = win10mVol.filter(t => t.time >= now - 600000);
  win5mVol = win5mVol.filter(t => t.time >= now - 300000);
  win1mVol = win1mVol.filter(t => t.time >= now - 60000);

  win30dLive = win30dLive.filter(t => t.time >= now - 2592000000);
  win24hLive = win24hLive.filter(t => t.time >= now - 86400000);
  win12hLive = win12hLive.filter(t => t.time >= now - 43200000);
  win8hLive = win8hLive.filter(t => t.time >= now - 28800000);
  win1hLive = win1hLive.filter(t => t.time >= now - 3600000);
  win10mLive = win10mLive.filter(t => t.time >= now - 600000);
  win5mLive = win5mLive.filter(t => t.time >= now - 300000);
  win1mLive = win1mLive.filter(t => t.time >= now - 60000);
}

/* ===== Update stats & charts ===== */
function updateAll(){
  const winMap = { '30d': win30d, '24h': win24h, '12h': win12h, '8h': win8h, '1h': win1h, '10m': win10m, '5m': win5m, '1m': win1m };
  const volMap = { '30d': win30dVol, '24h': win24hVol, '12h': win12hVol, '8h': win8hVol, '1h': win1hVol, '10m': win10mVol, '5m': win5mVol, '1m': win1mVol };
  const liveMap = { '30d': win30dLive, '24h': win24hLive, '12h': win12hLive, '8h': win8hLive, '1h': win1hLive, '10m': win10mLive, '5m': win5mLive, '1m': win1mLive };

  TF.forEach(tf => {
    const arr = winMap[tf.key];
    const volArr = volMap[tf.key];
    const liveArr = liveMap[tf.key];

    const stats = calcStats(volArr, tf.win); // Use volume array for stats, pass window size
    const liveStats = calcLiveTradeStats(liveArr); // Calculate avg/median from live trades only

    if(stats){
      document.getElementById(`vol-${tf.key}`).textContent = `Vol ‚Çø${fmtBTC.format(stats.buyVol + stats.sellVol)}`;
      document.getElementById(`hl-${tf.key}`).textContent = `H/L ${fmtUSD0.format(stats.hi)} / ${fmtUSD0.format(stats.lo)}`;

      // Update metric pills (for 1h, 10m, 5m, 1m)
      if(tf.key === '1h' || tf.key === '10m' || tf.key === '5m' || tf.key === '1m'){
        document.getElementById(`tpm-${tf.key}`).textContent = `Trades/m ${stats.tradesPerMin.toFixed(1)}`;
        document.getElementById(`vwap-${tf.key}`).textContent = `VWAP ${fmtUSD0.format(stats.vwap)}`;

        // Show avg/median from live trades only
        if(liveStats && liveArr.length > 0){
          document.getElementById(`avg-${tf.key}`).textContent = `Avg ${fmtUSD0.format(liveStats.avgTradeUsd)}`;
          document.getElementById(`med-${tf.key}`).textContent = `Med ${fmtUSD0.format(liveStats.medTradeUsd)}`;
        } else {
          document.getElementById(`avg-${tf.key}`).textContent = `Avg ‚Äî`;
          document.getElementById(`med-${tf.key}`).textContent = `Med ‚Äî`;
        }
      }
    }

    drawChart(tf.key, arr); // Use sampled array for price chart
    const spikeDetected = drawVolume(tf.key, volArr, tf); // Use full volume array for volume chart

    // Flash volume box if spike detected (for short timeframes and if alerts enabled)
    if((tf.key === '10m' || tf.key === '5m' || tf.key === '1m') && spikeDetected && settings.alerts.volSpike){
      const volBox = document.querySelector(`#col-${tf.key} .volBox`);
      if(volBox){
        volBox.classList.remove('spikeAlert');
        void volBox.offsetWidth; // Force reflow to restart animation
        volBox.classList.add('spikeAlert');
      }
    }

    // Draw gauge for 1h, 10m, 5m, 1m (where live data is accurate)
    if(stats && (tf.key === '1h' || tf.key === '10m' || tf.key === '5m' || tf.key === '1m')){
      drawGauge(tf.key, stats.buyVol, stats.sellVol);
    }

    // Update top trades list
    updateTopTrades(tf.key, liveArr);
  });
}

/* ===== Track previous top trades to detect new entries ===== */
const prevTopTrades = {
  '30d': {buys: [], sells: []},
  '24h': {buys: [], sells: []},
  '12h': {buys: [], sells: []},
  '8h': {buys: [], sells: []},
  '1h': {buys: [], sells: []},
  '10m': {buys: [], sells: []},
  '5m': {buys: [], sells: []},
  '1m': {buys: [], sells: []}
};

/* ===== Helper: Compare two arrays for equality ===== */
function arraysEqual(a, b){
  if(a.length !== b.length) return false;
  for(let i = 0; i < a.length; i++){
    if(a[i] !== b[i]) return false;
  }
  return true;
}

/* ===== Update top trades ===== */
function updateTopTrades(key, liveArr){
  if(!liveArr || liveArr.length === 0) return;

  // Separate buys and sells, calculate USD value
  const buys = liveArr.filter(t => t.side === 'buy').map(t => ({
    ...t,
    usd: t.price * t.size
  }));
  const sells = liveArr.filter(t => t.side === 'sell').map(t => ({
    ...t,
    usd: t.price * t.size
  }));

  // Sort by USD value, show more for longer timeframes
  buys.sort((a,b) => b.usd - a.usd);
  sells.sort((a,b) => b.usd - a.usd);
  const limit = (key === '30d' || key === '24h' || key === '12h' || key === '8h') ? 13 : 10;
  const top10Buys = buys.slice(0, limit);
  const top10Sells = sells.slice(0, limit);

  // Check for new entries by comparing timestamps
  const prevBuys = prevTopTrades[key].buys;
  const prevSells = prevTopTrades[key].sells;
  const newBuyTimes = new Set(top10Buys.map(t => t.time));
  const newSellTimes = new Set(top10Sells.map(t => t.time));
  const prevBuyTimes = new Set(prevBuys);
  const prevSellTimes = new Set(prevSells);

  // Format time helper - smart format based on timeframe
  const formatTime = (ms) => {
    const d = new Date(ms);
    if(key === '30d'){
      // For 30-day chart, show compact date: "Jan 29"
      return d.toLocaleDateString('en-US', {month:'short', day:'numeric'});
    } else {
      // For shorter timeframes, show time: "2:30pm"
      return d.toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', hour12:true}).toLowerCase();
    }
  };

  // Check if alerts are enabled (no delay needed with Firebase persistence)
  const enableBlink = settings.alerts.tradeBlink;

  // Update buy list
  const buyList = document.getElementById(`topBuys-${key}`);
  if(buyList){
    buyList.innerHTML = top10Buys.length > 0
      ? top10Buys.map(t => {
          const isNew = enableBlink && !prevBuyTimes.has(t.time) && prevBuys.length > 0;
          // Calculate blink duration: 10 seconds per BTC, minimum 5 seconds
          const blinkDuration = Math.max(5, Math.round(t.size * 10));
          const styleAttr = isNew ? ` style="--blink-duration: ${blinkDuration}s"` : '';
          return `
        <li class="topItem buy${isNew ? ' newTrade' : ''}"${styleAttr}>
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`;
        }).join('')
      : '<li class="topItem" style="opacity:.5">No buys yet</li>';
  }

  // Update sell list
  const sellList = document.getElementById(`topSells-${key}`);
  if(sellList){
    sellList.innerHTML = top10Sells.length > 0
      ? top10Sells.map(t => {
          const isNew = enableBlink && !prevSellTimes.has(t.time) && prevSells.length > 0;
          // Calculate blink duration: 10 seconds per BTC, minimum 5 seconds
          const blinkDuration = Math.max(5, Math.round(t.size * 10));
          const styleAttr = isNew ? ` style="--blink-duration: ${blinkDuration}s"` : '';
          return `
        <li class="topItem sell${isNew ? ' newTrade' : ''}"${styleAttr}>
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`;
        }).join('')
      : '<li class="topItem" style="opacity:.5">No sells yet</li>';
  }

  // Check if top trades list has actually changed
  const buysChanged = !arraysEqual(prevTopTrades[key].buys, top10Buys.map(t => t.time));
  const sellsChanged = !arraysEqual(prevTopTrades[key].sells, top10Sells.map(t => t.time));

  // Store current top trade times for next comparison
  prevTopTrades[key].buys = top10Buys.map(t => t.time);
  prevTopTrades[key].sells = top10Sells.map(t => t.time);

  // Save top trades to Firebase ONLY if the list changed (async, non-blocking)
  // Only persist 1h and longer timeframes (skip 10m, 5m, 1m - too volatile/resource intensive)
  // Don't save if we're currently loading from Firebase (prevents infinite loop)
  if((key === '30d' || key === '24h' || key === '12h' || key === '8h' || key === '1h') && !isLoadingFromFirebase && (buysChanged || sellsChanged)){
    console.log(`üíæ Saving ${key}: ${top10Buys.length} buys, ${top10Sells.length} sells to Firebase (list changed)`);
    saveTopTradesToFirebase(key, top10Buys, top10Sells);
  }
}

/* ===== Firebase: Save top trades ===== */
function saveTopTradesToFirebase(key, buys, sells){
  try{
    // Save top buys and sells for longer timeframes only
    const data = {
      buys: buys.map(t => ({
        price: t.price,
        size: t.size,
        usd: t.usd,
        time: t.time
      })),
      sells: sells.map(t => ({
        price: t.price,
        size: t.size,
        usd: t.usd,
        time: t.time
      })),
      lastUpdate: Date.now()
    };
    db.ref(`topTrades/${key}`).set(data);
  }catch(e){
    console.error('Failed to save to Firebase:', e);
  }
}

/* ===== Firebase: Load top trades on startup ===== */
async function loadTopTradesFromFirebase(){
  try{
    const snapshot = await db.ref('topTrades').once('value');
    const data = snapshot.val();
    if(!data) return;

    // Merge Firebase data with live trade windows
    mergeFirebaseTradesWithLive(data);

    console.log('‚úÖ Loaded top trades from Firebase');
    // Don't call updateAll() here - let normal flow handle it after historical data loads
  }catch(e){
    console.error('Failed to load from Firebase:', e);
  }
}

/* ===== Firebase: Setup real-time listeners ===== */
let isLoadingFromFirebase = false; // Prevent infinite update loops

function setupFirebaseListeners(){
  // Listen for changes to top trades in real-time
  db.ref('topTrades').on('value', (snapshot) => {
    const data = snapshot.val();
    if(!data) return;

    // Set flag to prevent save loop
    isLoadingFromFirebase = true;

    // Merge updated trades from Firebase
    mergeFirebaseTradesWithLive(data);

    // Update the display (but don't save back to Firebase)
    updateAll();

    // Clear flag after a short delay
    setTimeout(() => { isLoadingFromFirebase = false; }, 100);
  });

  console.log('‚úÖ Firebase real-time sync enabled');
}

/* ===== Helper: Merge Firebase trades with live data ===== */
function mergeFirebaseTradesWithLive(data){
  const liveMap = {
    '30d': win30dLive, '24h': win24hLive, '12h': win12hLive, '8h': win8hLive,
    '1h': win1hLive, '10m': win10mLive, '5m': win5mLive, '1m': win1mLive
  };

  TF.forEach(tf => {
    const key = tf.key;
    if(data[key]){
      const fbBuys = data[key].buys || [];
      const fbSells = data[key].sells || [];
      const liveArr = liveMap[key];

      console.log(`üì• Loading ${key}: ${fbBuys.length} buys, ${fbSells.length} sells from Firebase`);

      // Add Firebase trades to live window if not already present
      fbBuys.forEach(t => {
        if(!liveArr.find(live => live.time === t.time)){
          liveArr.push({
            price: t.price,
            size: t.size,
            side: 'buy',
            time: t.time
          });
        }
      });

      fbSells.forEach(t => {
        if(!liveArr.find(live => live.time === t.time)){
          liveArr.push({
            price: t.price,
            size: t.size,
            side: 'sell',
            time: t.time,
            usd: t.usd || (t.price * t.size) // Ensure USD is calculated
          });
        }
      });

      // Debug: Show the actual trades being loaded
      if(key === '30d' || key === '24h'){
        console.log(`   Sells loaded:`, fbSells.map(t => `${(t.size || 0).toFixed(2)} BTC`).join(', '));
      }
    }
  });
}

/* ===== Chart drawing (simple line) ===== */
function drawChart(key, arr){
  const canvas = document.getElementById(`chart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length < 2) return;

  const prices = arr.map(t => t.price);
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const range = (max - min) || 1;
  const avg = prices.reduce((a,b)=>a+b,0) / prices.length;

  const padX = 10, padY = 16;

  // Average line
  const yAvg = padY + (h - 2*padY) * (1 - (avg - min)/range);
  ctx.setLineDash([4,4]);
  ctx.strokeStyle = 'rgba(200,214,207,.4)';
  ctx.beginPath();
  ctx.moveTo(padX, yAvg);
  ctx.lineTo(w-padX, yAvg);
  ctx.stroke();
  ctx.setLineDash([]);

  // Line (colored based on price vs average)
  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Draw line segments, changing color based on whether price is above/below average
  for(let i = 1; i < arr.length; i++){
    const t0 = arr[i-1];
    const t1 = arr[i];
    const x0 = padX + ((i-1)/(arr.length-1)) * (w - 2*padX);
    const y0 = padY + (h - 2*padY) * (1 - (t0.price - min)/range);
    const x1 = padX + (i/(arr.length-1)) * (w - 2*padX);
    const y1 = padY + (h - 2*padY) * (1 - (t1.price - min)/range);

    // Color based on current price vs average
    ctx.strokeStyle = t1.price >= avg ? up : dn;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  // Labels
  ctx.fillStyle = 'rgba(255,255,255,.85)';
  ctx.font = '11px system-ui';
  ctx.textBaseline = 'top';
  ctx.fillText(fmtUSD0.format(max), padX, padY);
  ctx.textBaseline = 'bottom';
  ctx.fillText(fmtUSD0.format(min), padX, h-padY);
}

/* ===== Volume bars ===== */
function drawVolume(key, arr, tf){
  const canvas = document.getElementById(`volChart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length === 0) return;

  // Create bins locked to absolute time boundaries
  const now = Date.now();
  let bins, currentBinIdx;

  // For short timeframes (10m, 5m, 1m), lock to their bin boundaries
  if(key === '10m' || key === '5m' || key === '1m'){
    const currentBoundary = Math.floor(now / tf.binSize) * tf.binSize;
    const start = currentBoundary - tf.win + tf.binSize;

    bins = Array.from({length: tf.bins}, (_,i) => ({
      ts: start + i*tf.binSize,
      buy: 0,
      sell: 0
    }));

    arr.forEach(t => {
      const binStart = Math.floor(t.time / tf.binSize) * tf.binSize;
      const idx = Math.floor((binStart - start) / tf.binSize);

      // Only count trades in completed bins (not current bin)
      if(idx >= 0 && idx < tf.bins && binStart < currentBoundary){
        if(t.side==='buy') bins[idx].buy += t.size;
        else bins[idx].sell += t.size;
      }
    });

    currentBinIdx = -1; // Not used for locked timeframes
  } else {
    // Other timeframes use sliding window
    const start = now - tf.win;
    bins = Array.from({length: tf.bins}, (_,i) => ({
      ts: start + i*tf.binSize,
      buy: 0,
      sell: 0
    }));

    currentBinIdx = Math.floor((now - start) / tf.binSize);

    arr.forEach(t => {
      const idx = Math.min(tf.bins-1, Math.max(0, Math.floor((t.time - start) / tf.binSize)));

      // Skip current incomplete bin
      if(idx === currentBinIdx) return;

      if(t.side==='buy') bins[idx].buy += t.size;
      else bins[idx].sell += t.size;
    });
  }

  const sums = bins.map(b => b.buy + b.sell);
  const max = Math.max(1, ...sums);

  // Calculate average volume and check for spikes
  let isSpike = false;
  if(key === '10m' || key === '5m' || key === '1m'){
    // For locked timeframes, check second-to-last bar (most recently completed)
    const completedSums = sums.slice(0, -1).filter(s => s > 0); // Exclude last (current) bar
    if(completedSums.length > 1){
      const avgVol = completedSums.reduce((a,b) => a+b, 0) / completedSums.length;
      const mostRecentVol = sums[sums.length - 2]; // Second-to-last bar is most recently completed
      isSpike = mostRecentVol > 0 && mostRecentVol >= (avgVol * 1.5);
    }
  } else {
    // For sliding windows, exclude current incomplete bin
    const completedSums = sums.slice(0, currentBinIdx).filter(s => s > 0);
    const avgVol = completedSums.length > 0 ? completedSums.reduce((a,b) => a+b, 0) / completedSums.length : 0;
    const mostRecentIdx = currentBinIdx > 0 ? currentBinIdx - 1 : -1;
    const mostRecentVol = mostRecentIdx >= 0 ? sums[mostRecentIdx] : 0;
    isSpike = avgVol > 0 && mostRecentVol >= (avgVol * 1.5);
  }

  const padX = 8, padY = 8;
  const chartH = h - 2*padY;
  const barW = (w - 2*padX) / bins.length * 0.7;
  const step = (w - 2*padX) / bins.length;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  bins.forEach((b, i) => {
    const x = padX + i*step + step/2;
    const tot = b.buy + b.sell;
    const hT = Math.max(4, (tot/max) * chartH);
    const hBuy = tot ? (b.buy/tot) * hT : 0;
    const hSell = hT - hBuy;
    const yB = h - padY;

    ctx.fillStyle = dn;
    ctx.fillRect(x - barW/2, yB - hSell, barW, hSell);
    ctx.fillStyle = up;
    ctx.fillRect(x - barW/2, yB - hSell - hBuy, barW, hBuy);

    // Add volume label pills on top of bars (with max height cap)
    if(tot > 0.01){
      const label = tot >= 1 ? `‚Çø${tot.toFixed(1)}` : `‚Çø${tot.toFixed(2)}`;

      // Draw pill background on top of bar (capped at 80% of chart height)
      ctx.font = '9px system-ui';
      const metrics = ctx.measureText(label);
      const pillW = metrics.width + 8;
      const pillH = 14;
      const pillX = x - pillW/2;
      const maxY = padY + chartH * 0.15; // Don't go higher than 15% from top
      const pillY = Math.max(maxY, yB - hT - pillH - 2);

      ctx.fillStyle = 'rgba(0,0,0,.85)';
      ctx.beginPath();
      ctx.moveTo(pillX + 7, pillY);
      ctx.arcTo(pillX + pillW, pillY, pillX + pillW, pillY + pillH, 7);
      ctx.arcTo(pillX + pillW, pillY + pillH, pillX, pillY + pillH, 7);
      ctx.arcTo(pillX, pillY + pillH, pillX, pillY, 7);
      ctx.arcTo(pillX, pillY, pillX + pillW, pillY, 7);
      ctx.fill();

      // Draw label text
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, pillY + pillH/2);
    }

    // Add +/- DIFF pill inside bar (actual BTC difference, like mobile.html)
    if(hT > 26 && tot > 0.0001){
      const diff = b.buy - b.sell; // Actual BTC difference
      if(Math.abs(diff) > 0.0001){
        const diffLabel = `${diff>=0?'+':''}${diff.toFixed(2)}`;

        ctx.font = '10px system-ui';
        const diffMetrics = ctx.measureText(diffLabel);
        const diffPillW = diffMetrics.width + 10;
        const diffPillH = 16;
        const diffPillX = x - diffPillW/2;
        const diffPillY = yB - hT/2 - diffPillH/2; // Center of bar

        // Draw pill background (dark with border)
        ctx.fillStyle = 'rgba(0,0,0,.85)';
        ctx.strokeStyle = 'rgba(255,255,255,.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(diffPillX + 7, diffPillY);
        ctx.arcTo(diffPillX + diffPillW, diffPillY, diffPillX + diffPillW, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX + diffPillW, diffPillY + diffPillH, diffPillX, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX, diffPillY + diffPillH, diffPillX, diffPillY, 7);
        ctx.arcTo(diffPillX, diffPillY, diffPillX + diffPillW, diffPillY, 7);
        ctx.fill();
        ctx.stroke();

        // Draw diff text (colored: teal for +, orange for -)
        ctx.fillStyle = diff >= 0 ? up : dn;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(diffLabel, x, diffPillY + diffPillH/2);
      }
    }
  });

  // Return spike detection result
  return isSpike;
}

/* ===== Gauge ===== */
const needlePos = {};
function drawGauge(key, buyVol, sellVol){
  const canvas = document.getElementById(`biasGauge-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);

  const tot = buyVol + sellVol;
  const target = tot ? (buyVol/tot) : 0.5;

  if(!needlePos[key]) needlePos[key] = 0.5;
  needlePos[key] += (target - needlePos[key]) * 0.25;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  const g = ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0, up);
  g.addColorStop(Math.max(0, needlePos[key]-0.001), up);
  g.addColorStop(Math.min(1, needlePos[key]+0.001), dn);
  g.addColorStop(1, dn);

  const r = h/2;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(r,1);
  ctx.arcTo(w-1,1,w-1,h-1,r);
  ctx.arcTo(w-1,h-1,0,h-1,r);
  ctx.arcTo(0,h-1,0,1,r);
  ctx.arcTo(0,1,w-1,1,r);
  ctx.fill();

  const needle = document.getElementById(`needle-${key}`);
  const needleValue = document.getElementById(`needleValue-${key}`);
  if(!needle || !needleValue) return;

  const leftPx = Math.round(canvas.getBoundingClientRect().width * needlePos[key]);
  needle.style.left = leftPx + 'px';
  const biasPct = tot ? ((buyVol - sellVol)/tot)*100 : 0;
  needleValue.textContent = (biasPct>=0?'+':'') + biasPct.toFixed(0) + '%';
  needleValue.style.left = leftPx + 'px';
}

/* ===== WebSocket + fallback ===== */
let ws, recon, lastWs=0, lastRest=0;
function setConn(state, msg){
  connPill.classList.remove('conn-ok','conn-warn','conn-err');
  connPill.classList.add(state==='ok'?'conn-ok':state==='warn'?'conn-warn':'conn-err');
  connPill.textContent = msg;
}

function startWS(){
  clearTimeout(recon);
  try{ws && ws.close()}catch{}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('warn','Connecting‚Ä¶');

  ws.onopen = () => {
    ws.send(JSON.stringify({
      type:'subscribe',
      product_ids:['BTC-USD'],
      channels:['matches']
    }));
  };

  ws.onmessage = e => {
    lastWs = Date.now();
    setConn('ok','Live');
    try{
      const m = JSON.parse(e.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        onTrade({
          price: +m.price,
          size: +m.size,
          side: String(m.side||'').toLowerCase(),
          time: new Date(m.time)
        });
      }
    }catch{}
  };

  ws.onclose = () => {
    setConn('warn','Reconnecting‚Ä¶');
    recon = setTimeout(startWS, 1000);
  };

  ws.onerror = () => {
    setConn('err','Fallback');
    try{ws.close()}catch{}
  };
}

async function restFallback(){
  const QUIET = 3500;
  const now = Date.now();

  try{
    if(now - lastWs >= QUIET){
      const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/trades?limit=20', {
        headers: {Accept:'application/json'}
      });
      if(r.ok){
        const arr = await r.json();
        for(let i=arr.length-1; i>=0; i--){
          const t = arr[i];
          onTrade({
            price: +t.price,
            size: +t.size,
            side: String(t.side||'').toLowerCase(),
            time: new Date(t.time||now)
          });
        }
        lastRest = now;
        setConn('err','Fallback');
        return;
      }
    }

    if(now - Math.max(lastWs, lastRest) >= QUIET){
      const r2 = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/ticker', {
        headers: {Accept:'application/json'}
      });
      if(r2.ok){
        const t = await r2.json();
        onTrade({
          price: +t.price,
          size: +(t.size||0.001),
          side: 'buy',
          time: new Date(t.time||now)
        });
        lastRest = now;
        setConn('err','Fallback');
      }
    }
  }catch{
    setConn('err','Fallback');
  }
}

/* ===== 24h stats from API ===== */
async function fetch24h(){
  try{
    const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/stats', {
      headers: {Accept:'application/json'}
    });
    if(!r.ok) throw 0;
    const j = await r.json();

    const open = +j.open;
    const last = +j.last;

    if(Number.isFinite(open) && Number.isFinite(last)){
      const diff = last - open;
      const pct = open ? (diff/open*100) : 0;
      d24Change.textContent = `24h Œî ${fmtUSDChange.format(diff)} (${pct1.format(pct)}%)`;

      // Color coding
      if(diff > 0){
        d24Change.style.color = 'var(--up)';
        d24Change.style.borderColor = 'var(--up)';
      } else if(diff < 0){
        d24Change.style.color = 'var(--down)';
        d24Change.style.borderColor = 'var(--down)';
      } else {
        d24Change.style.color = '';
        d24Change.style.borderColor = '';
      }
    }
  }catch(e){
    console.log('24h stats error:', e);
    d24Change.textContent = '24h Œî ‚Äî';
  }
}

/* ===== Resize ===== */
let resizePending = false;
function throttledResize(){
  if(resizePending) return;
  resizePending = true;
  requestAnimationFrame(() => {
    resizePending = false;
    updateAll();
  });
}
new ResizeObserver(throttledResize).observe(document.body);
window.addEventListener('resize', throttledResize);

/* ===== Historical data from API ===== */
const iso = ms => new Date(ms).toISOString();

async function fetchHistoricalCandles(){
  try{
    const end = Date.now();

    // Fetch 30d of 6-hour candles for 30d window
    const start30d = end - 2592000000;
    const url30d = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=21600&start=${encodeURIComponent(iso(start30d))}&end=${encodeURIComponent(iso(end))}`;
    const r30d = await fetch(url30d, {headers: {Accept:'application/json'}});
    if(r30d.ok){
      const candles = await r30d.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win30d.push(buyTrade); win30d.push(sellTrade);
        win30dVol.push(buyTrade); win30dVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '30d candles');
    }

    // Fetch 24h of 5-min candles for 24h, 12h, and 8h windows
    const start24h = end - 86400000;
    const url24h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=300&start=${encodeURIComponent(iso(start24h))}&end=${encodeURIComponent(iso(end))}`;
    const r24h = await fetch(url24h, {headers: {Accept:'application/json'}});
    if(r24h.ok){
      const candles = await r24h.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win24h.push(buyTrade); win24h.push(sellTrade);
        win12h.push(buyTrade); win12h.push(sellTrade);
        win8h.push(buyTrade); win8h.push(sellTrade);
        win24hVol.push(buyTrade); win24hVol.push(sellTrade);
        win12hVol.push(buyTrade); win12hVol.push(sellTrade);
        win8hVol.push(buyTrade); win8hVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '24h candles');
    }

    // Fetch 1h of 1-min candles for 1h, 10m, 5m, and 1m windows
    const start1h = end - 3600000;
    const url1h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=60&start=${encodeURIComponent(iso(start1h))}&end=${encodeURIComponent(iso(end))}`;
    const r1h = await fetch(url1h, {headers: {Accept:'application/json'}});
    if(r1h.ok){
      const candles = await r1h.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win1h.push(buyTrade); win1h.push(sellTrade);
        win10m.push(buyTrade); win10m.push(sellTrade);
        win5m.push(buyTrade); win5m.push(sellTrade);
        win1m.push(buyTrade); win1m.push(sellTrade);
        win1hVol.push(buyTrade); win1hVol.push(sellTrade);
        win10mVol.push(buyTrade); win10mVol.push(sellTrade);
        win5mVol.push(buyTrade); win5mVol.push(sellTrade);
        win1mVol.push(buyTrade); win1mVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '1h candles');
    }

    // Prune and update all charts
    prune();
    updateAll();

  }catch(e){
    console.error('Failed to load historical data:', e);
  }
}

/* ===== Clock ===== */
function updateClock(){
  const now = new Date();
  liveClock.textContent = now.toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:true});
}

/* ===== Fetch Gold and crypto prices ===== */
async function fetchMetalPrices(){
  const API_KEY = '830bdfca25d44bfe9992c9872d0693f5';

  try{
    // Fetch Gold spot price (XAU/USD)
    const rGold = await fetch(`https://api.twelvedata.com/price?symbol=XAU/USD&apikey=${API_KEY}`);
    if(rGold.ok){
      const dataGold = await rGold.json();
      if(dataGold && dataGold.price){
        const price = parseFloat(dataGold.price);
        if(price > 0){
          goldPrice.textContent = `Gold $${Math.round(price)}`;
        }
      }
    }

    // Use Coinbase API for crypto prices with 24h stats
    const cryptos = [
      {id: 'ETH-USD', el: ethPrice, label: 'ETH', decimals: 0},
      {id: 'XRP-USD', el: xrpPrice, label: 'XRP', decimals: 3},
      {id: 'ADA-USD', el: adaPrice, label: 'ADA', decimals: 3}
    ];

    for(const crypto of cryptos){
      try{
        const r = await fetch(`https://api.exchange.coinbase.com/products/${crypto.id}/stats`, {
          headers: {Accept: 'application/json'}
        });
        if(r.ok){
          const data = await r.json();
          if(data && data.last && data.open){
            const price = parseFloat(data.last);
            const open = parseFloat(data.open);
            const change = ((price - open) / open) * 100;

            if(price > 0){
              const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
              crypto.el.textContent = `${crypto.label} $${price.toFixed(crypto.decimals)} (${changeText})`;

              // Color coding
              if(change > 0){
                crypto.el.style.color = 'var(--up)';
                crypto.el.style.borderColor = 'var(--up)';
              } else if(change < 0){
                crypto.el.style.color = 'var(--down)';
                crypto.el.style.borderColor = 'var(--down)';
              } else {
                crypto.el.style.color = '';
                crypto.el.style.borderColor = '';
              }
            }
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }catch(e){
        console.log(`${crypto.label} fetch error:`, e);
      }
    }
  }catch(e){
    console.log('Price fetch error:', e);
  }
}

/* ===== Settings Modal ===== */
const settings = {
  theme: 'dark',
  charts: { '30d': true, '24h': true, '12h': false, '8h': true, '1h': true, '10m': true, '5m': true, '1m': false },
  alerts: { volSpike: true, tradeBlink: true }
};

function loadSettings(){
  const saved = localStorage.getItem('btcStalkerSettings');
  if(saved){
    try{
      Object.assign(settings, JSON.parse(saved));
    }catch(e){}
  }
  applySettings();
}

function applySettings(){
  // Apply theme
  document.documentElement.setAttribute('data-theme', settings.theme);
  document.getElementById('themeDarkCheck').textContent = settings.theme === 'dark' ? '‚úì Active' : '';
  document.getElementById('themeLightCheck').textContent = settings.theme === 'light' ? '‚úì Active' : '';

  // Apply chart visibility
  TF.forEach(tf => {
    const col = document.getElementById(`col-${tf.key}`);
    if(col) col.style.display = settings.charts[tf.key] ? '' : 'none';
  });

  // Update checkboxes
  TF.forEach(tf => {
    const checkbox = document.getElementById(`chart${tf.key}`);
    if(checkbox) checkbox.checked = settings.charts[tf.key];
  });
  document.getElementById('alertVolSpike').checked = settings.alerts.volSpike;
  document.getElementById('alertTradeBlink').checked = settings.alerts.tradeBlink;
}

function selectTheme(theme){
  settings.theme = theme;
  applySettings();
}

function openSettings(){
  applySettings(); // Sync checkboxes with current settings
  document.getElementById('settingsModal').classList.add('open');
}

function closeSettings(){
  document.getElementById('settingsModal').classList.remove('open');
}

function saveSettings(){
  // Read checkbox values
  TF.forEach(tf => {
    const checkbox = document.getElementById(`chart${tf.key}`);
    if(checkbox) settings.charts[tf.key] = checkbox.checked;
  });
  settings.alerts.volSpike = document.getElementById('alertVolSpike').checked;
  settings.alerts.tradeBlink = document.getElementById('alertTradeBlink').checked;

  // Save to localStorage
  localStorage.setItem('btcStalkerSettings', JSON.stringify(settings));

  // Apply the settings
  applySettings();

  // Close modal
  closeSettings();
}

/* ===== Start ===== */
// Wait for DOM to be fully ready before drawing
setTimeout(async () => {
  loadSettings(); // Load saved settings
  await loadTopTradesFromFirebase(); // Load persisted top trades FIRST
  // setupFirebaseListeners(); // DISABLED - causing infinite loop, need better approach
  fetchHistoricalCandles(); // Then fetch historical data (which will merge with Firebase data)
  startWS();
  fetch24h();
  fetchMetalPrices();
  updateClock();
  setInterval(restFallback, 1200);
  setInterval(fetch24h, 60000);
  setInterval(fetchMetalPrices, 300000); // Update every 5 minutes
  setInterval(updateClock, 1000); // Update every second
}, 100);
</script>
</body>
</html>
