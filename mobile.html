<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>h8s.us — Mobile</title>
<style>
  :root{
    --bg:#0a0a0a; --panel:#101010; --ink:#eafaf3; --muted:#aeb9b4;
    --up:#2dd4bf; --down:#f59e0b; --glass:rgba(255,255,255,.06);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
  .wrap{max-width:820px;margin:0 auto;padding:10px}
  .card{background:var(--panel);border-radius:16px;box-shadow:0 0 0 1px var(--glass);padding:10px;margin:8px 0}

  /* Price header */
  .livePrice{font-size:clamp(28px,9vw,48px);font-weight:900;text-align:center;line-height:1.05}
  .livePrice.up{color:var(--up)} .livePrice.down{color:var(--down)}

  /* Segmented buttons */
  .seg{display:flex;gap:6px;background:#0e0e0e;border-radius:12px;padding:6px;box-shadow:0 0 0 1px var(--glass) inset}
  .seg button{
    flex:1; padding:10px 0; border:0; border-radius:10px; background:transparent; color:var(--ink);
    font-weight:800; letter-spacing:.2px; font-size:14px; cursor:pointer;
  }
  .seg button.active{background:#14201d;color:var(--up); box-shadow:0 0 0 1px rgba(45,212,191,.25) inset}
  .seg button:not(.active){color:var(--muted)}

  /* Charts */
  .chartBox{padding:6px;border-radius:12px;background:#0f0f0f}
  #priceChart{width:100%;height:320px;display:block}
  #volChart{width:100%;height:240px;display:block}
  .legend{display:flex;gap:10px;align-items:center;margin:2px 6px 6px}
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .dot.up{background:var(--up)} .dot.down{background:var(--down)}
  .maxLbl{margin-left:auto;opacity:.85;font-weight:700;font-size:11px}

  /* connection pill */
  .pill{position:fixed;left:10px;bottom:10px;padding:5px 9px;border-radius:10px;
        background:#15201c;color:var(--up);border:1px solid rgba(45,212,191,.25);font-weight:700;font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card"><div id="price" class="livePrice">$—</div></div>

    <div class="card seg">
      <button data-k="10m" class="active">10min</button>
      <button data-k="1h">1hr</button>
      <button data-k="1d">1day</button>
    </div>

    <div class="card">
      <div class="chartBox"><canvas id="priceChart"></canvas></div>
    </div>

    <div class="card">
      <div class="legend">
        <span class="dot up"></span><small>Buys</small>
        <span class="dot down"></span><small>Sells</small>
        <span id="volMax" class="maxLbl">max —</span>
      </div>
      <div class="chartBox"><canvas id="volChart"></canvas></div>
    </div>
  </div>

  <span id="conn" class="pill">Connecting…</span>

<script>
/* =============== Basics =============== */
const $=s=>document.querySelector(s);
const priceEl=$('#price'), connEl=$('#conn');
const pCan=$('#priceChart'), pctx=pCan.getContext('2d',{desynchronized:true});
const vCan=$('#volChart'), vctx=vCan.getContext('2d',{desynchronized:true});
const volMaxEl=$('#volMax');
const segBtns=[...document.querySelectorAll('.seg button')];

const fmtUSD = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtBTC2= new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
const UP=getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
const DN=getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

function fit(c,ctx){const dpr=Math.max(1,Math.min(devicePixelRatio||1,2.5)); c.width=c.clientWidth*dpr; c.height=c.clientHeight*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);}
new ResizeObserver(()=>{fit(pCan,pctx);fit(vCan,vctx);drawPrice();drawVol();}).observe(document.body);

/* =============== State =============== */
const FRAMES={
  '10m': { span: 10*60*1000, bins:10, binMs:60*1000,  prefer:[60,30] },   // try 1m then 30s
  '1h' : { span: 60*60*1000, bins:12, binMs:5*60*1000, prefer:[300,60] },  // try 5m then 1m
  '1d' : { span: 24*60*60*1000,bins:24, binMs:60*60*1000, prefer:[3600,900,300] } // 1h then 15m then 5m
};
let FRAME_KEY='10m';
let frame=FRAMES[FRAME_KEY];

let lastPrice=null;
let linePts=[];        // {t,p} within span
let bins=[];           // [{ts,buy,sell}]
let ws;

/* =============== Frame switch =============== */
segBtns.forEach(b=>b.addEventListener('click',async e=>{
  segBtns.forEach(x=>x.classList.remove('active'));
  e.currentTarget.classList.add('active');
  FRAME_KEY=e.currentTarget.dataset.k;
  frame=FRAMES[FRAME_KEY];
  await bootstrapFrame();   // pull candles + seed bins
}));

/* =============== Candle fetching with fallbacks =============== */
const iso=ms=>new Date(ms).toISOString();

async function fetchCandlesTry(spanMs, gran){
  const end=Date.now(), start=end-spanMs;
  const u=`https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=${gran}&start=${encodeURIComponent(iso(start))}&end=${encodeURIComponent(iso(end))}`;
  const r=await fetch(u,{headers:{Accept:'application/json'}});
  if(!r.ok) throw new Error('HTTP '+r.status);
  const raw=await r.json(); // [time, low, high, open, close, volume]
  const arr=raw.sort((a,b)=>a[0]-b[0]).map(c=>({t:c[0]*1000, p:+c[4], v:+c[5]}));
  return arr;
}

async function fetchCandlesRobust(spanMs, preferGrans){
  // Try preferred granularities in order; if an attempt returns <2 points, try next
  for(const g of preferGrans){
    try{
      const arr=await fetchCandlesTry(spanMs,g);
      if(arr && arr.length>=2) return arr;
    }catch(_){}
  }
  // Last-ditch: try 60s
  try{
    const arr=await fetchCandlesTry(spanMs,60);
    if(arr && arr.length>=2) return arr;
  }catch(_){}
  return []; // give up; UI will still run on live stream
}

/* Resample (downsample) to max N points to ensure smooth rendering on 1d */
function resampleMax(points, maxN){
  if(points.length<=maxN) return points;
  const step=points.length/maxN;
  const out=[];
  for(let i=0;i<maxN;i++){
    const idx=Math.floor(i*step);
    out.push(points[idx]);
  }
  return out;
}

function seedFromCandles(candles){
  // price line from candles (cap points for 1d)
  const cap = FRAME_KEY==='1d' ? 400 : (FRAME_KEY==='1h' ? 300 : 200);
  linePts = resampleMax(candles, cap);

  // show header price
  if(linePts.length) {
    lastPrice=linePts.at(-1).p;
    priceEl.textContent=fmtUSD.format(lastPrice);
  }

  // seed volume bins: split candle volume 70/30 into buys/sells as a placeholder
  const start=Date.now()-frame.span;
  bins = Array.from({length:frame.bins},(_,i)=>({ts:start+i*frame.binMs, buy:0, sell:0}));
  for(const c of candles){
    const i=Math.min(frame.bins-1, Math.max(0, Math.floor((c.t-start)/frame.binMs)));
    const buy=c.v*0.7, sell=c.v*0.3;
    bins[i].buy += buy; bins[i].sell += sell;
  }
}

async function bootstrapFrame(){
  // empty first to force redraws
  linePts=[]; bins=[];
  drawPrice(); drawVol();

  try{
    const candles=await fetchCandlesRobust(frame.span, frame.prefer);
    if(candles.length>=2){
      seedFromCandles(candles);
    }
  }catch(_){}
  drawPrice(); drawVol();
}

/* =============== Live ingestion =============== */
function setConn(txt,color){connEl.textContent=txt; if(color) connEl.style.color=color;}

function startWS(){
  try{ws && ws.close()}catch{}
  ws=new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('Connecting…','#fbbf24');
  ws.onopen=()=>ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
  ws.onmessage=e=>{
    try{
      const m=JSON.parse(e.data);
      if(m.type==='match'&&m.product_id==='BTC-USD'){
        const t=+new Date(m.time), p=+m.price, s=+m.size, side=(m.side==='sell'?'sell':'buy');
        liveIngest(t,p,s,side);
      }
    }catch(_){}
  };
  ws.onerror=()=>setConn('Fallback','#fb7185');
  ws.onclose =()=>{setConn('Reconnecting…','#fbbf24'); setTimeout(startWS,1000);}
}

function liveIngest(t,p,sz,side){
  // header price
  if(lastPrice!==null){priceEl.classList.remove('up','down'); if(p>lastPrice)priceEl.classList.add('up'); else if(p<lastPrice)priceEl.classList.add('down');}
  lastPrice=p; priceEl.textContent=fmtUSD.format(p); setConn('Live',UP);

  // price points (trim to current frame span)
  linePts.push({t,p});
  const cut=Date.now()-frame.span;
  while(linePts.length && linePts[0].t<cut) linePts.shift();

  // volume bins; shift forward as time moves
  if(!bins.length){
    const start=Date.now()-frame.span;
    bins = Array.from({length:frame.bins},(_,i)=>({ts:start+i*frame.binMs, buy:0, sell:0}));
  }
  const start=Date.now()-frame.span;
  // ensure newest bin timestamp alignment
  while(bins.at(-1).ts + frame.binMs < start + frame.span){
    const lastTS=bins.at(-1).ts;
    bins.shift();
    bins.push({ts:lastTS+frame.binMs, buy:0, sell:0});
  }
  const idx=Math.min(bins.length-1, Math.max(0, Math.floor((t-start)/frame.binMs)));
  if(side==='sell') bins[idx].sell += sz; else bins[idx].buy += sz;

  drawPrice(); drawVol();
}

/* =============== Price chart draw (R→L, fading trail, minimal grid) =============== */
function drawPrice(){
  fit(pCan,pctx);
  const w=pCan.clientWidth, h=pCan.clientHeight;
  const padL=10, padR=10, padT=10, padB=18;
  const x0=padL, x1=w-padR, y0=padT, y1=h-padB;

  pctx.clearRect(0,0,w,h); pctx.fillStyle='#0f0f0f'; pctx.fillRect(0,0,w,h);
  const now=Date.now(), start=now-frame.span;
  const pts=linePts.filter(s=>s.t>=start);
  if(pts.length<2) return;

  let lo=Infinity, hi=-Infinity, sum=0;
  for(const s of pts){ if(s.p<lo)lo=s.p; if(s.p>hi)hi=s.p; sum+=s.p; }
  const avg=sum/pts.length, rng=(hi-lo)||1;

  // faint grid lines + avg
  pctx.strokeStyle='rgba(255,255,255,.06)'; pctx.lineWidth=1;
  for(let i=1;i<=2;i++){const y=y0+(y1-y0)*i/3; pctx.beginPath(); pctx.moveTo(x0,y); pctx.lineTo(x1,y); pctx.stroke();}
  pctx.save(); pctx.setLineDash([6,6]); pctx.strokeStyle='rgba(200,214,207,.45)';
  const yAvg=y0+(y1-y0)*(1-(avg-lo)/rng);
  pctx.beginPath(); pctx.moveTo(x0,yAvg); pctx.lineTo(x1,yAvg); pctx.stroke(); pctx.restore();

  // sparse time ticks
  const steps = (FRAME_KEY==='10m') ? 240000 : (FRAME_KEY==='1h'? 15*60000 : 2*60*60*1000);
  pctx.fillStyle='rgba(255,255,255,.55)'; pctx.textAlign='center'; pctx.textBaseline='top'; pctx.font='10px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  const first=start + (steps - (start%steps));
  for(let t=first; t<=now; t+=steps){
    const rel=(t-start)/frame.span, x=x1 - rel*(x1-x0);
    pctx.fillText(new Date(t).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}).replace(/^0/,'').replace(' ',''),
                  x, y1+4);
  }

  // fading tail line (new→old alpha)
  const yMap=v=> y0+(y1-y0)*(1-(v-lo)/rng);
  pctx.lineWidth=2;
  for(let i=1;i<pts.length;i++){
    const a=pts[i-1], b=pts[i];
    const relB=(b.t-start)/frame.span; const xB=x1 - relB*(x1-x0);
    const relA=(a.t-start)/frame.span; const xA=x1 - relA*(x1-x0);
    const yA=yMap(a.p), yB=yMap(b.p);
    const age=(now-b.t)/frame.span;              // 0..1
    const alpha=Math.max(0, 1 - age*1.6);
    pctx.strokeStyle=`rgba(45,212,191,${alpha.toFixed(3)})`;
    pctx.beginPath(); pctx.moveTo(xA,yA); pctx.lineTo(xB,yB); pctx.stroke();
  }
}

/* =============== Volume chart draw (R→L, stacked) =============== */
function drawVol(){
  fit(vCan,vctx);
  const w=vCan.clientWidth, h=vCan.clientHeight;
  const padL=16, padR=10, padT=6, padB=20;
  const chartH=h-padT-padB, step=(w-padL-padR)/frame.bins, barW=Math.max(2,step*0.7);

  vctx.clearRect(0,0,w,h); vctx.fillStyle='#0f0f0f'; vctx.fillRect(0,0,w,h);
  if(!bins.length) { volMaxEl.textContent='max —'; return; }

  const totals=bins.map(b=>b.buy+b.sell);
  const maxRaw=Math.max(0.01,...totals), max=maxRaw*1.25;
  volMaxEl.textContent='max ₿'+fmtBTC2.format(maxRaw);

  // faint horizontals
  vctx.strokeStyle='rgba(255,255,255,.05)'; vctx.lineWidth=1;
  for(let i=1;i<=2;i++){const y=padT+chartH*i/3; vctx.beginPath(); vctx.moveTo(padL,y); vctx.lineTo(w-padR,y); vctx.stroke();}

  const now=Date.now(), start=now-frame.span, x0=padL, x1=w-padR;

  for(let i=0;i<bins.length;i++){
    const b=bins[i], total=b.buy+b.sell;
    const rel=(b.ts-start)/frame.span, x=x1 - rel*(x1-x0) - step/2;
    const yBase=padT+chartH, hT=Math.max(1,(total/max)*chartH), hBuy=total?(b.buy/total)*hT:0;

    vctx.fillStyle=DN; vctx.fillRect(x-barW/2, yBase-(hT-hBuy), barW, hT-hBuy);
    vctx.fillStyle=UP; vctx.fillRect(x-barW/2, yBase-hT,       barW, hBuy);
  }
}

/* =============== Kickoff =============== */
(async ()=>{
  fit(pCan,pctx); fit(vCan,vctx);
  await bootstrapFrame();   // ensures 1h / 1d show from candles even before live
  startWS();
})();
</script>
</body>
</html>