<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>h8s — 10m</title>
<style>
  :root{
    --bg:#0a0a0a; --panel:#101010; --ink:#e9fef7; --muted:#c8d6cf;
    --up:#2dd4bf; --down:#f59e0b; --grid:rgba(255,255,255,.06);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
  .wrap{padding:12px;max-width:760px;margin:0 auto}
  .card{background:var(--panel);border-radius:16px;padding:10px 10px 12px;
        box-shadow:0 0 0 1px rgba(255,255,255,.06), 0 10px 26px rgba(0,0,0,.35)}
  /* price text (top center) — only the number changes color */
  #price{font-size:clamp(28px,8vw,44px);font-weight:900;text-align:center;margin:0 0 8px}
  #price.price-up{color:var(--up)} #price.price-down{color:var(--down)}
  /* canvases */
  .can{display:block;width:100%;height:240px;border-radius:12px}
  #vol{height:170px;margin-top:12px}
  .row{display:flex;justify-content:space-between;align-items:center;margin:6px 2px 4px}
  .pill{font-size:11px;border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:3px 8px;opacity:.9;white-space:nowrap}
  .lgd{display:flex;gap:10px;align-items:center}
  .dot{width:10px;height:10px;border-radius:2px;display:inline-block;margin-right:6px}
  .dot.up{background:var(--up)} .dot.down{background:var(--down)}
  #conn{position:fixed;left:12px;bottom:12px;z-index:10}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div id="price">$—</div>

    <canvas id="chart" class="can"></canvas>

    <div class="row">
      <div class="lgd">
        <span class="dot up"></span><small>Buys</small>
        <span class="dot down"></span><small>Sells</small>
      </div>
      <span id="maxVol" class="pill">max —</span>
    </div>

    <canvas id="vol" class="can"></canvas>
  </div>
</div>

<span id="conn" class="pill">Connecting…</span>

<script>
/* ---------- helpers ---------- */
const $=s=>document.querySelector(s);
const fmtUSD=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtUSD0=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
const fmtBTC=new Intl.NumberFormat(undefined,{maximumFractionDigits:2});

const priceEl=$('#price'), connEl=$('#conn'), maxVolEl=$('#maxVol');
const chart=$('#chart'), ctx=chart.getContext('2d',{desynchronized:true});
const vol=$('#vol'), vctx=vol.getContext('2d',{desynchronized:true});

function sizeCanvas(c, ctx){
  const dpr=Math.max(1,Math.min(devicePixelRatio||1,3));
  const {clientWidth:w, clientHeight:h}=c;
  c.width=Math.max(1,w*dpr); c.height=Math.max(1,h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function resizeAll(){ sizeCanvas(chart,ctx); sizeCanvas(vol,vctx); draw(); }
new ResizeObserver(resizeAll).observe(document.body);

/* ---------- state ---------- */
let trades=[], series=[];
let lastPrice=null, startTime=null;
const MS1M = 60000, MS10 = 600000;

/* ---------- WS ---------- */
let ws, recon;
function setConn(txt){connEl.textContent=txt;}

function startWS(){
  try{ ws && ws.close(); }catch(e){}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('Connecting…');
  ws.onopen=()=> {
    setConn('Live');
    ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
  };
  ws.onmessage = e=>{
    try{
      const m=JSON.parse(e.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        const t={ t: new Date(m.time).getTime(), p:+m.price, s:+m.size,
                  side:(m.side||'buy').toLowerCase() };
        ingest(t);
      }
    }catch{}
  };
  ws.onclose = () => { setConn('Reconnecting…'); clearTimeout(recon); recon=setTimeout(startWS,1000); };
  ws.onerror = () => { setConn('Reconnecting…'); try{ws.close()}catch{} };
}
startWS();

/* ---------- ingestion ---------- */
function ingest(t){
  if(!startTime) startTime=t.t;

  // price text only (no panel flash)
  if(lastPrice!==null){
    priceEl.classList.remove('price-up','price-down');
    if(t.p>lastPrice) priceEl.classList.add('price-up');
    else if(t.p<lastPrice) priceEl.classList.add('price-down');
  }
  lastPrice=t.p;
  priceEl.textContent=fmtUSD.format(t.p);

  trades.push(t);
  series.push({t:t.t, p:t.p});

  const cutoff = Date.now() - MS10;
  trades = trades.filter(tr=>tr.t>=cutoff);
  series = series.filter(s=>s.t>=cutoff);

  draw();
}

/* ---------- draw ---------- */
function draw(){ drawPrice(); drawVol(); }

/* ===== Smooth helpers (Catmull–Rom → Bezier) ===== */
function smoothPath(points){
  if(points.length<2) return points;
  const out=[];
  for(let i=0;i<points.length-1;i++){
    const p0=points[i-1]||points[i], p1=points[i], p2=points[i+1], p3=points[i+2]||p2;
    const cp1x=p1.x+(p2.x-p0.x)/6, cp1y=p1.y+(p2.y-p0.y)/6;
    const cp2x=p2.x-(p3.x-p1.x)/6, cp2y=p2.y-(p3.y-p1.y)/6;
    out.push({p1,cp1:{x:cp1x,y:cp1y},cp2:{x:cp2x,y:cp2y},p2});
  }
  return out;
}

/* ---------- price chart ---------- */
function roundRect(context,x,y,w,h,r){
  context.beginPath();
  context.moveTo(x+r,y);
  context.arcTo(x+w,y,x+w,y+h,r);
  context.arcTo(x+w,y+h,x,y+h,r);
  context.arcTo(x,y+h,x,y,r);
  context.arcTo(x,y,x+w,y,r);
  context.closePath();
}

function drawGrid(context, w, h, padL, padR, padT, padB){
  context.strokeStyle='var(--grid)'; context.lineWidth=1;
  // horizontals
  for(let i=1;i<=3;i++){
    const y = padT + (h-padT-padB)*(i/4*(4/3));
    context.beginPath(); context.moveTo(padL-6,y); context.lineTo(w-padR+6,y); context.stroke();
  }
  // x labels (minutes)
  const innerW=w-padL-padR, baseY=h-padB+4;
  context.fillStyle='rgba(255,255,255,.75)';
  context.font='11px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  context.textAlign='center'; context.textBaseline='top';
  const now = Date.now();
  for(let i=0;i<=10;i+=2){
    const t = now - (10-i)*MS1M;
    const x = padL + innerW*((t - (now-MS10))/MS10);
    context.fillText(':'+new Date(t).toLocaleTimeString([],{minute:'2-digit'}), x, baseY);
  }
}

function drawPrice(){
  const w=chart.clientWidth, h=chart.clientHeight;
  ctx.clearRect(0,0,w,h);

  const padL=58, padR=12, padT=10, padB=22;
  const innerW=w-padL-padR, innerH=h-padT-padB;

  if(series.length<2){
    drawGrid(ctx,w,h,padL,padR,padT,padB);
    return;
  }

  // fill from left while <10m of data
  const now = Date.now();
  const elapsed = now - startTime;
  const windowLen = Math.min(MS10, elapsed);
  const start = now - windowLen;

  // min/max within current window
  let min=Infinity,max=-Infinity,sum=0,count=0;
  for(const s of series){ if(s.t>=start){min=Math.min(min,s.p);max=Math.max(max,s.p);sum+=s.p;count++;} }
  if(!isFinite(min)||!isFinite(max)){ drawGrid(ctx,w,h,padL,padR,padT,padB); return; }
  const avg = sum/(count||1);
  const range=(max-min)||1;

  drawGrid(ctx,w,h,padL,padR,padT,padB);

  // y labels
  ctx.fillStyle='rgba(255,255,255,.85)';
  ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.textBaseline='middle';
  ctx.fillText(fmtUSD0.format(max), 8, padT+10);
  const yAvg = padT + innerH * (1 - (avg-min)/range);
  ctx.fillText(fmtUSD0.format(avg), 8, Math.max(padT+14, Math.min(h-padB-14, yAvg)));
  ctx.fillText(fmtUSD0.format(min), 8, h-padB-10);

  // dashed avg line
  ctx.save();
  ctx.setLineDash([6,6]);
  ctx.strokeStyle='rgba(200,214,207,.6)';
  ctx.beginPath();
  ctx.moveTo(padL, yAvg);
  ctx.lineTo(w-padR, yAvg);
  ctx.stroke();
  ctx.restore();

  // build points (left->right growth)
  const pts=[];
  for(const s of series){
    if(s.t<start) continue;
    const x = padL + innerW * ((s.t - start) / windowLen);
    const y = padT + innerH * (1 - (s.p-min)/range);
    pts.push({x,y});
  }
  if(pts.length<2) return;

  // smooth path
  const segs=smoothPath(pts);
  ctx.lineWidth=2; ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
  for(const s of segs){ ctx.bezierCurveTo(s.cp1.x,s.cp1.y,s.cp2.x,s.cp2.y,s.p2.x,s.p2.y); }
  ctx.stroke();

  // latest price pill (always inside canvas)
  const last=pts.at(-1);
  const tag=fmtUSD0.format(lastPrice??avg);
  ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  const tw = ctx.measureText(tag).width + 12;
  const th = 18;
  const bx = Math.min(w-padR-tw, Math.max(padL, last.x - tw/2));
  const by = Math.max(padT+2, Math.min(h-padB-th-2, last.y - th - 8));
  ctx.fillStyle='rgba(0,0,0,.85)';
  ctx.strokeStyle='rgba(255,255,255,.25)';
  roundRect(ctx, bx, by, tw, th, 9); ctx.fill(); ctx.stroke();
  ctx.fillStyle='white'; ctx.textBaseline='middle'; ctx.textAlign='left';
  ctx.fillText(tag, bx+6, by+th/2);
}

/* ---------- volume ---------- */
const MS = 60000;
function bins10(){
  const now=Date.now();
  // anchor bins to minute boundaries so they slide right->left
  const start = (now - 9*MS) - ((now - 9*MS) % MS);
  const bins = Array.from({length:10},(_,i)=>({ts:start+i*MS,buy:0,sell:0}));
  for(const t of trades){
    const idx = Math.floor((t.t - start)/MS);
    if(idx>=0 && idx<10){ if(t.side==='sell') bins[idx].sell += t.s; else bins[idx].buy += t.s; }
  }
  return bins;
}

function drawVol(){
  const w=vol.clientWidth,h=vol.clientHeight;
  vctx.clearRect(0,0,w,h);

  const bins=bins10();
  const totals=bins.map(b=>b.buy+b.sell);
  const max=Math.max(1,...totals);
  maxVolEl.textContent='max ₿'+fmtBTC.format(Math.max(...totals)||0);

  const padX=26,padY=12,innerW=w-2*padX,innerH=h-2*padY;
  const step=innerW/10,barW=step*0.62;

  const up=getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn=getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  // minute ticks + labels
  vctx.strokeStyle='var(--grid)'; vctx.lineWidth=1;
  for(let i=1;i<=3;i++){ const y=padY+innerH*(i/4*(4/3)); vctx.beginPath(); vctx.moveTo(padX-6,y); vctx.lineTo(w-padX+6,y); vctx.stroke();}
  vctx.font='11px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  vctx.fillStyle='rgba(255,255,255,.75)'; vctx.textAlign='center'; vctx.textBaseline='top';
  for(let i=0;i<10;i+=2){
    const b=bins[i], x=padX+step*i+step/2;
    vctx.fillText(':'+new Date(b.ts).toLocaleTimeString([],{minute:'2-digit'}), x, h-18);
  }

  // bars + labels
  for(let i=0;i<bins.length;i++){
    const b=bins[i];
    const x=padX+step*i+(step-barW)/2;
    const tot=b.buy+b.sell;
    const hTot=Math.max(2,innerH*(tot/max));
    const hSell=(b.sell/tot||0)*hTot;
    const hBuy=hTot-hSell;
    const yBase=padY+innerH;

    // sells bottom, buys on top
    vctx.fillStyle=dn; vctx.fillRect(x,yBase-hSell,barW,hSell);
    vctx.fillStyle=up; vctx.fillRect(x,yBase-hSell-hBuy,barW,hBuy);

    // total pill (above bar) — clamp inside chart so it doesn't get cut off
    if(hTot>22 && tot>0){
      const totalTxt='₿'+fmtBTC.format(tot);
      const tw=vctx.measureText(totalTxt).width+10, th=16;
      const bx = Math.max(padX+2, Math.min(w-padX-2-tw, x+(barW-tw)/2));
      const topY = yBase-hTot-22;
      const by = Math.max(padY+2, topY);
      // halo
      vctx.fillStyle='rgba(0,0,0,.85)';
      rounded(vctx,bx,by,tw,th,8); vctx.fill();
      vctx.fillStyle='white'; vctx.textBaseline='middle'; vctx.textAlign='center';
      vctx.fillText(totalTxt, bx+tw/2, by+th/2);
    }

    // ± diff pill (center of bar) — green if buy>sell, amber if sell>buy
    const diff = b.buy - b.sell;
    if(Math.abs(diff) >= 0.01 && hTot>34){
      const diffTxt = (diff>0?'+':'') + fmtBTC.format(diff);
      const tw=vctx.measureText(diffTxt).width+12, th=16;
      const bx = Math.max(padX+2, Math.min(w-padX-2-tw, x+(barW-tw)/2));
      const by = yBase - hSell - hBuy/2 - th/2; // center of the whole bar
      vctx.fillStyle='rgba(0,0,0,.85)';
      rounded(vctx,bx,by,tw,th,9); vctx.fill();
      vctx.strokeStyle= diff>=0 ? up : dn;
      vctx.lineWidth=1; vctx.stroke();
      vctx.fillStyle= diff>=0 ? up : dn;
      vctx.textBaseline='middle'; vctx.textAlign='center';
      vctx.fillText(diffTxt, bx+tw/2, by+th/2);
    }
  }
}

function rounded(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

resizeAll();
</script>
</body>
</html>