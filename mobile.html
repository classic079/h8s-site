<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>h8s.us — Mobile</title>
<style>
:root{
  --bg:#0a0a0a;--panel:#101010;--ink:#eafaf3;--muted:#aeb9b4;
  --up:#2dd4bf;--down:#f59e0b;--glass:rgba(255,255,255,.06)
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
.wrap{max-width:820px;margin:0 auto;padding:10px}
.card{background:var(--panel);border-radius:16px;box-shadow:0 0 0 1px var(--glass);padding:10px;margin:8px 0}
.livePrice{font-size:clamp(28px,9vw,48px);font-weight:900;text-align:center;line-height:1.05}
.livePrice.up{color:var(--up)}.livePrice.down{color:var(--down)}
.seg{display:flex;gap:6px;background:#0e0e0e;border-radius:12px;padding:6px;box-shadow:0 0 0 1px var(--glass) inset}
.seg button{flex:1;padding:10px 0;border:0;border-radius:10px;background:transparent;color:var(--ink);
  font-weight:800;letter-spacing:.2px;font-size:14px;cursor:pointer}
.seg button.active{background:#14201d;color:var(--up);box-shadow:0 0 0 1px rgba(45,212,191,.25) inset}
.seg button:not(.active){color:var(--muted)}
.chartBox{padding:6px;border-radius:12px;background:#0f0f0f}
#priceChart{width:100%;height:320px;display:block}
#volChart{width:100%;height:230px;display:block}
.legend{display:flex;gap:10px;align-items:center;margin:2px 6px 6px}
.dot{width:12px;height:12px;border-radius:3px;display:inline-block}
.dot.up{background:var(--up)}.dot.down{background:var(--down)}
.maxLbl{margin-left:auto;opacity:.85;font-weight:700;font-size:11px}
.pill{position:fixed;left:10px;bottom:10px;padding:5px 9px;border-radius:10px;
  background:#15201c;color:var(--up);border:1px solid rgba(45,212,191,.25);font-weight:700;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card"><div id="price" class="livePrice">$—</div></div>

  <div class="card seg">
    <button data-k="10m" class="active">10min</button>
    <button data-k="1h">1hr</button>
    <button data-k="1d">1day</button>
  </div>

  <div class="card"><div class="chartBox"><canvas id="priceChart"></canvas></div></div>

  <div class="card">
    <div class="legend">
      <span class="dot up"></span><small>Buys</small>
      <span class="dot down"></span><small>Sells</small>
      <span id="volMax" class="maxLbl">max —</span>
    </div>
    <div class="chartBox"><canvas id="volChart"></canvas></div>
  </div>
</div>

<span id="conn" class="pill">Connecting…</span>

<script>
const $=s=>document.querySelector(s);
const priceEl=$('#price'),connEl=$('#conn');
const pCan=$('#priceChart'),pctx=pCan.getContext('2d',{desynchronized:true});
const vCan=$('#volChart'),vctx=vCan.getContext('2d',{desynchronized:true});
const volMaxEl=$('#volMax');
const segBtns=[...document.querySelectorAll('.seg button')];

const fmtUSD=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtBTC2=new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
const UP=getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
const DN=getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

function fit(c,ctx){const dpr=Math.max(1,Math.min(devicePixelRatio||1,2.5));c.width=c.clientWidth*dpr;c.height=c.clientHeight*dpr;ctx.setTransform(dpr,0,0,dpr,0,0)}
new ResizeObserver(()=>{fit(pCan,pctx);fit(vCan,vctx);drawPrice();drawVol()}).observe(document.body);

/* Frames */
const FRAMES={
  '10m':{span:10*60*1000,bins:10,binMs:60*1000,prefer:[60,30],jumpPct:0.018},
  '1h' :{span:60*60*1000,bins:12,binMs:5*60*1000,prefer:[300,60],jumpPct:0.015},
  '1d' :{span:24*60*60*1000,bins:24,binMs:60*60*1000,prefer:[3600,900,300],jumpPct:0.012}
};
let FRAME_KEY='10m',frame=FRAMES[FRAME_KEY];

let lastPrice=null;
let linePts=[]; // {t,p}
let bins=[];   // [{ts,buy,sell}]
let ws;

/* UI */
segBtns.forEach(b=>b.addEventListener('click',async e=>{
  segBtns.forEach(x=>x.classList.remove('active'));
  e.currentTarget.classList.add('active');
  FRAME_KEY=e.currentTarget.dataset.k;
  frame=FRAMES[FRAME_KEY];
  await bootstrapFrame();
}));

/* Fetch candles */
const iso=ms=>new Date(ms).toISOString();
async function fetchCandlesTry(spanMs,gran){
  const end=Date.now(),start=end-spanMs;
  const u=`https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=${gran}&start=${encodeURIComponent(iso(start))}&end=${encodeURIComponent(iso(end))}`;
  const r=await fetch(u,{headers:{Accept:'application/json'}});
  if(!r.ok) throw 0;
  const raw=await r.json();
  return raw.sort((a,b)=>a[0]-b[0]).map(c=>({t:c[0]*1000,p:+c[4],v:+c[5]}));
}
async function fetchCandlesRobust(spanMs,prefer){
  for(const g of prefer){
    try{const a=await fetchCandlesTry(spanMs,g);if(a.length>=2)return a}catch(_){}
  }
  try{const a=await fetchCandlesTry(spanMs,60);if(a.length>=2)return a}catch(_){}
  return [];
}
/* Resample to ~1 point per ~24px */
function resampleForWidth(points,px){
  const maxN=Math.max(60,Math.floor(px/24));
  if(points.length<=maxN) return points;
  const step=points.length/maxN,out=[];
  for(let i=0;i<maxN;i++){out.push(points[Math.floor(i*step)])}
  return out;
}
/* Stitch minute “ghost” points to now so the bridge to live is small */
function stitchToNow(points, granMs){
  if(points.length===0) return points;
  const now=Date.now();
  const last=points.at(-1);
  let t=last.t+granMs;
  const out=[...points];
  while(t<=now-1000){ // stop a second shy; live will fill
    out.push({t,p:last.p});
    t+=granMs;
  }
  return out;
}

function seedFromCandles(candles){
  const capd=resampleForWidth(candles,pCan.clientWidth);
  const granGuess=Math.max(60*1000, Math.round(frame.span/Math.max(30,capd.length)));
  linePts=stitchToNow(capd, granGuess);
  if(linePts.length){lastPrice=linePts.at(-1).p; priceEl.textContent=fmtUSD.format(lastPrice)}
  const start=Date.now()-frame.span;
  bins=Array.from({length:frame.bins},(_,i)=>({ts:start+i*frame.binMs,buy:0,sell:0}));
  for(const c of candles){
    const i=Math.min(frame.bins-1,Math.max(0,Math.floor((c.t-start)/frame.binMs)));
    const buy=c.v*0.7,sell=c.v*0.3;
    bins[i].buy+=buy;bins[i].sell+=sell;
  }
}

async function bootstrapFrame(){
  linePts=[];bins=[];drawPrice();drawVol();
  try{const c=await fetchCandlesRobust(frame.span,frame.prefer);if(c.length>=2)seedFromCandles(c)}catch(_){}
  drawPrice();drawVol();
}

/* Live */
function setConn(txt,color){connEl.textContent=txt;if(color)connEl.style.color=color}
function startWS(){
  try{ws&&ws.close()}catch{}
  ws=new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('Connecting…','#fbbf24');
  ws.onopen=()=>ws.send(JSON.stringify({type:'subscribe',product_ids:['BTC-USD'],channels:['matches']}));
  ws.onmessage=e=>{
    try{
      const m=JSON.parse(e.data);
      if(m.type==='match'&&m.product_id==='BTC-USD'){
        const t=+new Date(m.time),p=+m.price,sz=+m.size,side=(m.side==='sell'?'sell':'buy');
        liveIngest(t,p,sz,side);
      }
    }catch(_){}
  };
  ws.onerror=()=>setConn('Fallback','#fb7185');
  ws.onclose =()=>{setConn('Reconnecting…','#fbbf24');setTimeout(startWS,1000)}
}
function liveIngest(t,p,sz,side){
  if(lastPrice!==null){priceEl.classList.remove('up','down'); if(p>lastPrice)priceEl.classList.add('up'); else if(p<lastPrice)priceEl.classList.add('down')}
  lastPrice=p; priceEl.textContent=fmtUSD.format(p); setConn('Live',UP);

  const start=Date.now()-frame.span;
  linePts.push({t,p});
  while(linePts.length && linePts[0].t<start) linePts.shift();

  if(!bins.length){
    const s=Date.now()-frame.span;
    bins=Array.from({length:frame.bins},(_,i)=>({ts:s+i*frame.binMs,buy:0,sell:0}));
  }
  while(bins.at(-1).ts+frame.binMs < start+frame.span){
    const lastTS=bins.at(-1).ts; bins.shift(); bins.push({ts:lastTS+frame.binMs,buy:0,sell:0});
  }
  const idx=Math.min(bins.length-1,Math.max(0,Math.floor((t-start)/frame.binMs)));
  if(side==='sell') bins[idx].sell+=sz; else bins[idx].buy+=sz;

  drawPrice();drawVol();
}

/* Draw price with gap + jump guards */
function drawPrice(){
  fit(pCan,pctx);
  const w=pCan.clientWidth,h=pCan.clientHeight;
  const padL=12,padR=10,padT=10,padB=26; // more bottom for ticks
  const x0=padL,x1=w-padR,y0=padT,y1=h-padB;
  pctx.clearRect(0,0,w,h); pctx.fillStyle='#0f0f0f'; pctx.fillRect(0,0,w,h);
  const now=Date.now(),start=now-frame.span;
  const pts=linePts.filter(s=>s.t>=start);
  if(pts.length<2)return;

  let lo=Infinity,hi=-Infinity,sum=0;
  for(const s of pts){if(s.p<lo)lo=s.p;if(s.p>hi)hi=s.p;sum+=s.p}
  const avg=sum/pts.length,rng=(hi-lo)||1;
  const yMap=v=>y0+(y1-y0)*(1-(v-lo)/rng);
  pctx.strokeStyle='rgba(255,255,255,.06)'; pctx.lineWidth=1;
  for(let i=1;i<=2;i++){const y=y0+(y1-y0)*i/3;pctx.beginPath();pctx.moveTo(x0,y);pctx.lineTo(x1,y);pctx.stroke()}
  pctx.save();pctx.setLineDash([6,6]);pctx.strokeStyle='rgba(200,214,207,.45)';
  const yAvg=yMap(avg); pctx.beginPath();pctx.moveTo(x0,yAvg);pctx.lineTo(x1,yAvg);pctx.stroke();pctx.restore();

  // time ticks (sparse) 
  const tickEvery = FRAME_KEY==='10m'? 2*60*1000 : FRAME_KEY==='1h'? 15*60*1000 : 2*60*60*1000;
  pctx.fillStyle='rgba(255,255,255,.55)'; pctx.textAlign='center'; pctx.textBaseline='top'; pctx.font='10px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  const first=start + (tickEvery - (start%tickEvery));
  for(let t=first;t<=now;t+=tickEvery){
    const rel=(t-start)/frame.span, x=x1 - rel*(x1-x0);
    pctx.fillText(new Date(t).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}).replace(/^0/,'').replace(' ',''),
      x,y1+5);
  }

  // draw segments with guards
  const maxGap=30*1000;                         // 30s gap => new segment
  const jumpGuard = frame.jumpPct;              // e.g., 1.8% for 10m
  for(let i=1;i<pts.length;i++){
    const a=pts[i-1],b=pts[i];
    const gap=b.t-a.t;
    const relB=(b.t-start)/frame.span, xB=x1 - relB*(x1-x0);
    const relA=(a.t-start)/frame.span, xA=x1 - relA*(x1-x0);
    const yA=yMap(a.p),yB=yMap(b.p);

    if(gap>maxGap) continue;                    // break
    const mid=(a.p+b.p)/2, big=Math.abs(b.p-a.p)/Math.max(1,mid);
    if(big>jumpGuard) continue;                 // ignore crazy jump

    // fade by age
    const age=(now-b.t)/frame.span;
    const alpha=Math.max(0,1-age*1.6);
    pctx.strokeStyle=`rgba(45,212,191,${alpha.toFixed(3)})`; pctx.lineWidth=2;
    pctx.beginPath(); pctx.moveTo(xA,yA); pctx.lineTo(xB,yB); pctx.stroke();
  }
}

/* Draw volume */
function drawVol(){
  fit(vCan,vctx);
  const w=vCan.clientWidth,h=vCan.clientHeight;
  const padL=16,padR=10,padT=6,padB=22;
  const chartH=h-padT-padB,step=(w-padL-padR)/frame.bins,barW=Math.max(2,step*0.7);
  vctx.clearRect(0,0,w,h); vctx.fillStyle='#0f0f0f'; vctx.fillRect(0,0,w,h);
  if(!bins.length){volMaxEl.textContent='max —';return}
  const totals=bins.map(b=>b.buy+b.sell);
  const maxRaw=Math.max(0.01,...totals), max=maxRaw*1.25;
  volMaxEl.textContent='max ₿'+fmtBTC2.format(maxRaw);
  vctx.strokeStyle='rgba(255,255,255,.05)'; vctx.lineWidth=1;
  for(let i=1;i<=2;i++){const y=padT+chartH*i/3; vctx.beginPath(); vctx.moveTo(padL,y); vctx.lineTo(w-padR,y); vctx.stroke()}
  const now=Date.now(),start=now-frame.span,x0=padL,x1=w-padR;
  for(let i=0;i<bins.length;i++){
    const b=bins[i],total=b.buy+b.sell;
    const rel=(b.ts-start)/frame.span, x=x1 - rel*(x1-x0) - step/2;
    const yBase=padT+chartH, hT=Math.max(1,(total/max)*chartH), hBuy=total?(b.buy/total)*hT:0;
    vctx.fillStyle=DN; vctx.fillRect(x-barW/2, yBase-(hT-hBuy), barW, hT-hBuy);
    vctx.fillStyle=UP; vctx.fillRect(x-barW/2, yBase-hT,       barW, hBuy);
  }
}

/* Kickoff */
(async ()=>{
  fit(pCan,pctx);fit(vCan,vctx);
  await bootstrapFrame();
  startWS();
})();
</script>
</body>
</html>