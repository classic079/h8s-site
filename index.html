<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>BTC Stalker - Multi-Timeframe v13.51</title>
<script>
// Mobile detection - redirect to mobile.html if on phone/tablet
(function(){
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  if(isMobile && !window.location.pathname.includes('mobile.html')){
    window.location.href = 'mobile.html';
  }
})();
</script>
<style>
:root{
  --bg:#0a0a0a; --panel:#111; --panel-2:#0d0d0d;
  --text:#e9fef7; --muted:#c8d6cf;
  --up:#2dd4bf; --down:#f59e0b;
  --grid:rgba(255,255,255,.08);
  --glow:0 0 0 1px rgba(255,255,255,.06), 0 18px 40px rgba(0,0,0,.45);
}
:root[data-theme="light"]{
  --bg:#f5f7fa; --panel:#ffffff; --panel-2:#f8f9fb;
  --text:#1a1d23; --muted:#64748b;
  --up:#059669; --down:#dc2626;
  --grid:rgba(0,0,0,.08);
  --glow:0 0 0 1px rgba(0,0,0,.06), 0 8px 24px rgba(0,0,0,.08);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}

.wrap{max-width:1920px;margin:8px auto 8px;padding:0 16px}

/* Header */
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;gap:10px}
.headerLeft{display:flex;gap:8px;align-items:center}
.headerCenter{flex:1;text-align:center}
.headerRight{display:flex;gap:8px;align-items:center}
#livePrice{font-weight:900;font-size:clamp(22px,3.5vw,36px);letter-spacing:.4px;transition:color .18s}
#livePrice.up{color:var(--up)}
#livePrice.down{color:var(--down)}

/* Pills */
.pill{display:inline-flex;align-items:center;gap:6px;padding:3px 10px;
  border-radius:999px;background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.22);
  font-size:15px;white-space:nowrap;color:#fff;opacity:.92}
[data-theme="light"] .pill{background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.15);color:var(--text)}
.pill.flash{animation:flashy .4s ease-out}
@keyframes flashy{0%{opacity:.5}60%{opacity:1}100%{opacity:.92}}
#connPill{position:fixed;left:12px;bottom:12px;z-index:50}
.conn-ok{color:var(--up);border-color:var(--up)}
.conn-warn{color:#fbbf24;border-color:#fbbf24}
.conn-err{color:#fb7185;border-color:#fb7185}

/* Bottom Right Pills Container */
.bottomRightPills{position:fixed;right:24px;bottom:24px;z-index:50;display:flex;gap:8px;align-items:center}
@media(max-width:760px){.bottomRightPills{right:16px;bottom:16px;flex-wrap:wrap}}

/* Big Clock Pill */
.bigClockPill{font-size:clamp(17px,2.16vw,22px);font-weight:700;letter-spacing:1px;
  font-family:'Courier New',monospace;padding:8px 16px;
  display:inline-flex;align-items:center;border-radius:999px;
  background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.22);
  color:#fff;opacity:.92;transition:opacity .3s;user-select:none}
[data-theme="light"] .bigClockPill{background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.15);color:var(--text)}
.bigClockPill:hover{opacity:1}

/* Weather Bar - Expanded */
.weatherBar{font-size:clamp(17px,2.16vw,22px);font-weight:600;
  font-family:'Courier New',monospace;padding:8px 16px;
  display:inline-flex;align-items:center;gap:12px;border-radius:999px;
  background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.22);
  color:#fff;opacity:.92;transition:opacity .3s;white-space:nowrap;user-select:none}
[data-theme="light"] .weatherBar{background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.15);color:var(--text)}
.weatherBar:hover{opacity:1}
.weatherBar .divider{opacity:.3;margin:0 4px}
.weatherBar .label{opacity:.6;font-size:0.85em}

/* Settings button */
.settingsBtn{cursor:pointer;transition:all .2s;user-select:none}
.settingsBtn:hover{opacity:1;transform:scale(1.05);border-color:rgba(255,255,255,.4)}
.settingsBtn:active{transform:scale(0.98)}

/* Settings modal */
.settingsModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);
  display:none;align-items:center;justify-content:center;z-index:100}
.settingsModal.open{display:flex}
.settingsContent{background:var(--panel);border-radius:16px;padding:24px;
  max-width:500px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,.7);border:1px solid rgba(255,255,255,.1)}
.settingsHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
.settingsHeader h2{margin:0;font-size:20px}
.closeBtn{cursor:pointer;font-size:24px;opacity:.7;transition:opacity .2s}
.closeBtn:hover{opacity:1}
.settingsSection{margin-bottom:20px}
.settingsSection h3{font-size:14px;margin:0 0 10px;opacity:.8;text-transform:uppercase;letter-spacing:.5px}
.settingOption{display:flex;justify-content:space-between;align-items:center;padding:10px;
  border-radius:8px;background:rgba(255,255,255,.03);margin-bottom:8px}
.settingOption:hover{background:rgba(255,255,255,.06)}
.settingOption input[type="checkbox"]{cursor:pointer;width:18px;height:18px}
.settingOption input[type="text"]{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);
  border-radius:6px;padding:6px 10px;color:var(--text);font-size:14px;width:120px}
.settingOption input[type="text"]:focus{outline:none;border-color:var(--up);background:rgba(255,255,255,.15)}
.settingsActions{display:flex;gap:10px;justify-content:flex-end;margin-top:20px}
.btn{padding:10px 20px;border-radius:8px;border:none;cursor:pointer;font-size:14px;font-weight:600;transition:all .2s}
.btnPrimary{background:var(--up);color:#000}
.btnPrimary:hover{opacity:.9;transform:scale(1.02)}
.btnSecondary{background:rgba(255,255,255,.1);color:#fff;border:1px solid rgba(255,255,255,.2)}
.btnSecondary:hover{background:rgba(255,255,255,.15)}

/* Grid */
.grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
@media(max-width:1500px){.grid{grid-template-columns:repeat(2,1fr)}}
@media(max-width:760px){.grid{grid-template-columns:1fr}}

/* Column cards */
.col{background:var(--panel);border-radius:14px;box-shadow:var(--glow);padding:10px;display:flex;flex-direction:column}
.colHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.tfLabel{font-weight:800;font-size:13px;letter-spacing:.5px;text-transform:uppercase;color:var(--muted)}
.statPills{display:flex;gap:6px;flex-wrap:wrap}
.statPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.6);color:#fff;white-space:nowrap}
.statPill.up{background:var(--up);border-color:transparent;color:#0a0a0a;font-weight:700}
.statPill.down{background:var(--down);border-color:transparent;color:#0a0a0a;font-weight:700}

/* Charts */
.chartBox{background:var(--panel-2);border-radius:10px;height:200px;margin-bottom:8px;position:relative}
.chartBox canvas{display:block;width:100%;height:100%;border-radius:10px}
.volBox{background:var(--panel-2);border-radius:10px;height:120px}
.volBox canvas{display:block;width:100%;height:100%;border-radius:10px}

/* Gauge (10m only) */
.gaugeRow{display:flex;align-items:center;gap:8px;padding:6px 8px;margin-top:8px}
.gLabel{font-size:11px;opacity:.9}
.gLabel.buy{color:var(--up)}.gLabel.sell{color:var(--down)}
[id^="biasGauge-"]{width:100%;height:20px;border-radius:999px;background:transparent;box-shadow:inset 0 0 0 1px rgba(255,255,255,.12)}
.gaugeWrap{position:relative;flex:1}
.needle{position:absolute;top:2px;width:0;height:0;border-left:6px solid transparent;
  border-right:6px solid transparent;border-top:9px solid #fff;
  filter:drop-shadow(0 2px 2px rgba(0,0,0,.35));transition:left .2s}
.needleValue{position:absolute;top:-13px;transform:translateX(-50%);
  background:rgba(0,0,0,.8);color:#fff;font-size:10px;padding:2px 6px;
  border-radius:8px;border:1px solid rgba(255,255,255,.25)}

/* Metric pills */
.metricPills{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin:8px 0}
.metricPill{font-size:11px;padding:3px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.1);background:rgba(0,0,0,.5);color:#cbd5e1;white-space:nowrap}

/* Top trades */
.topTrades{margin-top:10px;padding:8px}
.topHeader{font-size:11px;font-weight:700;margin-bottom:8px;opacity:.9}
.topGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.topCol{border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:6px 6px 4px}
.topCol h4{margin:2px 6px 6px;font-size:11px;letter-spacing:.4px;text-transform:uppercase;white-space:nowrap}
.buyCol{background:color-mix(in oklab, var(--up) 12%, transparent);border-color:color-mix(in oklab, var(--up) 35%, transparent)}
.sellCol{background:color-mix(in oklab, var(--down) 12%, transparent);border-color:color-mix(in oklab, var(--down) 35%, transparent)}
[data-theme="light"] .buyCol{background:rgba(5,150,105,.08);border-color:rgba(5,150,105,.25)}
[data-theme="light"] .sellCol{background:rgba(220,38,38,.08);border-color:rgba(220,38,38,.25)}
.topList{list-style:none;margin:0;padding:0;font-variant-numeric:tabular-nums}
.topItem{padding:7px 6px;border-radius:8px;font-size:13px;display:flex;gap:8px;align-items:baseline}
.topItem .usd{font-weight:800;color:var(--text);flex:0 0 auto}
.topItem .btc{color:var(--muted);flex:0 0 auto}
.topItem .t{color:var(--muted);flex:0 0 auto;font-size:12px;opacity:.75}
.topItem.newTrade{animation:blinkTrade var(--blink-duration, 5s) ease-in-out}
@keyframes blinkTrade{
  0%{background:transparent;transform:scale(1);box-shadow:none}
  5%{background:rgba(255,255,0,.8);transform:scale(1.1);box-shadow:0 0 30px rgba(255,255,0,1)}
  10%,90%{background:rgba(255,255,0,.8);transform:scale(1.1);box-shadow:0 0 30px rgba(255,255,0,1)}
  95%{background:rgba(255,255,0,.4);transform:scale(1.05);box-shadow:0 0 15px rgba(255,255,0,.5)}
  100%{background:transparent;transform:scale(1);box-shadow:none}
}
.volBox.spikeAlert{animation:volSpike 3s ease-out}
@keyframes volSpike{
  0%{box-shadow:0 0 30px rgba(255,255,255,.6);transform:scale(1.02)}
  15%{box-shadow:0 0 20px rgba(255,255,255,.4)}
  30%{box-shadow:0 0 30px rgba(255,255,255,.6)}
  45%{box-shadow:0 0 20px rgba(255,255,255,.4)}
  60%{box-shadow:0 0 30px rgba(255,255,255,.6)}
  80%{box-shadow:0 0 10px rgba(255,255,255,.2)}
  100%{box-shadow:none;transform:scale(1)}
}
</style>
<!-- Firebase removed - now using MySQL for top trades storage -->
<!-- <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script> -->
</head>
<body>
<span id="connPill" class="pill conn-warn">Connecting‚Ä¶</span>

<div class="wrap">
  <header>
    <div class="headerLeft">
      <span class="pill settingsBtn" onclick="openSettings()">‚öôÔ∏è Settings</span>
      <span class="pill">BTC/USD</span>
      <span class="pill" style="opacity:.6">v13.51</span>
      <span id="d24Change" class="pill">24h Œî ‚Äî</span>
    </div>
    <div class="headerCenter">
      <div id="livePrice">$‚Äî</div>
    </div>
    <div class="headerRight">
      <span id="ethPrice" class="pill">ETH ‚Äî</span>
      <span id="xrpPrice" class="pill">XRP ‚Äî</span>
      <span id="adaPrice" class="pill">ADA ‚Äî</span>
      <span id="goldPrice" class="pill">Gold ‚Äî</span>
      <span id="oilPrice" class="pill">Oil ‚Äî</span>
    </div>
  </header>

  <section class="grid" id="dashboard"></section>
</div>

<!-- Bottom Right Pills -->
<div class="bottomRightPills">
  <div id="weatherBar" class="weatherBar">
    <span id="weatherNow">üå§Ô∏è --¬∞F</span>
    <span class="divider">|</span>
    <span id="weatherToday"><span class="label">Today:</span> H -- L --</span>
    <span class="divider">|</span>
    <span id="weatherTomorrow"><span class="label">Tomorrow:</span> -- H -- L --</span>
  </div>
  <div id="bigClock" class="bigClockPill">--:--:--</div>
</div>

<!-- Settings Modal -->
<div class="settingsModal" id="settingsModal" onclick="if(event.target === this) closeSettings()">
  <div class="settingsContent">
    <div class="settingsHeader">
      <h2>Settings</h2>
      <span class="closeBtn" onclick="closeSettings()">&times;</span>
    </div>

    <div class="settingsSection">
      <h3>Theme</h3>
      <div class="settingOption" style="cursor:pointer" onclick="selectTheme('dark')">
        <span>üåô Dark Mode</span>
        <span id="themeDarkCheck"></span>
      </div>
      <div class="settingOption" style="cursor:pointer" onclick="selectTheme('light')">
        <span>‚òÄÔ∏è Light Mode</span>
        <span id="themeLightCheck"></span>
      </div>
    </div>

    <div class="settingsSection">
      <h3>Visible Charts</h3>
      <div class="settingOption">
        <span>30 Day</span>
        <input type="checkbox" id="chart30d" checked>
      </div>
      <div class="settingOption">
        <span>24 Hour</span>
        <input type="checkbox" id="chart24h" checked>
      </div>
      <div class="settingOption">
        <span>12 Hour</span>
        <input type="checkbox" id="chart12h">
      </div>
      <div class="settingOption">
        <span>8 Hour</span>
        <input type="checkbox" id="chart8h" checked>
      </div>
      <div class="settingOption">
        <span>1 Hour</span>
        <input type="checkbox" id="chart1h" checked>
      </div>
      <div class="settingOption">
        <span>10 Minute</span>
        <input type="checkbox" id="chart10m" checked>
      </div>
      <div class="settingOption">
        <span>5 Minute</span>
        <input type="checkbox" id="chart5m" checked>
      </div>
      <div class="settingOption">
        <span>1 Minute</span>
        <input type="checkbox" id="chart1m">
      </div>
      <div class="settingOption">
        <span>üì∞ Live News Feed</span>
        <input type="checkbox" id="chartNews">
      </div>
      <div class="settingOption">
        <span>üìä Live Ticker</span>
        <input type="checkbox" id="chartTicker">
      </div>
    </div>

    <div class="settingsSection">
      <h3>Weather</h3>
      <div class="settingOption">
        <span>üìç Zip Code</span>
        <input type="text" id="weatherZip" placeholder="43440" maxlength="5">
      </div>
    </div>

    <div class="settingsSection">
      <h3>News Filter</h3>
      <div class="settingOption" style="flex-direction:column;align-items:flex-start;gap:8px">
        <span>üö´ Block words (comma separated)</span>
        <input type="text" id="newsFilter" placeholder="Trump, Biden, election" style="width:100%">
        <small style="opacity:0.6;font-size:12px">News containing these words will be hidden</small>
      </div>
    </div>

    <div class="settingsSection">
      <h3>Alerts</h3>
      <div class="settingOption">
        <span>Volume Spike Alerts</span>
        <input type="checkbox" id="alertVolSpike" checked>
      </div>
      <div class="settingOption">
        <span>Large Trade Blink</span>
        <input type="checkbox" id="alertTradeBlink" checked>
      </div>
    </div>

    <div class="settingsActions">
      <button class="btn btnSecondary" onclick="closeSettings()">Cancel</button>
      <button class="btn btnPrimary" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<script>
/* ===== MySQL Storage (replaces Firebase) ===== */
// Top trades now stored in MySQL via /api-trades.php
// No initialization needed - API handles database connection

/* ===== Config ===== */
const TF = [
  {key:'30d', label:'30 DAYS',  win:2592000000, bins:30, binSize:86400000},  // 30 bars x 1 day each
  {key:'24h', label:'24 HOURS', win:86400000, bins:12, binSize:7200000},  // 12 bars x 2hr each
  {key:'12h', label:'12 HOURS', win:43200000, bins:12, binSize:3600000},  // 12 bars x 1hr each
  {key:'8h',  label:'8 HOURS',  win:28800000, bins:12, binSize:2400000},  // 12 bars x 40min each
  {key:'1h',  label:'1 HOUR',   win:3600000,  bins:12, binSize:300000},
  {key:'10m', label:'10 MIN',   win:600000,   bins:10, binSize:60000},
  {key:'5m',  label:'5 MIN',    win:300000,   bins:10, binSize:30000},    // 10 bars x 30sec each
  {key:'1m',  label:'1 MIN',    win:60000,    bins:12, binSize:5000}      // 12 bars x 5sec each
];

/* ===== Elements ===== */
const priceEl = document.getElementById('livePrice');
const connPill = document.getElementById('connPill');
const d24Change = document.getElementById('d24Change');
const goldPrice = document.getElementById('goldPrice');
const oilPrice = document.getElementById('oilPrice');
const ethPrice = document.getElementById('ethPrice');
const xrpPrice = document.getElementById('xrpPrice');
const adaPrice = document.getElementById('adaPrice');
const liveClock = document.getElementById('bigClock');
const weatherNow = document.getElementById('weatherNow');
const weatherToday = document.getElementById('weatherToday');
const weatherTomorrow = document.getElementById('weatherTomorrow');

/* ===== Formatters ===== */
const fmtUSD = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
const fmtUSD0 = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
const fmtUSDChange = new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2,signDisplay:'always'});
const fmtBTC = new Intl.NumberFormat(undefined,{maximumFractionDigits:2});
const pct1 = new Intl.NumberFormat(undefined,{maximumFractionDigits:1});

/* ===== State ===== */
let lastPrice = null;
let win30d = [], win24h = [], win12h = [], win8h = [], win1h = [], win10m = [], win5m = [], win1m = [];
let win30dVol = [], win24hVol = [], win12hVol = [], win8hVol = [], win1hVol = [], win10mVol = [], win5mVol = [], win1mVol = [];
let win30dLive = [], win24hLive = [], win12hLive = [], win8hLive = [], win1hLive = [], win10mLive = [], win5mLive = [], win1mLive = [];
let last30dSample = 0, last24hSample = 0, last12hSample = 0, last8hSample = 0, last1hSample = 0, last10mSample = 0, last5mSample = 0, last1mSample = 0;
let recentTrades = []; // Live ticker trades (keep last 100)
let lastTradeTime = 0; // Track last trade for health monitoring
let lastNewsUpdate = 0; // Track last successful news update
let newsUpdateCount = 0; // Count successful news updates
let oilPriceFetched = false; // Track if we've fetched oil at least once
const SAMPLE_INTERVALS = {
  '30d': 3600000,  // 1 hour
  '24h': 300000,   // 5 minutes
  '12h': 120000,   // 2 minutes
  '8h': 120000,    // 2 minutes
  '1h': 60000,     // 1 minute
  '10m': 500,      // 0.5 seconds
  '5m': 300,       // 0.3 seconds
  '1m': 100        // 0.1 seconds
};

/* ===== Build DOM ===== */
const dash = document.getElementById('dashboard');
dash.innerHTML = TF.map(t => `
<div class="col" id="col-${t.key}">
  <div class="colHeader">
    <div class="tfLabel">${t.label}</div>
    <div class="statPills" id="pills-${t.key}">
      <span class="statPill" id="vol-${t.key}">Vol ‚Äî</span>
      <span class="statPill" id="hl-${t.key}">H/L ‚Äî</span>
    </div>
  </div>
  <div class="chartBox"><canvas id="chart-${t.key}"></canvas></div>
  ${(t.key==='1h' || t.key==='10m' || t.key==='5m' || t.key==='1m') ? `<div class="gaugeRow">
    <span class="gLabel buy">Buys</span>
    <div class="gaugeWrap">
      <canvas id="biasGauge-${t.key}"></canvas>
      <div id="needle-${t.key}" class="needle" style="left:50%"></div>
      <div id="needleValue-${t.key}" class="needleValue" style="left:50%">0%</div>
    </div>
    <span class="gLabel sell">Sells</span>
  </div>
  <div class="metricPills" id="metrics-${t.key}">
    <span class="metricPill" id="tpm-${t.key}">T/m ‚Äî</span>
    <span class="metricPill" id="avg-${t.key}">Avg ‚Äî</span>
    <span class="metricPill" id="med-${t.key}">Med ‚Äî</span>
    <span class="metricPill" id="vwap-${t.key}">VWAP ‚Äî</span>
  </div>` : ''}
  <div class="volBox"><canvas id="volChart-${t.key}"></canvas></div>
  <div class="topTrades">
    <div class="topHeader">Top Trades</div>
    <div class="topGrid">
      <div class="topCol buyCol">
        <h4>Buys</h4>
        <ul class="topList" id="topBuys-${t.key}"></ul>
      </div>
      <div class="topCol sellCol">
        <h4>Sells</h4>
        <ul class="topList" id="topSells-${t.key}"></ul>
      </div>
    </div>
  </div>
</div>
`).join('');

// Add Live News card
dash.innerHTML += `
<div class="col" id="col-news" style="display:none">
  <div class="colHeader">
    <div class="tfLabel">üì∞ LIVE NEWS</div>
    <div class="statPills">
      <span class="statPill" id="newsUpdateTime">Loading...</span>
    </div>
  </div>
  <div id="newsListContainer" style="background:var(--panel-2);border-radius:10px;padding:12px;height:800px;overflow:hidden">
    <div id="newsList"></div>
  </div>
</div>
`;

// Add Live Ticker card
dash.innerHTML += `
<div class="col" id="col-ticker" style="display:none">
  <div class="colHeader">
    <div class="tfLabel">üìä LIVE TICKER</div>
    <div class="statPills">
      <span class="statPill" id="tickerCount">0 trades</span>
    </div>
  </div>
  <div id="tickerContainer" style="background:var(--panel-2);border-radius:10px;padding:12px;height:800px;overflow-y:auto;overflow-x:hidden">
    <div id="tickerList"></div>
  </div>
</div>
`;

/* ===== Canvas helpers ===== */
function sizeCanvas(c){
  if(!c || !c.getContext) {
    console.warn('sizeCanvas: invalid canvas element', c);
    return null;
  }
  const dpr = Math.max(1, Math.min(devicePixelRatio||1, 3));
  c.width = Math.max(1, c.clientWidth*dpr);
  c.height = Math.max(1, c.clientHeight*dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}

/* ===== Stats calculation ===== */
function median(arr){
  const a=[...arr].sort((x,y)=>x-y);
  const n=a.length;
  return n?(n&1?a[(n-1)/2]:(a[n/2-1]+a[n/2])/2):NaN;
}

function calcStats(arr, windowMs){
  if(arr.length===0) return null;
  const prices = arr.map(t=>t.price);
  const hi = Math.max(...prices);
  const lo = Math.min(...prices);
  let buyVol=0, sellVol=0, buyUsd=0, sellUsd=0, totalVol=0;
  for(const t of arr){
    const usd = t.price * t.size;
    totalVol += t.size;
    if(t.side==='buy'){buyVol+=t.size; buyUsd+=usd}
    else{sellVol+=t.size; sellUsd+=usd}
  }
  const totalUsd = buyUsd + sellUsd;
  const buyRatio = totalUsd ? (buyUsd/totalUsd)*100 : 50;

  // VWAP (Volume Weighted Average Price)
  const vwap = totalVol > 0 ? totalUsd / totalVol : 0;

  // Trades per minute
  const minutes = windowMs / 60000;
  const tradesPerMin = minutes > 0 ? arr.length / minutes : 0;

  return {
    first: prices[0],
    last: prices[prices.length-1],
    hi, lo,
    buyVol, sellVol,
    buyRatio,
    count: arr.length,
    vwap,
    tradesPerMin
  };
}

// Calculate avg/median from LIVE trades only (not historical candles)
function calcLiveTradeStats(liveArr){
  if(liveArr.length === 0) return null;

  const usdTrades = [];
  for(const t of liveArr){
    const usd = t.price * t.size;
    usdTrades.push(usd);
  }

  // Avg trade size (USD)
  const totalUsd = usdTrades.reduce((sum, val) => sum + val, 0);
  const avgTradeUsd = usdTrades.length > 0 ? totalUsd / usdTrades.length : 0;

  // Median trade size (USD)
  usdTrades.sort((a,b)=>a-b);
  const medTradeUsd = usdTrades.length > 0 ? usdTrades[Math.floor(usdTrades.length/2)] : 0;

  return { avgTradeUsd, medTradeUsd };
}

/* ===== Trade ingestion ===== */
function onTrade(t){
  const p = t.price;
  const s = t.size;
  const side = t.side==='sell' ? 'sell' : 'buy';
  const time = t.time.getTime();

  // Track last trade time for health monitoring
  lastTradeTime = Date.now();

  // Update price display (always)
  if(lastPrice !== null){
    priceEl.classList.remove('up','down');
    if(p>lastPrice) priceEl.classList.add('up');
    else if(p<lastPrice) priceEl.classList.add('down');
  }
  lastPrice = p;
  priceEl.textContent = fmtUSD.format(p);

  // Sample at different rates for price charts
  const now = Date.now();
  const trade = {price:p, size:s, side, time};
  const lastSamples = {
    '30d': last30dSample, '24h': last24hSample, '12h': last12hSample, '8h': last8hSample,
    '1h': last1hSample, '10m': last10mSample, '5m': last5mSample, '1m': last1mSample
  };

  if(now - last30dSample >= SAMPLE_INTERVALS['30d']){ win30d.push(trade); last30dSample = now; }
  if(now - last24hSample >= SAMPLE_INTERVALS['24h']){ win24h.push(trade); last24hSample = now; }
  if(now - last12hSample >= SAMPLE_INTERVALS['12h']){ win12h.push(trade); last12hSample = now; }
  if(now - last8hSample >= SAMPLE_INTERVALS['8h']){ win8h.push(trade); last8hSample = now; }
  if(now - last1hSample >= SAMPLE_INTERVALS['1h']){ win1h.push(trade); last1hSample = now; }
  if(now - last10mSample >= SAMPLE_INTERVALS['10m']){ win10m.push(trade); last10mSample = now; }
  if(now - last5mSample >= SAMPLE_INTERVALS['5m']){ win5m.push(trade); last5mSample = now; }
  if(now - last1mSample >= SAMPLE_INTERVALS['1m']){ win1m.push(trade); last1mSample = now; }

  // Add ALL trades to volume windows (no sampling)
  win30dVol.push(trade);
  win24hVol.push(trade);
  win12hVol.push(trade);
  win8hVol.push(trade);
  win1hVol.push(trade);
  win10mVol.push(trade);
  win5mVol.push(trade);
  win1mVol.push(trade);

  // Add to LIVE trade arrays (for avg/median calculation)
  win30dLive.push(trade);
  win24hLive.push(trade);
  win12hLive.push(trade);
  win8hLive.push(trade);
  win1hLive.push(trade);
  win10mLive.push(trade);
  win5mLive.push(trade);
  win1mLive.push(trade);

  // Add to live ticker (keep last 100 trades)
  recentTrades.unshift(trade);
  if(recentTrades.length > 100) recentTrades.pop();
  updateTicker();

  prune();
  updateAll();
}

function prune(){
  const now = Date.now();

  // Safety check: log if we're about to clear arrays
  const before5m = win5m.length;

  win30d = win30d.filter(t => t.time >= now - 2592000000);
  win24h = win24h.filter(t => t.time >= now - 86400000);
  win12h = win12h.filter(t => t.time >= now - 43200000);
  win8h = win8h.filter(t => t.time >= now - 28800000);
  win1h = win1h.filter(t => t.time >= now - 3600000);
  win10m = win10m.filter(t => t.time >= now - 600000);
  win5m = win5m.filter(t => t.time >= now - 300000);
  win1m = win1m.filter(t => t.time >= now - 60000);

  // Alert if 5m data was completely cleared
  if(before5m > 0 && win5m.length === 0){
    console.error(`‚ö†Ô∏è 5m array cleared! Before: ${before5m}, After: 0. Current time: ${now}, Cutoff: ${now - 300000}`);
  }

  win30dVol = win30dVol.filter(t => t.time >= now - 2592000000);
  win24hVol = win24hVol.filter(t => t.time >= now - 86400000);
  win12hVol = win12hVol.filter(t => t.time >= now - 43200000);
  win8hVol = win8hVol.filter(t => t.time >= now - 28800000);
  win1hVol = win1hVol.filter(t => t.time >= now - 3600000);
  win10mVol = win10mVol.filter(t => t.time >= now - 600000);
  win5mVol = win5mVol.filter(t => t.time >= now - 300000);
  win1mVol = win1mVol.filter(t => t.time >= now - 60000);

  // Prune Live arrays by their respective time windows
  win30dLive = win30dLive.filter(t => t.time >= now - 2592000000);
  win24hLive = win24hLive.filter(t => t.time >= now - 86400000);
  win12hLive = win12hLive.filter(t => t.time >= now - 43200000);
  win8hLive = win8hLive.filter(t => t.time >= now - 28800000);
  win1hLive = win1hLive.filter(t => t.time >= now - 3600000);
  win10mLive = win10mLive.filter(t => t.time >= now - 600000);
  win5mLive = win5mLive.filter(t => t.time >= now - 300000);
  win1mLive = win1mLive.filter(t => t.time >= now - 60000);
}

/* ===== Update stats & charts ===== */
function updateAll(){
  const winMap = { '30d': win30d, '24h': win24h, '12h': win12h, '8h': win8h, '1h': win1h, '10m': win10m, '5m': win5m, '1m': win1m };
  const volMap = { '30d': win30dVol, '24h': win24hVol, '12h': win12hVol, '8h': win8hVol, '1h': win1hVol, '10m': win10mVol, '5m': win5mVol, '1m': win1mVol };
  const liveMap = { '30d': win30dLive, '24h': win24hLive, '12h': win12hLive, '8h': win8hLive, '1h': win1hLive, '10m': win10mLive, '5m': win5mLive, '1m': win1mLive };

  TF.forEach(tf => {
    const arr = winMap[tf.key];
    const volArr = volMap[tf.key];
    const liveArr = liveMap[tf.key];

    const stats = calcStats(volArr, tf.win); // Use volume array for stats, pass window size
    const liveStats = calcLiveTradeStats(liveArr); // Calculate avg/median from live trades only

    if(stats){
      document.getElementById(`vol-${tf.key}`).textContent = `Vol ‚Çø${fmtBTC.format(stats.buyVol + stats.sellVol)}`;
      document.getElementById(`hl-${tf.key}`).textContent = `H/L ${fmtUSD0.format(stats.hi)} / ${fmtUSD0.format(stats.lo)}`;

      // Update metric pills (for 1h, 10m, 5m, 1m)
      if(tf.key === '1h' || tf.key === '10m' || tf.key === '5m' || tf.key === '1m'){
        document.getElementById(`tpm-${tf.key}`).textContent = `Trades/m ${stats.tradesPerMin.toFixed(1)}`;
        document.getElementById(`vwap-${tf.key}`).textContent = `VWAP ${fmtUSD0.format(stats.vwap)}`;

        // Show avg/median from live trades only
        if(liveStats && liveArr.length > 0){
          document.getElementById(`avg-${tf.key}`).textContent = `Avg ${fmtUSD0.format(liveStats.avgTradeUsd)}`;
          document.getElementById(`med-${tf.key}`).textContent = `Med ${fmtUSD0.format(liveStats.medTradeUsd)}`;
        } else {
          document.getElementById(`avg-${tf.key}`).textContent = `Avg ‚Äî`;
          document.getElementById(`med-${tf.key}`).textContent = `Med ‚Äî`;
        }
      }
    }

    drawChart(tf.key, arr); // Use sampled array for price chart
    const spikeDetected = drawVolume(tf.key, volArr, tf); // Use full volume array for volume chart

    // Flash volume box if spike detected (for short timeframes and if alerts enabled)
    if((tf.key === '10m' || tf.key === '5m' || tf.key === '1m') && spikeDetected && settings.alerts.volSpike){
      const volBox = document.querySelector(`#col-${tf.key} .volBox`);
      if(volBox){
        volBox.classList.remove('spikeAlert');
        void volBox.offsetWidth; // Force reflow to restart animation
        volBox.classList.add('spikeAlert');
      }
    }

    // Draw gauge for 1h, 10m, 5m, 1m (where live data is accurate)
    if(stats && (tf.key === '1h' || tf.key === '10m' || tf.key === '5m' || tf.key === '1m')){
      drawGauge(tf.key, stats.buyVol, stats.sellVol);
    }

    // Update top trades list
    updateTopTrades(tf.key, liveArr);
  });
}

/* ===== Track previous top trades to detect new entries ===== */
const prevTopTrades = {
  '30d': {buys: [], sells: []},
  '24h': {buys: [], sells: []},
  '12h': {buys: [], sells: []},
  '8h': {buys: [], sells: []},
  '1h': {buys: [], sells: []},
  '10m': {buys: [], sells: []},
  '5m': {buys: [], sells: []},
  '1m': {buys: [], sells: []}
};

/* ===== Helper: Compare two arrays for equality ===== */
function arraysEqual(a, b){
  if(a.length !== b.length) return false;
  for(let i = 0; i < a.length; i++){
    if(a[i] !== b[i]) return false;
  }
  return true;
}

/* ===== Update top trades ===== */
function updateTopTrades(key, liveArr){
  if(!liveArr || liveArr.length === 0) return;

  // Debug: show raw liveArr length
  if(key === '30d'){
    // console.log(`üîç 30d liveArr has ${liveArr.length} total trades (before filtering by side)`);
  }

  // Separate buys and sells, calculate USD value
  const buys = liveArr.filter(t => t.side === 'buy').map(t => ({
    ...t,
    usd: t.price * t.size
  }));
  const sells = liveArr.filter(t => t.side === 'sell').map(t => ({
    ...t,
    usd: t.price * t.size
  }));

  // Sort by USD value, show more for longer timeframes
  buys.sort((a,b) => b.usd - a.usd);
  sells.sort((a,b) => b.usd - a.usd);
  const limit = (key === '30d' || key === '24h' || key === '12h' || key === '8h') ? 13 : 10;
  const top10Buys = buys.slice(0, limit);
  const top10Sells = sells.slice(0, limit);

  // Debug logging for 30d
  if(key === '30d'){
    // console.log(`üìä 30d updateTopTrades: ${buys.length} total buys, ${sells.length} total sells`);
    // console.log(`   Top 13 buys:`, top10Buys.map(t => `${t.size.toFixed(2)} BTC`).join(', '));
    // console.log(`   Top 13 sells:`, top10Sells.map(t => `${t.size.toFixed(2)} BTC`).join(', '));
  }

  // Check for new entries by comparing timestamps
  const prevBuys = prevTopTrades[key].buys;
  const prevSells = prevTopTrades[key].sells;
  const newBuyTimes = new Set(top10Buys.map(t => t.time));
  const newSellTimes = new Set(top10Sells.map(t => t.time));
  const prevBuyTimes = new Set(prevBuys);
  const prevSellTimes = new Set(prevSells);

  // Format time helper - smart format based on timeframe
  const formatTime = (ms) => {
    const d = new Date(ms);
    if(key === '30d'){
      // For 30-day chart, show compact date: "Jan 29"
      return d.toLocaleDateString('en-US', {month:'short', day:'numeric'});
    } else {
      // For shorter timeframes, show time: "2:30pm"
      return d.toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', hour12:true}).toLowerCase();
    }
  };

  // Check if alerts are enabled (no delay needed with Firebase persistence)
  const enableBlink = settings.alerts.tradeBlink;

  // Update buy list
  const buyList = document.getElementById(`topBuys-${key}`);
  if(buyList){
    buyList.innerHTML = top10Buys.length > 0
      ? top10Buys.map(t => {
          const isNew = enableBlink && !prevBuyTimes.has(t.time) && prevBuys.length > 0;
          // Calculate blink duration: 10 seconds per BTC, minimum 5 seconds
          const blinkDuration = Math.max(5, Math.round(t.size * 10));
          const styleAttr = isNew ? ` style="--blink-duration: ${blinkDuration}s"` : '';
          return `
        <li class="topItem buy${isNew ? ' newTrade' : ''}"${styleAttr}>
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`;
        }).join('')
      : '<li class="topItem" style="opacity:.5">No buys yet</li>';
  }

  // Update sell list
  const sellList = document.getElementById(`topSells-${key}`);
  if(sellList){
    sellList.innerHTML = top10Sells.length > 0
      ? top10Sells.map(t => {
          const isNew = enableBlink && !prevSellTimes.has(t.time) && prevSells.length > 0;
          // Calculate blink duration: 10 seconds per BTC, minimum 5 seconds
          const blinkDuration = Math.max(5, Math.round(t.size * 10));
          const styleAttr = isNew ? ` style="--blink-duration: ${blinkDuration}s"` : '';
          return `
        <li class="topItem sell${isNew ? ' newTrade' : ''}"${styleAttr}>
          <span class="usd">${fmtUSD0.format(t.usd)}</span>
          <span class="btc">(${fmtBTC.format(t.size)} BTC)</span>
          <span class="t">${formatTime(t.time)}</span>
        </li>`;
        }).join('')
      : '<li class="topItem" style="opacity:.5">No sells yet</li>';
  }

  // Check if top trades list has actually changed
  const buysChanged = !arraysEqual(prevTopTrades[key].buys, top10Buys.map(t => t.time));
  const sellsChanged = !arraysEqual(prevTopTrades[key].sells, top10Sells.map(t => t.time));

  // Store current top trade times for next comparison
  prevTopTrades[key].buys = top10Buys.map(t => t.time);
  prevTopTrades[key].sells = top10Sells.map(t => t.time);

  // Save top trades to MySQL ONLY if the list changed (async, non-blocking)
  // Only persist 1h and longer timeframes (skip 10m, 5m, 1m - too volatile/resource intensive)
  // Don't save if we're currently loading from MySQL (prevents infinite loop)
  if((key === '30d' || key === '24h' || key === '12h' || key === '8h' || key === '1h')){
    if(isLoadingFromMySQL){
      // if(key === '30d') console.log(`üîí ${key}: Save blocked - still loading from MySQL`);
    } else if(!buysChanged && !sellsChanged){
      // if(key === '30d') console.log(`‚è≠Ô∏è ${key}: No changes, skipping save`);
    } else {
      console.log(`üíæ Saving ${key}: ${top10Buys.length} buys, ${top10Sells.length} sells to MySQL`);
      saveTopTradesToMySQL(key, top10Buys, top10Sells);
    }
  }
}

/* ===== MySQL: Save top trades ===== */
async function saveTopTradesToMySQL(key, buys, sells){
  try{
    // Save top buys and sells for longer timeframes only
    const data = {
      timeframe: key,
      buys: buys.map(t => ({
        price: t.price,
        size: t.size,
        usd: t.usd,
        time: t.time
      })),
      sells: sells.map(t => ({
        price: t.price,
        size: t.size,
        usd: t.usd,
        time: t.time
      }))
    };

    const response = await fetch('/api-trades.php?action=save', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(data)
    });

    if(!response.ok){
      console.error(`Failed to save ${key} trades:`, response.statusText);
    }
  }catch(e){
    console.error('Failed to save to MySQL:', e);
  }
}

/* ===== Update Live Ticker ===== */
function updateTicker(){
  if(!settings.charts.ticker) return; // Only update if ticker is enabled

  const tickerList = document.getElementById('tickerList');
  const tickerCount = document.getElementById('tickerCount');
  if(!tickerList || !tickerCount) return;

  tickerCount.textContent = `${recentTrades.length} trades`;

  if(recentTrades.length === 0){
    tickerList.innerHTML = '<div style="color:var(--muted);padding:20px;text-align:center">Waiting for trades...</div>';
    return;
  }

  tickerList.innerHTML = recentTrades.map(t => {
    const usd = t.price * t.size;
    const timeStr = new Date(t.time).toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false});
    const sideColor = t.side === 'buy' ? 'var(--up)' : 'var(--down)';
    const sideLabel = t.side === 'buy' ? 'BUY' : 'SELL';

    return `
      <div style="border-bottom:1px solid rgba(255,255,255,.05);padding:8px 4px;display:flex;gap:10px;align-items:center;font-size:13px">
        <span style="color:${sideColor};font-weight:800;width:45px">${sideLabel}</span>
        <span style="flex:1;font-weight:700">${fmtUSD.format(t.price)}</span>
        <span style="color:var(--muted);width:80px;text-align:right">${t.size.toFixed(4)} BTC</span>
        <span style="color:var(--muted);width:70px;text-align:right">${fmtUSD0.format(usd)}</span>
        <span style="color:var(--muted);width:70px;text-align:right;font-size:11px">${timeStr}</span>
      </div>
    `;
  }).join('');
}

/* ===== MySQL: Load top trades on startup ===== */
async function loadTopTradesFromMySQL(){
  try{
    isLoadingFromMySQL = true; // Prevent saving during initial load

    const response = await fetch('/api-trades.php?action=load');
    if(!response.ok){
      throw new Error('Failed to load trades');
    }

    const result = await response.json();
    if(!result.success || !result.data) {
      isLoadingFromMySQL = false;
      return;
    }

    // Merge MySQL data with live trade windows
    mergeMySQLTradesWithLive(result.data);

    console.log('‚úÖ Loaded top trades from MySQL');
    // Don't call updateAll() here - let normal flow handle it after historical data loads

    // Keep flag true until after first updateAll() runs (after historical data loads)
    // Will be set to false after historical candles finish loading
  }catch(e){
    console.error('Failed to load from MySQL:', e);
    isLoadingFromMySQL = false;
  }
}

/* ===== MySQL: State management ===== */
let isLoadingFromMySQL = false; // Prevent infinite update loops

function setupFirebaseListeners(){
  // Listen for changes to top trades in real-time
  db.ref('topTrades').on('value', (snapshot) => {
    const data = snapshot.val();
    if(!data) return;

    // Set flag to prevent save loop
    isLoadingFromMySQL = true;

    // Merge updated trades from Firebase
    mergeFirebaseTradesWithLive(data);

    // Update the display (but don't save back to Firebase)
    updateAll();

    // Clear flag after a short delay
    setTimeout(() => { isLoadingFromMySQL = false; }, 100);
  });

  console.log('‚úÖ Firebase real-time sync enabled');
}

/* ===== Helper: Merge MySQL trades with live data ===== */
function mergeMySQLTradesWithLive(data){
  const liveMap = {
    '30d': win30dLive, '24h': win24hLive, '12h': win12hLive, '8h': win8hLive,
    '1h': win1hLive, '10m': win10mLive, '5m': win5mLive, '1m': win1mLive
  };

  TF.forEach(tf => {
    const key = tf.key;
    if(data[key]){
      const fbBuys = data[key].buys || [];
      const fbSells = data[key].sells || [];
      const liveArr = liveMap[key];

      console.log(`üì• Loading ${key}: ${fbBuys.length} buys, ${fbSells.length} sells from MySQL`);

      // Replace liveArr contents with MySQL data (don't merge - replace entirely)
      // This ensures we get exactly what's in MySQL without duplicates
      liveArr.length = 0; // Clear array

      // Add all Firebase buys
      fbBuys.forEach(t => {
        liveArr.push({
          price: t.price,
          size: t.size,
          side: 'buy',
          time: t.time
        });
      });

      // Add all Firebase sells
      fbSells.forEach(t => {
        liveArr.push({
          price: t.price,
          size: t.size,
          side: 'sell',
          time: t.time,
          usd: t.usd || (t.price * t.size) // Ensure USD is calculated
        });
      });

      // Debug: Show the actual trades being loaded
      if(key === '30d' || key === '24h'){
        // console.log(`   Sells loaded:`, fbSells.map(t => `${(t.size || 0).toFixed(2)} BTC`).join(', '));
      }
    }
  });
}

/* ===== Chart drawing (simple line) ===== */
function drawChart(key, arr){
  const canvas = document.getElementById(`chart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length < 2) return;

  const prices = arr.map(t => t.price);
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const range = (max - min) || 1;
  const avg = prices.reduce((a,b)=>a+b,0) / prices.length;

  const padX = 10, padY = 16;

  // Average line
  const yAvg = padY + (h - 2*padY) * (1 - (avg - min)/range);
  ctx.setLineDash([4,4]);
  ctx.strokeStyle = 'rgba(200,214,207,.4)';
  ctx.beginPath();
  ctx.moveTo(padX, yAvg);
  ctx.lineTo(w-padX, yAvg);
  ctx.stroke();
  ctx.setLineDash([]);

  // Line (colored based on price vs average)
  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Draw line segments, changing color based on whether price is above/below average
  for(let i = 1; i < arr.length; i++){
    const t0 = arr[i-1];
    const t1 = arr[i];
    const x0 = padX + ((i-1)/(arr.length-1)) * (w - 2*padX);
    const y0 = padY + (h - 2*padY) * (1 - (t0.price - min)/range);
    const x1 = padX + (i/(arr.length-1)) * (w - 2*padX);
    const y1 = padY + (h - 2*padY) * (1 - (t1.price - min)/range);

    // Color based on current price vs average
    ctx.strokeStyle = t1.price >= avg ? up : dn;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  // Labels
  ctx.fillStyle = 'rgba(255,255,255,.85)';
  ctx.font = '11px system-ui';
  ctx.textBaseline = 'top';
  ctx.fillText(fmtUSD0.format(max), padX, padY);
  ctx.textBaseline = 'bottom';
  ctx.fillText(fmtUSD0.format(min), padX, h-padY);
}

/* ===== Volume bars ===== */
function drawVolume(key, arr, tf){
  const canvas = document.getElementById(`volChart-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-2').trim();
  ctx.fillRect(0,0,w,h);

  if(arr.length === 0) return;

  // Create bins locked to absolute time boundaries
  const now = Date.now();
  let bins, currentBinIdx;

  // For short timeframes (10m, 5m, 1m), lock to their bin boundaries
  if(key === '10m' || key === '5m' || key === '1m'){
    const currentBoundary = Math.floor(now / tf.binSize) * tf.binSize;
    const start = currentBoundary - tf.win + tf.binSize;

    bins = Array.from({length: tf.bins}, (_,i) => ({
      ts: start + i*tf.binSize,
      buy: 0,
      sell: 0
    }));

    arr.forEach(t => {
      const binStart = Math.floor(t.time / tf.binSize) * tf.binSize;
      const idx = Math.floor((binStart - start) / tf.binSize);

      // Count all trades including current bin (allow first bar to grow live)
      if(idx >= 0 && idx < tf.bins){
        if(t.side==='buy') bins[idx].buy += t.size;
        else bins[idx].sell += t.size;
      }
    });

    currentBinIdx = tf.bins - 1; // Current bin is the last one
  } else {
    // Other timeframes use sliding window
    const start = now - tf.win;
    bins = Array.from({length: tf.bins}, (_,i) => ({
      ts: start + i*tf.binSize,
      buy: 0,
      sell: 0
    }));

    currentBinIdx = Math.floor((now - start) / tf.binSize);

    arr.forEach(t => {
      const idx = Math.min(tf.bins-1, Math.max(0, Math.floor((t.time - start) / tf.binSize)));

      // Skip current incomplete bin
      if(idx === currentBinIdx) return;

      if(t.side==='buy') bins[idx].buy += t.size;
      else bins[idx].sell += t.size;
    });
  }

  const sums = bins.map(b => b.buy + b.sell);
  const max = Math.max(1, ...sums);

  // Calculate average volume and check for spikes
  let isSpike = false;
  if(key === '10m' || key === '5m' || key === '1m'){
    // For locked timeframes, check second-to-last bar (most recently completed)
    const completedSums = sums.slice(0, -1).filter(s => s > 0); // Exclude last (current) bar
    if(completedSums.length > 1){
      const avgVol = completedSums.reduce((a,b) => a+b, 0) / completedSums.length;
      const mostRecentVol = sums[sums.length - 2]; // Second-to-last bar is most recently completed
      isSpike = mostRecentVol > 0 && mostRecentVol >= (avgVol * 1.5);
    }
  } else {
    // For sliding windows, exclude current incomplete bin
    const completedSums = sums.slice(0, currentBinIdx).filter(s => s > 0);
    const avgVol = completedSums.length > 0 ? completedSums.reduce((a,b) => a+b, 0) / completedSums.length : 0;
    const mostRecentIdx = currentBinIdx > 0 ? currentBinIdx - 1 : -1;
    const mostRecentVol = mostRecentIdx >= 0 ? sums[mostRecentIdx] : 0;
    isSpike = avgVol > 0 && mostRecentVol >= (avgVol * 1.5);
  }

  const padX = 8, padY = 8;
  const chartH = h - 2*padY;
  const barW = (w - 2*padX) / bins.length * 0.7;
  const step = (w - 2*padX) / bins.length;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  bins.forEach((b, i) => {
    const x = padX + i*step + step/2;
    const tot = b.buy + b.sell;
    const hT = Math.max(4, (tot/max) * chartH);
    const hBuy = tot ? (b.buy/tot) * hT : 0;
    const hSell = hT - hBuy;
    const yB = h - padY;

    ctx.fillStyle = dn;
    ctx.fillRect(x - barW/2, yB - hSell, barW, hSell);
    ctx.fillStyle = up;
    ctx.fillRect(x - barW/2, yB - hSell - hBuy, barW, hBuy);

    // Add volume label pills on top of bars (with max height cap)
    if(tot > 0.01){
      const label = tot >= 1 ? `‚Çø${tot.toFixed(1)}` : `‚Çø${tot.toFixed(2)}`;

      // Draw pill background on top of bar (capped at 80% of chart height)
      ctx.font = '9px system-ui';
      const metrics = ctx.measureText(label);
      const pillW = metrics.width + 8;
      const pillH = 14;
      const pillX = x - pillW/2;
      const maxY = padY + chartH * 0.15; // Don't go higher than 15% from top
      const pillY = Math.max(maxY, yB - hT - pillH - 2);

      ctx.fillStyle = 'rgba(0,0,0,.85)';
      ctx.beginPath();
      ctx.moveTo(pillX + 7, pillY);
      ctx.arcTo(pillX + pillW, pillY, pillX + pillW, pillY + pillH, 7);
      ctx.arcTo(pillX + pillW, pillY + pillH, pillX, pillY + pillH, 7);
      ctx.arcTo(pillX, pillY + pillH, pillX, pillY, 7);
      ctx.arcTo(pillX, pillY, pillX + pillW, pillY, 7);
      ctx.fill();

      // Draw label text
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, pillY + pillH/2);
    }

    // Add +/- DIFF pill inside bar (actual BTC difference, like mobile.html)
    if(hT > 26 && tot > 0.0001){
      const diff = b.buy - b.sell; // Actual BTC difference
      if(Math.abs(diff) > 0.0001){
        const diffLabel = `${diff>=0?'+':''}${diff.toFixed(2)}`;

        ctx.font = '10px system-ui';
        const diffMetrics = ctx.measureText(diffLabel);
        const diffPillW = diffMetrics.width + 10;
        const diffPillH = 16;
        const diffPillX = x - diffPillW/2;
        const diffPillY = yB - hT/2 - diffPillH/2; // Center of bar

        // Draw pill background (dark with border)
        ctx.fillStyle = 'rgba(0,0,0,.85)';
        ctx.strokeStyle = 'rgba(255,255,255,.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(diffPillX + 7, diffPillY);
        ctx.arcTo(diffPillX + diffPillW, diffPillY, diffPillX + diffPillW, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX + diffPillW, diffPillY + diffPillH, diffPillX, diffPillY + diffPillH, 7);
        ctx.arcTo(diffPillX, diffPillY + diffPillH, diffPillX, diffPillY, 7);
        ctx.arcTo(diffPillX, diffPillY, diffPillX + diffPillW, diffPillY, 7);
        ctx.fill();
        ctx.stroke();

        // Draw diff text (colored: teal for +, orange for -)
        ctx.fillStyle = diff >= 0 ? up : dn;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(diffLabel, x, diffPillY + diffPillH/2);
      }
    }
  });

  // Return spike detection result
  return isSpike;
}

/* ===== Gauge ===== */
const needlePos = {};
function drawGauge(key, buyVol, sellVol){
  const canvas = document.getElementById(`biasGauge-${key}`);
  if(!canvas) return;
  const ctx = sizeCanvas(canvas);
  if(!ctx) return;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);

  const tot = buyVol + sellVol;
  const target = tot ? (buyVol/tot) : 0.5;

  if(!needlePos[key]) needlePos[key] = 0.5;
  needlePos[key] += (target - needlePos[key]) * 0.25;

  const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
  const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

  const g = ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0, up);
  g.addColorStop(Math.max(0, needlePos[key]-0.001), up);
  g.addColorStop(Math.min(1, needlePos[key]+0.001), dn);
  g.addColorStop(1, dn);

  const r = h/2;
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(r,1);
  ctx.arcTo(w-1,1,w-1,h-1,r);
  ctx.arcTo(w-1,h-1,0,h-1,r);
  ctx.arcTo(0,h-1,0,1,r);
  ctx.arcTo(0,1,w-1,1,r);
  ctx.fill();

  const needle = document.getElementById(`needle-${key}`);
  const needleValue = document.getElementById(`needleValue-${key}`);
  if(!needle || !needleValue) return;

  const leftPx = Math.round(canvas.getBoundingClientRect().width * needlePos[key]);
  needle.style.left = leftPx + 'px';
  const biasPct = tot ? ((buyVol - sellVol)/tot)*100 : 0;
  needleValue.textContent = (biasPct>=0?'+':'') + biasPct.toFixed(0) + '%';
  needleValue.style.left = leftPx + 'px';
}

/* ===== WebSocket + fallback ===== */
let ws, recon, lastWs=0, lastRest=0;
function setConn(state, msg){
  connPill.classList.remove('conn-ok','conn-warn','conn-err');
  connPill.classList.add(state==='ok'?'conn-ok':state==='warn'?'conn-warn':'conn-err');
  connPill.textContent = msg;
}

function startWS(){
  clearTimeout(recon);
  try{ws && ws.close()}catch{}
  ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
  setConn('warn','Connecting‚Ä¶');

  ws.onopen = () => {
    ws.send(JSON.stringify({
      type:'subscribe',
      product_ids:['BTC-USD'],
      channels:['matches']
    }));
  };

  ws.onmessage = e => {
    lastWs = Date.now();
    setConn('ok','Live');
    try{
      const m = JSON.parse(e.data);
      if(m.type==='match' && m.product_id==='BTC-USD'){
        onTrade({
          price: +m.price,
          size: +m.size,
          side: String(m.side||'').toLowerCase(),
          time: new Date(m.time)
        });
      }
    }catch{}
  };

  ws.onclose = () => {
    setConn('warn','Reconnecting‚Ä¶');
    recon = setTimeout(startWS, 1000);
  };

  ws.onerror = () => {
    setConn('err','Fallback');
    try{ws.close()}catch{}
  };
}

async function restFallback(){
  const QUIET = 3500;
  const now = Date.now();

  try{
    if(now - lastWs >= QUIET){
      const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/trades?limit=20', {
        headers: {Accept:'application/json'}
      });
      if(r.ok){
        const arr = await r.json();
        for(let i=arr.length-1; i>=0; i--){
          const t = arr[i];
          onTrade({
            price: +t.price,
            size: +t.size,
            side: String(t.side||'').toLowerCase(),
            time: new Date(t.time||now)
          });
        }
        lastRest = now;
        setConn('err','Fallback');
        return;
      }
    }

    if(now - Math.max(lastWs, lastRest) >= QUIET){
      const r2 = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/ticker', {
        headers: {Accept:'application/json'}
      });
      if(r2.ok){
        const t = await r2.json();
        onTrade({
          price: +t.price,
          size: +(t.size||0.001),
          side: 'buy',
          time: new Date(t.time||now)
        });
        lastRest = now;
        setConn('err','Fallback');
      }
    }
  }catch{
    setConn('err','Fallback');
  }
}

/* ===== 24h stats from API ===== */
async function fetch24h(){
  try{
    const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/stats', {
      headers: {Accept:'application/json'}
    });
    if(!r.ok) throw 0;
    const j = await r.json();

    const open = +j.open;
    const last = +j.last;

    if(Number.isFinite(open) && Number.isFinite(last)){
      const diff = last - open;
      const pct = open ? (diff/open*100) : 0;
      d24Change.textContent = `24h Œî ${fmtUSDChange.format(diff)} (${pct1.format(pct)}%)`;

      // Color coding
      if(diff > 0){
        d24Change.style.color = 'var(--up)';
        d24Change.style.borderColor = 'var(--up)';
      } else if(diff < 0){
        d24Change.style.color = 'var(--down)';
        d24Change.style.borderColor = 'var(--down)';
      } else {
        d24Change.style.color = '';
        d24Change.style.borderColor = '';
      }
    }
  }catch(e){
    console.log('24h stats error:', e);
    d24Change.textContent = '24h Œî ‚Äî';
  }
}

/* ===== Resize ===== */
let resizePending = false;
function throttledResize(){
  if(resizePending) return;
  resizePending = true;
  requestAnimationFrame(() => {
    resizePending = false;
    updateAll();
  });
}
new ResizeObserver(throttledResize).observe(document.body);
window.addEventListener('resize', throttledResize);

/* ===== Historical data from API ===== */
const iso = ms => new Date(ms).toISOString();

async function fetchHistoricalCandles(){
  try{
    const end = Date.now();

    // Fetch 30d of 6-hour candles for 30d window
    const start30d = end - 2592000000;
    const url30d = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=21600&start=${encodeURIComponent(iso(start30d))}&end=${encodeURIComponent(iso(end))}`;
    const r30d = await fetch(url30d, {headers: {Accept:'application/json'}});
    if(r30d.ok){
      const candles = await r30d.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win30d.push(buyTrade); win30d.push(sellTrade);
        win30dVol.push(buyTrade); win30dVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '30d candles');
    }

    // Fetch 24h of 5-min candles for 24h, 12h, and 8h windows
    const start24h = end - 86400000;
    const url24h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=300&start=${encodeURIComponent(iso(start24h))}&end=${encodeURIComponent(iso(end))}`;
    const r24h = await fetch(url24h, {headers: {Accept:'application/json'}});
    if(r24h.ok){
      const candles = await r24h.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win24h.push(buyTrade); win24h.push(sellTrade);
        win12h.push(buyTrade); win12h.push(sellTrade);
        win8h.push(buyTrade); win8h.push(sellTrade);
        win24hVol.push(buyTrade); win24hVol.push(sellTrade);
        win12hVol.push(buyTrade); win12hVol.push(sellTrade);
        win8hVol.push(buyTrade); win8hVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '24h candles');
    }

    // Fetch 1h of 1-min candles for 1h, 10m, 5m, and 1m windows
    const start1h = end - 3600000;
    const url1h = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=60&start=${encodeURIComponent(iso(start1h))}&end=${encodeURIComponent(iso(end))}`;
    const r1h = await fetch(url1h, {headers: {Accept:'application/json'}});
    if(r1h.ok){
      const candles = await r1h.json();
      candles.sort((a,b) => a[0] - b[0]);
      candles.forEach(c => {
        const vol = +c[5];
        const buyTrade = {price: +c[4], size: vol * 0.5, side: 'buy', time: c[0] * 1000};
        const sellTrade = {price: +c[4], size: vol * 0.5, side: 'sell', time: c[0] * 1000};
        win1h.push(buyTrade); win1h.push(sellTrade);
        win10m.push(buyTrade); win10m.push(sellTrade);
        win5m.push(buyTrade); win5m.push(sellTrade);
        win1m.push(buyTrade); win1m.push(sellTrade);
        win1hVol.push(buyTrade); win1hVol.push(sellTrade);
        win10mVol.push(buyTrade); win10mVol.push(sellTrade);
        win5mVol.push(buyTrade); win5mVol.push(sellTrade);
        win1mVol.push(buyTrade); win1mVol.push(sellTrade);
      });
      console.log('‚úÖ Loaded', candles.length, '1h candles');
    }

    // Prune and update all charts
    prune();
    updateAll();

    // Now that initial load is complete, allow MySQL saves
    isLoadingFromMySQL = false;
    console.log('üîì Initial load complete, MySQL saves enabled');

  }catch(e){
    console.error('Failed to load historical data:', e);
    isLoadingFromMySQL = false;
  }
}

/* ===== Clock ===== */
function updateClock(){
  const now = new Date();
  liveClock.textContent = now.toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:true});
}

/* ===== Weather ===== */
async function updateWeather(){
  try {
    const zip = settings.weatherZip || '43440';

    // Fetch current weather and 5-day forecast via proxy
    const [currentRes, forecastRes] = await Promise.all([
      fetch(`/api-proxy.php?endpoint=weather&type=current&zip=${zip}`),
      fetch(`/api-proxy.php?endpoint=weather&type=forecast&zip=${zip}`)
    ]);

    const current = await currentRes.json();
    const forecast = await forecastRes.json();

    // Current temp
    const temp = Math.round(current.main.temp);
    const condition = current.weather[0].main;

    // Check if it's currently daytime or nighttime
    const now = Math.floor(Date.now() / 1000); // Current time in Unix timestamp
    const sunrise = current.sys.sunrise;
    const sunset = current.sys.sunset;
    const isDaytime = now >= sunrise && now < sunset;

    // Weather emoji mapping (day/night versions)
    const weatherEmojis = {
      'Clear': isDaytime ? '‚òÄÔ∏è' : 'üåô',
      'Clouds': isDaytime ? '‚òÅÔ∏è' : '‚òÅÔ∏è',
      'Rain': 'üåßÔ∏è',
      'Drizzle': 'üå¶Ô∏è',
      'Thunderstorm': '‚õàÔ∏è',
      'Snow': '‚ùÑÔ∏è',
      'Mist': 'üå´Ô∏è',
      'Fog': 'üå´Ô∏è',
      'Haze': 'üå´Ô∏è'
    };

    const emoji = weatherEmojis[condition] || (isDaytime ? 'üå§Ô∏è' : 'üåô');

    // Today's high/low from forecast (next 8 3-hour periods = 24 hours)
    const todayForecasts = forecast.list.slice(0, 8);
    const todayTemps = todayForecasts.map(f => f.main.temp);
    const todayHigh = Math.round(Math.max(...todayTemps));
    const todayLow = Math.round(Math.min(...todayTemps));

    // Tomorrow's forecast (forecasts 8-16, next 24 hours after today)
    const tomorrowForecasts = forecast.list.slice(8, 16);
    const tomorrowTemps = tomorrowForecasts.map(f => f.main.temp);
    const tomorrowHigh = Math.round(Math.max(...tomorrowTemps));
    const tomorrowLow = Math.round(Math.min(...tomorrowTemps));

    // Get most common weather condition for tomorrow
    const tomorrowConditions = tomorrowForecasts.map(f => f.weather[0].main);
    const tomorrowCondition = tomorrowConditions.sort((a,b) =>
      tomorrowConditions.filter(v => v===a).length - tomorrowConditions.filter(v => v===b).length
    ).pop();

    // Tomorrow's emoji (always use daytime version for forecast)
    const forecastEmojis = {
      'Clear': '‚òÄÔ∏è',
      'Clouds': '‚òÅÔ∏è',
      'Rain': 'üåßÔ∏è',
      'Drizzle': 'üå¶Ô∏è',
      'Thunderstorm': '‚õàÔ∏è',
      'Snow': '‚ùÑÔ∏è',
      'Mist': 'üå´Ô∏è',
      'Fog': 'üå´Ô∏è',
      'Haze': 'üå´Ô∏è'
    };
    const tomorrowEmoji = forecastEmojis[tomorrowCondition] || 'üå§Ô∏è';

    // Update display
    weatherNow.textContent = `${emoji} ${temp}¬∞F`;
    weatherToday.innerHTML = `<span class="label">Today:</span> H ${todayHigh}¬∞ L ${todayLow}¬∞`;
    weatherTomorrow.innerHTML = `<span class="label">Tomorrow:</span> ${tomorrowEmoji} H ${tomorrowHigh}¬∞ L ${tomorrowLow}¬∞`;

  } catch(e) {
    console.error('Weather fetch failed:', e);
    weatherNow.textContent = 'üå§Ô∏è --¬∞F';
    weatherToday.innerHTML = '<span class="label">Today:</span> H -- L --';
    weatherTomorrow.innerHTML = '<span class="label">Tomorrow:</span> -- H -- L --';
  }
}

/* ===== Check if WTI oil markets are open ===== */
function isOilMarketOpen(){
  // WTI trades Sunday 5pm CT - Friday 4pm CT with 1hr break at 4pm daily
  // Convert to UTC: CT is UTC-6 (CST) or UTC-5 (CDT)
  const now = new Date();
  const utcHour = now.getUTCHours();
  const utcDay = now.getUTCDay(); // 0=Sunday, 6=Saturday
  const utcMinutes = now.getUTCMinutes();

  // Estimate CT offset (rough: UTC-6 Nov-Mar, UTC-5 Mar-Nov)
  // For simplicity, use America/Chicago locale to get CT hour
  const ctString = now.toLocaleString('en-US', {timeZone: 'America/Chicago', hour: '2-digit', hour12: false});
  const ctHour = parseInt(ctString);

  // Saturday: Closed all day
  if(utcDay === 6) return false;

  // Sunday: Open from 5pm CT onwards
  if(utcDay === 0){
    return ctHour >= 17; // 5pm or later
  }

  // Monday-Thursday: Open 6pm-5pm next day (with 1hr break 4-5pm)
  if(utcDay >= 1 && utcDay <= 4){
    // Closed during 4-5pm CT break
    if(ctHour === 16) return false; // 4pm hour
    return true; // Open rest of the time
  }

  // Friday: Open until 4pm CT
  if(utcDay === 5){
    return ctHour < 16; // Before 4pm
  }

  return false;
}

/* ===== Fetch Gold and crypto prices ===== */
async function fetchMetalPrices(){
  try{
    // Fetch Gold spot price via proxy
    const rGold = await fetch('/api-proxy.php?endpoint=gold');
    if(rGold.ok){
      const dataGold = await rGold.json();
      if(dataGold && dataGold.price){
        const price = parseFloat(dataGold.price);
        if(price > 0){
          goldPrice.textContent = `Gold $${Math.round(price)}`;
        }
      }
    }

    // Fetch WTI Crude Oil price: always on first load, then only when markets are open
    const oilMarketOpen = isOilMarketOpen();
    const shouldFetchOil = !oilPriceFetched || oilMarketOpen; // First time OR markets open

    if(shouldFetchOil){
      const rOil = await fetch('/api-proxy.php?endpoint=oil');
      if(rOil.ok){
        const dataOil = await rOil.json();
        if(dataOil && dataOil.data && dataOil.data.price){
          const price = parseFloat(dataOil.data.price);
          const change = parseFloat(dataOil.data.change_percent || 0);
          if(price > 0){
            const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
            oilPrice.textContent = `Oil $${price.toFixed(2)} (${changeText})`;

            // Color coding
            if(change > 0){
              oilPrice.style.color = 'var(--up)';
              oilPrice.style.borderColor = 'var(--up)';
            } else if(change < 0){
              oilPrice.style.color = 'var(--down)';
              oilPrice.style.borderColor = 'var(--down)';
            } else {
              oilPrice.style.color = '';
              oilPrice.style.borderColor = '';
            }

            oilPriceFetched = true; // Mark as fetched
            if(!oilMarketOpen){
              console.log('üõ¢Ô∏è Initial oil price loaded (markets closed, showing last close)');
            }
          }
        }
      }
    } else if(!shouldFetchOil && !oilMarketOpen){
      console.log('üõ¢Ô∏è Oil markets closed - skipping API call');
    }

    // Use CoinGecko API for all crypto prices with 24h change
    const cryptos = [
      {id: 'ethereum', el: ethPrice, label: 'ETH', decimals: 0},
      {id: 'ripple', el: xrpPrice, label: 'XRP', decimals: 3},
      {id: 'cardano', el: adaPrice, label: 'ADA', decimals: 3}
    ];

    for(const crypto of cryptos){
      try{
        const r = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${crypto.id}&vs_currencies=usd&include_24hr_change=true`, {
          headers: {Accept: 'application/json'}
        });
        if(r.ok){
          const data = await r.json();
          if(data && data[crypto.id]){
            const price = data[crypto.id].usd;
            const change = data[crypto.id].usd_24h_change || 0;

            if(price > 0){
              const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
              crypto.el.textContent = `${crypto.label} $${price.toFixed(crypto.decimals)} (${changeText})`;

              // Color coding
              if(change > 0){
                crypto.el.style.color = 'var(--up)';
                crypto.el.style.borderColor = 'var(--up)';
              } else if(change < 0){
                crypto.el.style.color = 'var(--down)';
                crypto.el.style.borderColor = 'var(--down)';
              } else {
                crypto.el.style.color = '';
                crypto.el.style.borderColor = '';
              }
            }
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }catch(e){
        console.log(`${crypto.label} fetch error:`, e);
      }
    }
  }catch(e){
    console.log('Price fetch error:', e);
  }
}

/* ===== Fetch Live News Data ===== */
async function fetchNewsData(){
  if(!settings.charts.news) return; // Skip if not enabled

  try{
    console.log('üì∞ Fetching live news...');

    // RSS feeds to fetch
    const feeds = [
      { url: 'https://www.trumpstruth.org/feed', name: 'Trump Truth', color: '#E91E3A' },
      { url: 'https://moxie.foxnews.com/google-publisher/us.xml', name: 'Fox News', color: '#003366' },
      { url: 'https://news.google.com/rss/search?q=when:24h+allinurl:reuters.com&ceid=US:en&hl=en-US&gl=US', name: 'Reuters', color: '#FF6600' },
      { url: 'https://www.cnbc.com/id/10000664/device/rss/rss.html', name: 'CNBC', color: '#0D7AB3' },
      { url: 'https://feeds.bbci.co.uk/news/world/rss.xml', name: 'BBC World', color: '#BB1919' },
      { url: 'https://rss.nytimes.com/services/xml/rss/nyt/World.xml', name: 'NY Times', color: '#000000' },
      { url: 'https://feeds.a.dj.com/rss/RSSWorldNews.xml', name: 'WSJ', color: '#0274B6' },
      { url: 'https://www.yahoo.com/news/rss', name: 'Yahoo News', color: '#5F01D1' },
      { url: 'https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml', name: 'CoinDesk', color: '#FF9800' },
      { url: 'https://cointelegraph.com/rss', name: 'Cointelegraph', color: '#F7931A' }
    ];

    // Fetch all feeds in parallel using our own RSS proxy
    // Cache-busting handled server-side
    const responses = await Promise.all(
      feeds.map(feed =>
        fetch(`/api-rss.php?rss_url=${encodeURIComponent(feed.url)}&count=10`)
          .then(r => r.json())
          .then(data => {
            // Debug: Log first item's raw date for each feed
            if(data.items && data.items.length > 0){
              console.log(`\nüìÖ ${feed.name} - Raw date from RSS: ${data.items[0].pubDate}`);
            }
            return { ...feed, items: data.items || [] };
          })
          .catch(err => {
            console.warn(`Failed to fetch ${feed.name}:`, err);
            return { ...feed, items: [] };
          })
      )
    );

    console.log('News feeds fetched:', responses.map(r => `${r.name}:${r.items.length}`).join(', '));

    // Log all items from each feed to see what's available
    responses.forEach(feed => {
      if(feed.items.length > 0){
        console.log(`\nüì∞ ${feed.name} (${feed.items.length} items):`);
        feed.items.forEach((item, idx) => {
          const isNoTitle = item.title?.trim().startsWith('[No Title]');
          const titleDisplay = item.title?.substring(0, 80) || 'NO TITLE';
          const dateDisplay = item.pubDate || 'NO DATE';
          console.log(`  ${idx+1}. ${titleDisplay} | ${dateDisplay}${isNoTitle ? ' [FILTERED]' : ''}`);
        });
      }
    });

    // Special debug for Trump Truth
    const trumpFeed = responses.find(f => f.name === 'Trump Truth');
    if(trumpFeed){
      console.log(`\nüîç TRUMP TRUTH DETAILED DEBUG:`);
      console.log(`   Total items fetched: ${trumpFeed.items.length}`);

      trumpFeed.items.forEach((item, idx) => {
        console.log(`\n   Item #${idx + 1}:`);
        console.log(`     - Title: ${item.title ? item.title.substring(0, 80) : 'MISSING'}`);
        console.log(`     - PubDate: ${item.pubDate || 'MISSING'}`);
        console.log(`     - Link: ${item.link ? 'present' : 'MISSING'}`);

        if(item.pubDate){
          const parsed = new Date(item.pubDate);
          console.log(`     - Parsed date valid: ${!isNaN(parsed.getTime())}`);
          console.log(`     - Parsed date: ${parsed.toISOString()}`);
        }
      });
    }

    // Combine all news items with source info
    const allNews = [];
    let trumpAddedCount = 0;

    // Get blocked words from settings (case-insensitive)
    const blockedWords = settings.newsFilter
      ? settings.newsFilter.split(',').map(w => w.trim().toLowerCase()).filter(w => w.length > 0)
      : [];

    responses.forEach(feed => {
      feed.items.forEach(item => {
        // Skip items with [No Title] (re-truths/shares) and items without titles
        if(item.title && !item.title.trim().startsWith('[No Title]')){

          // Check if title contains any blocked words
          const titleLower = item.title.toLowerCase();
          const hasBlockedWord = blockedWords.some(word => titleLower.includes(word));
          if(hasBlockedWord) {
            console.log(`üö´ Filtered out: "${item.title.substring(0, 60)}..." (matched filter)`);
            return; // Skip this item
          }
          // Use current time if no pubDate provided (fallback for broken feeds)
          let dateToUse = item.pubDate || new Date().toISOString();

          // Force UTC parsing: if date string doesn't end with Z, append it to force UTC interpretation
          if(dateToUse && !dateToUse.endsWith('Z') && !dateToUse.includes('+') && !dateToUse.includes('GMT')){
            // Replace space with T if needed (e.g., "2025-10-30 17:06:32" -> "2025-10-30T17:06:32Z")
            dateToUse = dateToUse.replace(' ', 'T') + 'Z';
          }

          const parsedDate = new Date(dateToUse);

          // Only add if date is valid
          if(!isNaN(parsedDate.getTime())){
            allNews.push({
              title: item.title,
              link: item.link,
              pubDate: parsedDate,
              source: feed.name,
              sourceColor: feed.color
            });
            if(feed.name === 'Trump Truth') trumpAddedCount++;
          } else {
            // Debug: Log items that fail date validation
            if(feed.name === 'Trump Truth'){
              console.log(`   ‚ö†Ô∏è Trump item FAILED date validation: "${item.title?.substring(0, 50)}" | pubDate: ${item.pubDate}`);
            }
          }
        } else {
          // Debug: Log items with no title
          if(feed.name === 'Trump Truth'){
            console.log(`   ‚ö†Ô∏è Trump item MISSING TITLE`);
          }
        }
      });
    });

    console.log(`\n‚úÖ Trump Truth items added to allNews: ${trumpAddedCount} out of ${trumpFeed?.items.length || 0}`);

    // Sort by date (newest first)
    allNews.sort((a, b) => b.pubDate - a.pubDate);

    console.log(`üìä Total valid articles after filtering: ${allNews.length}`);

    // Show top 10 most recent articles
    const newsToShow = allNews.slice(0, 10);

    console.log(`\nüéØ TOP 10 ARTICLES TO DISPLAY:`);
    newsToShow.forEach((item, idx) => {
      console.log(`  ${idx+1}. [${item.source}] ${item.title.substring(0, 60)} | ${item.pubDate.toISOString()}`);
    });

    // Display
    const listEl = document.getElementById('newsList');
    if(!listEl) return;

    if(newsToShow.length === 0){
      listEl.innerHTML = `<div style="color:var(--muted);padding:20px;text-align:center">No news available</div>`;
      return;
    }

    listEl.innerHTML = newsToShow.map((item, idx) => {
      const timeAgo = getTimeAgo(item.pubDate);

      // Debug timezone for first article only
      if(idx === 0){
        console.log(`\n‚è∞ TIMEZONE DEBUG (first article):`);
        console.log(`   Original pubDate: ${item.pubDate}`);
        console.log(`   ISO string: ${item.pubDate.toISOString()}`);
        console.log(`   Local string: ${item.pubDate.toLocaleString()}`);
        console.log(`   Timezone offset: ${item.pubDate.getTimezoneOffset()} minutes`);
        console.log(`   Display time: ${timeAgo}`);
      }

      const sourceStyle = item.source === 'NY Times'
        ? `color:${item.sourceColor};font-weight:700;text-shadow:0 0 3px rgba(255,255,255,0.8)`
        : `color:${item.sourceColor};font-weight:700`;

      return `
        <div style="border-bottom:1px solid rgba(255,255,255,.1);padding:14px 6px">
          <a href="${item.link}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;display:block">
            <div style="font-weight:600;font-size:16px;line-height:1.4;margin-bottom:6px;color:var(--text)">${item.title}</div>
            <div style="display:flex;gap:12px;font-size:13px;color:var(--muted)">
              <span style="${sourceStyle}">${item.source}</span>
              <span>‚Ä¢</span>
              <span>${timeAgo}</span>
            </div>
          </a>
        </div>
      `;
    }).join('');

    // Update timestamp
    const updateTime = document.getElementById('newsUpdateTime');
    if(updateTime) updateTime.textContent = `Updated ${new Date().toLocaleTimeString('en-US', {hour:'numeric', minute:'2-digit'})}`;

    console.log(`‚úÖ Loaded ${newsToShow.length} news headlines from ${responses.length} sources (${allNews.length} total available)`);

    // Track successful update
    lastNewsUpdate = Date.now();
    newsUpdateCount++;
    console.log(`üìä News update #${newsUpdateCount} completed at ${new Date().toLocaleTimeString()}`);
  }catch(e){
    console.error('‚ùå News fetch error:', e);
    console.error(`Last successful update was ${lastNewsUpdate > 0 ? Math.floor((Date.now() - lastNewsUpdate) / 1000) + 's ago' : 'never'}`);
    const listEl = document.getElementById('newsList');
    if(listEl) listEl.innerHTML = '<div style="color:var(--down);padding:20px;text-align:center">Failed to load news</div>';
  }
}

// Helper function to format time as "X ago"
function getTimeAgo(date){
  const seconds = Math.floor((new Date() - date) / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  // Less than 1 minute
  if(minutes < 1){
    return seconds < 0 ? `${Math.abs(seconds)}s future` : `${seconds}s ago`;
  }

  // Less than 1 hour: show minutes
  if(minutes < 60){
    return minutes < 0 ? `${Math.abs(minutes)}m future` : `${minutes}m ago`;
  }

  // Less than 24 hours: show hours
  if(hours < 24){
    return hours < 0 ? `${Math.abs(hours)}h future` : `${hours}h ago`;
  }

  // More than 24 hours: show days
  const days = Math.floor(hours / 24);
  return days < 0 ? `${Math.abs(days)}d future` : `${days}d ago`;
}

/* ===== Settings Modal ===== */
const settings = {
  theme: 'dark',
  charts: { '30d': false, '24h': true, '12h': false, '8h': false, '1h': true, '10m': false, '5m': true, '1m': false, 'news': true, 'ticker': false },
  alerts: { volSpike: true, tradeBlink: true },
  weatherZip: '43440',
  newsFilter: ''
};

function loadSettings(){
  const saved = localStorage.getItem('btcStalkerSettings');
  if(saved){
    try{
      Object.assign(settings, JSON.parse(saved));
    }catch(e){}
  }
  applySettings();
}

function applySettings(){
  // Apply theme
  document.documentElement.setAttribute('data-theme', settings.theme);
  document.getElementById('themeDarkCheck').textContent = settings.theme === 'dark' ? '‚úì Active' : '';
  document.getElementById('themeLightCheck').textContent = settings.theme === 'light' ? '‚úì Active' : '';

  // Apply chart visibility
  TF.forEach(tf => {
    const col = document.getElementById(`col-${tf.key}`);
    if(col) col.style.display = settings.charts[tf.key] ? '' : 'none';
  });

  // Apply News visibility
  const newsCol = document.getElementById('col-news');
  if(newsCol){
    newsCol.style.display = settings.charts.news ? '' : 'none';
    // Fetch data if enabled
    if(settings.charts.news) fetchNewsData();
  }

  // Apply Ticker visibility
  const tickerCol = document.getElementById('col-ticker');
  if(tickerCol){
    tickerCol.style.display = settings.charts.ticker ? '' : 'none';
    // Update ticker if enabled
    if(settings.charts.ticker) updateTicker();
  }

  // Update checkboxes
  TF.forEach(tf => {
    const checkbox = document.getElementById(`chart${tf.key}`);
    if(checkbox) checkbox.checked = settings.charts[tf.key];
  });
  const newsCheck = document.getElementById('chartNews');
  if(newsCheck) newsCheck.checked = settings.charts.news;
  const tickerCheck = document.getElementById('chartTicker');
  if(tickerCheck) tickerCheck.checked = settings.charts.ticker;

  document.getElementById('alertVolSpike').checked = settings.alerts.volSpike;
  document.getElementById('alertTradeBlink').checked = settings.alerts.tradeBlink;

  // Apply weather zip
  const weatherZipInput = document.getElementById('weatherZip');
  if(weatherZipInput) weatherZipInput.value = settings.weatherZip;

  // Apply news filter
  const newsFilterInput = document.getElementById('newsFilter');
  if(newsFilterInput) newsFilterInput.value = settings.newsFilter;
}

function selectTheme(theme){
  settings.theme = theme;
  applySettings();
}

function openSettings(){
  applySettings(); // Sync checkboxes with current settings
  document.getElementById('settingsModal').classList.add('open');
}

function closeSettings(){
  document.getElementById('settingsModal').classList.remove('open');
}

function saveSettings(){
  // Read checkbox values
  TF.forEach(tf => {
    const checkbox = document.getElementById(`chart${tf.key}`);
    if(checkbox) settings.charts[tf.key] = checkbox.checked;
  });
  // News checkbox
  const newsCheck = document.getElementById('chartNews');
  if(newsCheck) settings.charts.news = newsCheck.checked;
  // Ticker checkbox
  const tickerCheck = document.getElementById('chartTicker');
  if(tickerCheck) settings.charts.ticker = tickerCheck.checked;

  settings.alerts.volSpike = document.getElementById('alertVolSpike').checked;
  settings.alerts.tradeBlink = document.getElementById('alertTradeBlink').checked;

  // Weather zip code
  const weatherZipInput = document.getElementById('weatherZip');
  if(weatherZipInput && weatherZipInput.value.trim()) {
    settings.weatherZip = weatherZipInput.value.trim();
  }

  // News filter
  const newsFilterInput = document.getElementById('newsFilter');
  if(newsFilterInput) {
    settings.newsFilter = newsFilterInput.value.trim();
  }

  // Save to localStorage
  localStorage.setItem('btcStalkerSettings', JSON.stringify(settings));

  // Apply the settings
  applySettings();

  // Update weather with new zip
  updateWeather();

  // Refresh news if filter changed
  if(settings.charts.news) {
    fetchNewsData();
  }

  // Close modal
  closeSettings();
}

/* ===== Start ===== */
// Wait for DOM to be fully ready before drawing
setTimeout(async () => {
  loadSettings(); // Load saved settings
  await loadTopTradesFromMySQL(); // Load persisted top trades from MySQL FIRST
  // setupFirebaseListeners removed - MySQL doesn't need real-time sync
  fetchHistoricalCandles(); // Then fetch historical data (which will merge with Firebase data)
  startWS();
  fetch24h();
  fetchMetalPrices();
  fetchNewsData(); // Initial load
  updateClock();
  updateWeather();
  setInterval(restFallback, 1200);
  setInterval(fetch24h, 60000);
  setInterval(fetchMetalPrices, 300000); // Update every 5 minutes
  setInterval(fetchNewsData, 180000); // Update news every 3 minutes
  setInterval(updateClock, 1000); // Update every second
  setInterval(updateWeather, 600000); // Update weather every 10 minutes

  // Health monitor: check if trades are flowing and arrays aren't empty
  setInterval(() => {
    const timeSinceLastTrade = Date.now() - lastTradeTime;
    if(lastTradeTime > 0 && timeSinceLastTrade > 60000){ // No trades for 1+ minute
      console.warn(`‚ö†Ô∏è No trades received for ${Math.floor(timeSinceLastTrade/1000)}s. 5m: ${win5m.length}, WS state: ${ws?.readyState}`);
    }
    if(win5m.length === 0 && lastTradeTime > 0){
      console.error(`üö® 5m array is empty! Last trade ${Math.floor(timeSinceLastTrade/1000)}s ago. This might cause blank chart.`);
    }
  }, 60000); // Check every minute
}, 100);
</script>
</body>
</html>
