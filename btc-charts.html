<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Charts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 2fr;
            gap: 2px;
            padding: 2px;
            height: 30px;
        }

        .chart-panel {
            background: #1e293b;
            border-radius: 2px;
            padding: 1px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(45, 212, 191, 0.15);
            border: 1px solid rgba(45, 212, 191, 0.1);
        }

        .chart-header {
            font-size: 11px;
            font-weight: bold;
            color: #94a3b8;
            margin-bottom: 2px;
            text-align: center;
            letter-spacing: 1px;
            position: relative;
        }

        .version-tag {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 9px;
            color: #64748b;
            font-weight: normal;
            opacity: 0.7;
        }

        .price-display {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 2px;
            color: #2dd4bf;
            text-shadow: 0 0 20px rgba(45, 212, 191, 0.3);
        }

        .change-display {
            font-size: 12px;
            text-align: center;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .chart-container {
            flex: 1;
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .stats-wrapper {
            margin-bottom: 0px;
            padding: 0 1px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            gap: 4px;
            margin-bottom: 0px;
        }

        .stats-row-center {
            display: flex;
            justify-content: center;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 0px;
            padding: 0 1px;
            font-size: 12px;
            gap: 2px;
        }

        .stat {
            text-align: center;
            flex: 1;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 10px;
            margin-bottom: 3px;
            letter-spacing: 1px;
        }

        .stat-value {
            color: #e2e8f0;
            font-weight: bold;
            font-size: 13px;
        }

        .up {
            color: #2dd4bf;
        }

        .down {
            color: #f59e0b;
        }

        /* Bias Gauge */
        .gauge-row {
            display: flex;
            align-items: center;
            gap: 1px;
            padding: 0px 1px;
            margin-top: 0px;
        }

        .gauge-label {
            font-size: 6px;
            opacity: 0.9;
        }

        .gauge-label.buy {
            color: #2dd4bf;
        }

        .gauge-label.sell {
            color: #f59e0b;
        }

        #biasGauge-5m {
            width: 100%;
            height: 7px;
            border-radius: 999px;
            background: transparent;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
        }

        .gauge-wrap {
            position: relative;
            flex: 1;
        }

        .needle {
            position: absolute;
            top: 2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 9px solid #fff;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.35));
            transition: left 0.2s;
        }

        .needle-value {
            position: absolute;
            top: -13px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.25);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chart-panel">
            <div class="chart-header">24 HOURS</div>
            <div class="stats-wrapper">
                <div class="stats-row">
                    <div class="stat">
                        <div class="stat-label">HIGH</div>
                        <div class="stat-value" id="high-24h">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">LOW</div>
                        <div class="stat-value" id="low-24h">-</div>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="chart-24h"></canvas>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">1 HOUR</div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-1h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">AVG</div>
                    <div class="stat-value" id="avg-1h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-1h">-</div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="chart-1h"></canvas>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">5 MINUTES<span class="version-tag">v1.9</span></div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-5m">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-5m">-</div>
                </div>
            </div>
            <div class="price-display" id="price-5m">$--,---</div>
            <div class="change-display" id="change-5m">--</div>
            <div class="chart-container">
                <canvas id="chart-5m"></canvas>
            </div>
            <div class="gauge-row">
                <span class="gauge-label buy">Buys</span>
                <div class="gauge-wrap">
                    <canvas id="biasGauge-5m"></canvas>
                    <div id="needle-5m" class="needle" style="left:50%"></div>
                    <div id="needleValue-5m" class="needle-value" style="left:50%">0%</div>
                </div>
                <span class="gauge-label sell">Sells</span>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const chartConfigs = {
            '24h': { canvasId: 'chart-24h', granularity: 900, points: 96 },  // 15min bars, 96 points = 24 hours
            '1h': { canvasId: 'chart-1h', granularity: 60, points: 60 },     // 1min bars, 60 points = 1 hour
            '5m': { canvasId: 'chart-5m', granularity: 5, points: 60 }       // 5sec bars, 60 points = 5 minutes
        };

        const charts = {};
        const priceData = {};

        // Initialize charts
        Object.keys(chartConfigs).forEach(key => {
            const config = chartConfigs[key];
            const ctx = document.getElementById(config.canvasId).getContext('2d');

            priceData[key] = {
                timestamps: [],
                prices: [],
                volumes: []
            };

            charts[key] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'BTC/USD',
                        data: [],
                        borderColor: '#2dd4bf',
                        backgroundColor: 'rgba(45, 212, 191, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        fill: true,
                        segment: {
                            borderColor: ctx => {
                                const chart = ctx.chart;
                                const {p0, p1} = ctx;
                                if (!p0 || !p1) return '#2dd4bf';
                                const avg = chart.data.datasets[1].data[p0.parsed.x];
                                const v0 = p0.parsed.y;
                                const v1 = p1.parsed.y;
                                return (v0 >= avg || v1 >= avg) ? '#2dd4bf' : '#f59e0b';
                            },
                            backgroundColor: ctx => {
                                const chart = ctx.chart;
                                const {p0, p1} = ctx;
                                if (!p0 || !p1) return 'rgba(45, 212, 191, 0.1)';
                                const avg = chart.data.datasets[1].data[p0.parsed.x];
                                const v0 = p0.parsed.y;
                                const v1 = p1.parsed.y;
                                return (v0 >= avg || v1 >= avg) ? 'rgba(45, 212, 191, 0.1)' : 'rgba(245, 158, 11, 0.1)';
                            }
                        }
                    }, {
                        label: 'Average',
                        data: [],
                        borderColor: '#94a3b8',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(148, 163, 184, 0.15)',
                                lineWidth: 1
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                color: '#64748b',
                                font: {
                                    size: 11,
                                    family: "'Courier New', monospace"
                                },
                                padding: 8
                            }
                        }
                    },
                    interaction: { mode: 'index', intersect: false }
                }
            });
        });

        // Fetch historical data from Coinbase
        async function fetchHistoricalData(timeframe) {
            const config = chartConfigs[timeframe];
            const end = Math.floor(Date.now() / 1000);
            const start = end - (config.granularity * config.points);

            try {
                const response = await fetch(
                    `https://api.exchange.coinbase.com/products/BTC-USD/candles?start=${start}&end=${end}&granularity=${config.granularity}`
                );
                const data = await response.json();

                // Coinbase returns [time, low, high, open, close, volume]
                data.reverse().forEach(candle => {
                    const [time, low, high, open, close, volume] = candle;
                    priceData[timeframe].timestamps.push(time);
                    priceData[timeframe].prices.push(close);
                    priceData[timeframe].volumes.push(volume);
                });

                updateChart(timeframe);
                updateStats(timeframe);
            } catch (error) {
                console.error(`Error fetching ${timeframe} data:`, error);
            }
        }

        function updateChart(timeframe) {
            const data = priceData[timeframe];
            const chart = charts[timeframe];
            const avg = data.prices.reduce((a, b) => a + b, 0) / data.prices.length;

            chart.data.labels = data.timestamps.map(t => new Date(t * 1000).toLocaleTimeString());
            chart.data.datasets[0].data = data.prices;

            // Add average line as horizontal line across all points
            chart.data.datasets[1].data = new Array(data.prices.length).fill(avg);

            chart.update('none');
        }

        function updateStats(timeframe) {
            const data = priceData[timeframe];
            if (data.prices.length === 0) return;

            const currentPrice = data.prices[data.prices.length - 1];
            const startPrice = data.prices[0];
            const high = Math.max(...data.prices);
            const low = Math.min(...data.prices);
            const avg = data.prices.reduce((a, b) => a + b, 0) / data.prices.length;
            const change = ((currentPrice - startPrice) / startPrice) * 100;

            // Only update price display if element exists (for 5m chart)
            const priceEl = document.getElementById(`price-${timeframe}`);
            if (priceEl) {
                priceEl.textContent =
                    `$${currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            }

            const changeEl = document.getElementById(`change-${timeframe}`);
            if (changeEl) {
                const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeEl.textContent = changeText;
                changeEl.className = `change-display ${change >= 0 ? 'up' : 'down'}`;
            }

            document.getElementById(`high-${timeframe}`).textContent =
                `$${high.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            document.getElementById(`low-${timeframe}`).textContent =
                `$${low.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;

            // Update average if element exists
            const avgEl = document.getElementById(`avg-${timeframe}`);
            if (avgEl) {
                avgEl.textContent =
                    `$${avg.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
                // Color code AVG based on price vs average
                avgEl.className = `stat-value ${currentPrice > avg ? 'up' : 'down'}`;
            }
        }

        // Bias Gauge
        let buyVolume = 0, sellVolume = 0;
        let needlePos = 0.5;

        function sizeCanvas(canvas) {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            return canvas.getContext('2d');
        }

        function drawGauge() {
            const canvas = document.getElementById('biasGauge-5m');
            if (!canvas) return;

            const ctx = sizeCanvas(canvas);
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const total = buyVolume + sellVolume;
            const target = total ? (buyVolume / total) : 0.5;

            needlePos += (target - needlePos) * 0.25;

            const upColor = '#2dd4bf';
            const downColor = '#f59e0b';

            const g = ctx.createLinearGradient(0, 0, w, 0);
            g.addColorStop(0, upColor);
            g.addColorStop(Math.max(0, needlePos - 0.001), upColor);
            g.addColorStop(Math.min(1, needlePos + 0.001), downColor);
            g.addColorStop(1, downColor);

            const r = h / 2;
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.moveTo(r, 1);
            ctx.arcTo(w - 1, 1, w - 1, h - 1, r);
            ctx.arcTo(w - 1, h - 1, 0, h - 1, r);
            ctx.arcTo(0, h - 1, 0, 1, r);
            ctx.arcTo(0, 1, w - 1, 1, r);
            ctx.fill();

            const needle = document.getElementById('needle-5m');
            const needleValue = document.getElementById('needleValue-5m');
            if (!needle || !needleValue) return;

            const leftPx = Math.round(canvas.getBoundingClientRect().width * needlePos);
            needle.style.left = leftPx + 'px';
            const biasPct = total ? ((buyVolume - sellVolume) / total) * 100 : 0;
            needleValue.textContent = (biasPct >= 0 ? '+' : '') + biasPct.toFixed(0) + '%';
            needleValue.style.left = leftPx + 'px';
        }

        // WebSocket for real-time updates
        const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');

        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'subscribe',
                product_ids: ['BTC-USD'],
                channels: ['ticker', 'matches']
            }));
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'ticker' && data.price) {
                const price = parseFloat(data.price);
                const now = Math.floor(Date.now() / 1000);

                // Update each timeframe
                Object.keys(chartConfigs).forEach(key => {
                    const pData = priceData[key];
                    const config = chartConfigs[key];

                    // Add new data point
                    if (pData.timestamps.length === 0 ||
                        now - pData.timestamps[pData.timestamps.length - 1] >= config.granularity) {
                        pData.timestamps.push(now);
                        pData.prices.push(price);
                        pData.volumes.push(0);

                        // Keep only the required number of points
                        if (pData.timestamps.length > config.points) {
                            pData.timestamps.shift();
                            pData.prices.shift();
                            pData.volumes.shift();
                        }

                        updateChart(key);
                        updateStats(key);
                    }
                });
            }

            // Handle match data for bias gauge
            if (data.type === 'match') {
                const size = parseFloat(data.size);
                if (data.side === 'buy') {
                    buyVolume += size;
                } else {
                    sellVolume += size;
                }
                drawGauge();
            }
        };

        // Reset volume periodically (every 5 minutes)
        setInterval(() => {
            buyVolume *= 0.8;
            sellVolume *= 0.8;
            drawGauge();
        }, 5000);

        // Initialize with historical data
        Object.keys(chartConfigs).forEach(key => {
            fetchHistoricalData(key);
        });

        // Refresh historical data periodically
        setInterval(() => {
            Object.keys(chartConfigs).forEach(key => {
                fetchHistoricalData(key);
            });
        }, 60000); // Refresh every minute
    </script>
</body>
</html>
