<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Charts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 2fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
        }

        .chart-panel {
            background: #1e293b;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(45, 212, 191, 0.1);
        }

        .chart-header {
            font-size: 20px;
            font-weight: bold;
            color: #2dd4bf;
            margin-bottom: 8px;
            text-align: left;
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .timeframe-label {
            min-width: 90px;
        }

        .change-display {
            font-size: 16px;
            font-weight: normal;
            text-shadow: none;
        }

        .version-tag {
            position: absolute;
            top: 0;
            right: 5px;
            font-size: 10px;
            color: #64748b;
            font-weight: normal;
            opacity: 0.7;
        }

        .price-display {
            font-size: 24px;
            margin-left: auto;
            color: #2dd4bf;
            background: rgba(45, 212, 191, 0.15);
            padding: 6px 16px;
            border-radius: 20px;
            border: 1px solid rgba(45, 212, 191, 0.3);
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
            user-select: none;
        }

        .price-display.milestone-alert {
            animation: milestone-pulse 1s ease-in-out 3;
        }

        @keyframes milestone-pulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
            }
            50% {
                transform: scale(1.2);
                text-shadow: 0 0 30px rgba(45, 212, 191, 1), 0 0 50px rgba(45, 212, 191, 0.8);
            }
        }

        .volume-spike {
            animation: volume-blink 0.6s ease-in-out infinite;
        }

        @keyframes volume-blink {
            0%, 100% {
                border-left-color: #2dd4bf;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 15px rgba(45, 212, 191, 0.3);
            }
            50% {
                border-left-color: #f59e0b;
                box-shadow: 0 0 25px rgba(245, 158, 11, 0.8), 0 0 40px rgba(245, 158, 11, 0.4);
            }
        }

        .chart-container {
            flex: 1;
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 8px;
            font-size: 14px;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 12px;
        }

        .stat-value {
            color: #e2e8f0;
            font-weight: bold;
            font-size: 16px;
        }

        .up {
            color: #2dd4bf;
        }

        .down {
            color: #f59e0b;
        }

        /* Minimal gauge styling */
        .gauge-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .gauge-bar {
            flex: 1;
            position: relative;
            height: 6px;
        }

        #biasGauge {
            width: 100%;
            height: 100%;
            border-radius: 3px;
        }

        .needle {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 10px;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transition: left 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label">24 HOURS</span>
                <span class="change-display" id="change-24h">--</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-24h"></canvas>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-24h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-24h">-</div>
                </div>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label">1 HOUR</span>
                <span class="change-display" id="change-1h">--</span>
                <span class="version-tag">v3.14</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-1h"></canvas>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-1h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-1h">-</div>
                </div>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label" onclick="location.reload()" title="Click to refresh" style="cursor: pointer;">5 MINUTES</span>
                <span class="change-display" id="change-5m">--</span>
                <span class="price-display" id="price-5m">$--,---</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-5m"></canvas>
            </div>
            <div class="stats">
                <div class="gauge-container">
                    <span class="stat-label" style="color: #2dd4bf;">BUY</span>
                    <div class="gauge-bar">
                        <canvas id="biasGauge"></canvas>
                        <div id="needle" class="needle" style="left: 50%;"></div>
                    </div>
                    <span class="stat-label" style="color: #f59e0b;">SELL</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const chartConfigs = {
            '24h': { canvasId: 'chart-24h', granularity: 900, points: 96, historyPoints: 96, updateInterval: 900 },  // 15min bars, 96 points = 24 hours
            '1h': { canvasId: 'chart-1h', granularity: 60, points: 60, historyPoints: 60, updateInterval: 60 },      // 1min bars, 60 points = 1 hour
            '5m': { canvasId: 'chart-5m', granularity: 60, points: 300, historyPoints: 5, updateInterval: 1 }        // Fetch 5x60sec candles, then add 1sec updates to 300 points (5 min)
        };

        const charts = {};
        const priceData = {};

        // Initialize charts
        Object.keys(chartConfigs).forEach(key => {
            const config = chartConfigs[key];
            const ctx = document.getElementById(config.canvasId).getContext('2d');

            priceData[key] = {
                timestamps: [],
                prices: [],
                volumes: []
            };

            charts[key] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'BTC/USD',
                        data: [],
                        borderColor: '#2dd4bf',
                        backgroundColor: 'rgba(45, 212, 191, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            },
                            ticks: {
                                color: '#94a3b8',
                                font: { size: 14 },
                                maxTicksLimit: 5
                            }
                        }
                    },
                    interaction: { mode: 'index', intersect: false }
                }
            });
        });

        // Fetch historical data from Coinbase
        async function fetchHistoricalData(timeframe) {
            const config = chartConfigs[timeframe];
            const end = Math.floor(Date.now() / 1000);
            const start = end - (config.granularity * config.historyPoints);

            try {
                const response = await fetch(
                    `https://api.exchange.coinbase.com/products/BTC-USD/candles?start=${start}&end=${end}&granularity=${config.granularity}`
                );
                const data = await response.json();

                // Clear existing data to prevent stacking
                priceData[timeframe].timestamps = [];
                priceData[timeframe].prices = [];
                priceData[timeframe].volumes = [];

                // Coinbase returns [time, low, high, open, close, volume]
                data.reverse().forEach(candle => {
                    const [time, low, high, open, close, volume] = candle;
                    priceData[timeframe].timestamps.push(time);
                    priceData[timeframe].prices.push(close);
                    priceData[timeframe].volumes.push(volume);
                });

                updateChart(timeframe);
                updateStats(timeframe);
            } catch (error) {
                console.error(`Error fetching ${timeframe} data:`, error);
            }
        }

        function updateChart(timeframe) {
            const data = priceData[timeframe];
            const chart = charts[timeframe];
            const avg = data.prices.reduce((a, b) => a + b, 0) / data.prices.length;

            chart.data.labels = data.timestamps.map(t => new Date(t * 1000).toLocaleTimeString());
            chart.data.datasets[0].data = data.prices;

            // Color based on current vs average
            const currentPrice = data.prices[data.prices.length - 1];
            chart.data.datasets[0].borderColor = currentPrice > avg ? '#2dd4bf' : '#f59e0b';
            chart.data.datasets[0].backgroundColor = currentPrice > avg ?
                'rgba(45, 212, 191, 0.1)' : 'rgba(245, 158, 11, 0.1)';

            chart.update('none');
        }

        function updateStats(timeframe) {
            const data = priceData[timeframe];
            if (data.prices.length === 0) return;

            const currentPrice = data.prices[data.prices.length - 1];
            const startPrice = data.prices[0];
            const high = Math.max(...data.prices);
            const low = Math.min(...data.prices);

            // Calculate change
            const changeAmount = currentPrice - startPrice;
            const changePercent = (changeAmount / startPrice) * 100;
            const isPositive = changeAmount >= 0;

            const priceEl = document.getElementById(`price-${timeframe}`);
            if (priceEl) {
                priceEl.textContent =
                    `$${currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            }
            const highEl = document.getElementById(`high-${timeframe}`);
            if (highEl) {
                highEl.textContent =
                    `$${high.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }
            const lowEl = document.getElementById(`low-${timeframe}`);
            if (lowEl) {
                lowEl.textContent =
                    `$${low.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }

            // Update change display
            const changeEl = document.getElementById(`change-${timeframe}`);
            if (changeEl) {
                const sign = isPositive ? '+' : '';
                changeEl.textContent =
                    `${sign}$${Math.abs(changeAmount).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} (${sign}${changePercent.toFixed(1)}%)`;
                changeEl.className = 'change-display ' + (isPositive ? 'up' : 'down');
            }
        }

        // Bias Gauge
        let buyVolume = 0, sellVolume = 0;
        let recentMinuteVolumes = [];  // Track 1-minute volume totals for spike detection
        const VOLUME_WINDOW = 30; // Track last 30 minutes for average
        let currentMinuteVolume = 0;
        let currentMinuteTimestamp = Math.floor(Date.now() / 60000); // Current minute bucket
        let needlePos = 0.5;
        let volumeSpikeActive = false;

        // Real-time volume tracking
        let recentTrades = [];  // Track last 10 seconds of trades
        const REALTIME_WINDOW = 10000; // 10 second window in milliseconds

        // Milestone tracking
        let lastMilestone = null;
        let priceBeforeCrossing = null;

        // Check real-time volume and update blinking
        function checkRealtimeVolume() {
            const now = Date.now();
            const panel = document.querySelector('#chart-5m').closest('.chart-panel');
            if (!panel) return;

            // Remove old trades outside the window
            recentTrades = recentTrades.filter(t => now - t.timestamp < REALTIME_WINDOW);

            // Calculate current volume rate (volume per second over last 10 seconds)
            const currentVolumeRate = recentTrades.reduce((sum, t) => sum + t.size, 0) / (REALTIME_WINDOW / 1000);

            // Only compare if we have enough historical data
            if (recentMinuteVolumes.length >= 5) {
                // Calculate average volume rate from historical minutes
                const avgMinuteVolume = recentMinuteVolumes.reduce((a, b) => a + b, 0) / recentMinuteVolumes.length;
                const avgVolumeRate = avgMinuteVolume / 60; // Convert to per-second

                // Check if current rate is significantly higher (1.5x average)
                const shouldBlink = currentVolumeRate >= avgVolumeRate * 1.5 && recentTrades.length > 5;

                if (shouldBlink && !volumeSpikeActive) {
                    panel.classList.add('volume-spike');
                    volumeSpikeActive = true;
                } else if (!shouldBlink && volumeSpikeActive) {
                    panel.classList.remove('volume-spike');
                    volumeSpikeActive = false;
                }
            }
        }

        function drawGauge() {
            const canvas = document.getElementById('biasGauge');
            if (!canvas) return;

            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            const ctx = canvas.getContext('2d');

            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const total = buyVolume + sellVolume;
            const target = total ? (buyVolume / total) : 0.5;
            needlePos += (target - needlePos) * 0.25;

            const g = ctx.createLinearGradient(0, 0, w, 0);
            g.addColorStop(0, '#2dd4bf');
            g.addColorStop(Math.max(0, needlePos - 0.001), '#2dd4bf');
            g.addColorStop(Math.min(1, needlePos + 0.001), '#f59e0b');
            g.addColorStop(1, '#f59e0b');

            ctx.fillStyle = g;
            ctx.fillRect(0, 0, w, h);

            const needle = document.getElementById('needle');
            if (needle) {
                needle.style.left = (needlePos * 100) + '%';
            }
        }

        // Check for milestone crossing and trigger animation
        function checkMilestone(price) {
            const currentMilestone = Math.floor(price / 200) * 200;

            // Initialize tracking on first run
            if (lastMilestone === null) {
                lastMilestone = currentMilestone;
                priceBeforeCrossing = price;
                return;
            }

            // Check if we crossed a milestone threshold
            if (currentMilestone !== lastMilestone) {
                // Calculate how far we moved from the threshold
                const threshold = lastMilestone > currentMilestone ? lastMilestone : currentMilestone;
                const distanceFromThreshold = Math.abs(price - threshold);

                // Only trigger if we moved at least $50 from the threshold
                if (distanceFromThreshold >= 50) {
                    const priceEl = document.getElementById('price-5m');
                    if (priceEl) {
                        // Add animation class
                        priceEl.classList.add('milestone-alert');

                        // Remove class after animation completes (3 seconds for 3 pulses at 1s each)
                        setTimeout(() => {
                            priceEl.classList.remove('milestone-alert');
                        }, 3000);
                    }

                    console.log(`ðŸŽ¯ Milestone crossed: $${threshold.toLocaleString()} â†’ $${price.toLocaleString()}`);
                }

                // Update tracking
                lastMilestone = currentMilestone;
                priceBeforeCrossing = price;
            }
        }

        // WebSocket for real-time updates
        const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');

        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'subscribe',
                product_ids: ['BTC-USD'],
                channels: ['ticker', 'matches']
            }));
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'ticker' && data.price) {
                const price = parseFloat(data.price);
                const now = Math.floor(Date.now() / 1000);

                // Check for milestone crossing
                checkMilestone(price);

                // Update each timeframe
                Object.keys(chartConfigs).forEach(key => {
                    const pData = priceData[key];
                    const config = chartConfigs[key];

                    // Add new data point
                    if (pData.timestamps.length === 0 ||
                        now - pData.timestamps[pData.timestamps.length - 1] >= config.updateInterval) {
                        pData.timestamps.push(now);
                        pData.prices.push(price);
                        pData.volumes.push(0);

                        // Keep only the required number of points
                        if (pData.timestamps.length > config.points) {
                            pData.timestamps.shift();
                            pData.prices.shift();
                            pData.volumes.shift();
                        }

                        updateChart(key);
                        updateStats(key);
                    }
                });
            }

            // Handle match data for bias gauge
            if (data.type === 'match') {
                const size = parseFloat(data.size);
                if (data.side === 'buy') {
                    buyVolume += size;
                } else {
                    sellVolume += size;
                }
                drawGauge();

                // Track volume by minute for historical baseline
                const currentMinute = Math.floor(Date.now() / 60000);

                // Check if we've moved to a new minute
                if (currentMinute !== currentMinuteTimestamp) {
                    // Save the previous minute's volume for historical baseline
                    if (currentMinuteVolume > 0) {
                        recentMinuteVolumes.push(currentMinuteVolume);
                        if (recentMinuteVolumes.length > VOLUME_WINDOW) {
                            recentMinuteVolumes.shift();
                        }
                    }

                    // Reset for new minute
                    currentMinuteVolume = 0;
                    currentMinuteTimestamp = currentMinute;
                }

                // Add current trade volume to this minute's total
                currentMinuteVolume += size;

                // Add trade to real-time tracking
                recentTrades.push({
                    size: size,
                    timestamp: Date.now()
                });

                // Check volume in real-time
                checkRealtimeVolume();
            }
        };

        // Wait for window to fully load before initializing
        window.addEventListener('load', () => {
            // Delay to let Lovelace iframe size properly
            setTimeout(() => {
                // Force chart resize
                Object.keys(charts).forEach(key => {
                    charts[key].resize();
                });

                // Initialize with historical data
                Object.keys(chartConfigs).forEach(key => {
                    fetchHistoricalData(key);
                });
            }, 500);
        });

        // Refresh historical data periodically (skip 5m since it updates via WebSocket)
        setInterval(() => {
            Object.keys(chartConfigs).forEach(key => {
                if (key !== '5m') {
                    fetchHistoricalData(key);
                }
            });
        }, 60000); // Refresh every minute

        // Decay volume for gauge
        setInterval(() => {
            buyVolume *= 0.8;
            sellVolume *= 0.8;
            drawGauge();
        }, 5000);
    </script>
</body>
</html>
