<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Charts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 2fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
        }

        .chart-panel {
            background: #1e293b;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(45, 212, 191, 0.1);
        }

        .chart-header {
            font-size: 18px;
            font-weight: bold;
            color: #2dd4bf;
            margin-bottom: 10px;
            text-align: left;
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .timeframe-label {
            min-width: 90px;
        }

        .change-display {
            font-size: 14px;
            font-weight: normal;
            text-shadow: none;
        }

        .version-tag {
            position: absolute;
            top: 0;
            right: 5px;
            font-size: 10px;
            color: #64748b;
            font-weight: normal;
            opacity: 0.7;
        }

        .price-display {
            font-size: 22px;
            margin-left: auto;
            color: #2dd4bf;
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
        }

        .chart-container {
            flex: 1;
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 12px;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 10px;
        }

        .stat-value {
            color: #e2e8f0;
            font-weight: bold;
        }

        .up {
            color: #2dd4bf;
        }

        .down {
            color: #f59e0b;
        }

        /* Minimal gauge styling */
        .gauge-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .gauge-bar {
            flex: 1;
            position: relative;
            height: 6px;
        }

        #biasGauge {
            width: 100%;
            height: 100%;
            border-radius: 3px;
        }

        .needle {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 10px;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transition: left 0.2s;
        }

        /* Volume spike alert animation */
        .chart-panel.spikeAlert {
            animation: volSpike 4s ease-out;
        }
        @keyframes volSpike {
            0%, 10%, 20%, 30% {
                box-shadow: 0 0 60px rgba(245, 158, 11, 0.9),
                            0 0 100px rgba(245, 158, 11, 0.6),
                            inset 0 0 40px rgba(245, 158, 11, 0.3);
                transform: scale(1.05);
                border: 3px solid #f59e0b;
            }
            5%, 15%, 25% {
                box-shadow: 0 0 30px rgba(45, 212, 191, 0.7),
                            0 0 50px rgba(45, 212, 191, 0.4);
                transform: scale(1.02);
                border: 3px solid #2dd4bf;
            }
            40% {
                box-shadow: 0 0 40px rgba(245, 158, 11, 0.6);
                transform: scale(1.03);
            }
            60% {
                box-shadow: 0 0 25px rgba(45, 212, 191, 0.4);
                transform: scale(1.01);
            }
            100% {
                box-shadow: 0 0 20px rgba(45, 212, 191, 0.1);
                transform: scale(1);
                border: 3px solid transparent;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label">24 HOURS</span>
                <span class="change-display" id="change-24h">--</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-24h"></canvas>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-24h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-24h">-</div>
                </div>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label">1 HOUR</span>
                <span class="change-display" id="change-1h">--</span>
                <span class="version-tag">v2.6</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-1h"></canvas>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">HIGH</div>
                    <div class="stat-value" id="high-1h">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LOW</div>
                    <div class="stat-value" id="low-1h">-</div>
                </div>
            </div>
        </div>

        <div class="chart-panel">
            <div class="chart-header">
                <span class="timeframe-label">5 MINUTES</span>
                <span class="change-display" id="change-5m">--</span>
                <span class="price-display" id="price-5m">$--,---</span>
            </div>
            <div class="chart-container">
                <canvas id="chart-5m"></canvas>
            </div>
            <div class="stats">
                <div class="gauge-container">
                    <span class="stat-label" style="color: #2dd4bf;">BUY</span>
                    <div class="gauge-bar">
                        <canvas id="biasGauge"></canvas>
                        <div id="needle" class="needle" style="left: 50%;"></div>
                    </div>
                    <span class="stat-label" style="color: #f59e0b;">SELL</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const chartConfigs = {
            '24h': { canvasId: 'chart-24h', granularity: 900, points: 96 },  // 15min bars, 96 points = 24 hours
            '1h': { canvasId: 'chart-1h', granularity: 60, points: 60 },     // 1min bars, 60 points = 1 hour
            '5m': { canvasId: 'chart-5m', granularity: 5, points: 60 }       // 5sec bars, 60 points = 5 minutes
        };

        const charts = {};
        const priceData = {};
        const volumeHistory = {}; // Track volume for spike detection

        // Initialize charts
        Object.keys(chartConfigs).forEach(key => {
            const config = chartConfigs[key];
            const ctx = document.getElementById(config.canvasId).getContext('2d');

            priceData[key] = {
                timestamps: [],
                prices: [],
                volumes: []
            };

            charts[key] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'BTC/USD',
                        data: [],
                        borderColor: '#2dd4bf',
                        backgroundColor: 'rgba(45, 212, 191, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            },
                            ticks: {
                                color: '#94a3b8',
                                font: { size: 10 }
                            }
                        }
                    },
                    interaction: { mode: 'index', intersect: false }
                }
            });
        });

        // Fetch historical data from Coinbase
        async function fetchHistoricalData(timeframe) {
            const config = chartConfigs[timeframe];
            const end = Math.floor(Date.now() / 1000);
            const start = end - (config.granularity * config.points);

            try {
                const response = await fetch(
                    `https://api.exchange.coinbase.com/products/BTC-USD/candles?start=${start}&end=${end}&granularity=${config.granularity}`
                );
                const data = await response.json();

                // Clear existing data to prevent stacking
                priceData[timeframe].timestamps = [];
                priceData[timeframe].prices = [];
                priceData[timeframe].volumes = [];

                // Coinbase returns [time, low, high, open, close, volume]
                data.reverse().forEach(candle => {
                    const [time, low, high, open, close, volume] = candle;
                    priceData[timeframe].timestamps.push(time);
                    priceData[timeframe].prices.push(close);
                    priceData[timeframe].volumes.push(volume);
                });

                updateChart(timeframe);
                updateStats(timeframe);
            } catch (error) {
                console.error(`Error fetching ${timeframe} data:`, error);
            }
        }

        function updateChart(timeframe) {
            const data = priceData[timeframe];
            const chart = charts[timeframe];
            const avg = data.prices.reduce((a, b) => a + b, 0) / data.prices.length;

            chart.data.labels = data.timestamps.map(t => new Date(t * 1000).toLocaleTimeString());
            chart.data.datasets[0].data = data.prices;

            // Color based on current vs average
            const currentPrice = data.prices[data.prices.length - 1];
            chart.data.datasets[0].borderColor = currentPrice > avg ? '#2dd4bf' : '#f59e0b';
            chart.data.datasets[0].backgroundColor = currentPrice > avg ?
                'rgba(45, 212, 191, 0.1)' : 'rgba(245, 158, 11, 0.1)';

            chart.update('none');
        }

        function updateStats(timeframe) {
            const data = priceData[timeframe];
            if (data.prices.length === 0) return;

            const currentPrice = data.prices[data.prices.length - 1];
            const startPrice = data.prices[0];
            const high = Math.max(...data.prices);
            const low = Math.min(...data.prices);

            // Calculate change
            const changeAmount = currentPrice - startPrice;
            const changePercent = (changeAmount / startPrice) * 100;
            const isPositive = changeAmount >= 0;

            const priceEl = document.getElementById(`price-${timeframe}`);
            if (priceEl) {
                priceEl.textContent =
                    `$${currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            }
            const highEl = document.getElementById(`high-${timeframe}`);
            if (highEl) {
                highEl.textContent =
                    `$${high.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }
            const lowEl = document.getElementById(`low-${timeframe}`);
            if (lowEl) {
                lowEl.textContent =
                    `$${low.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }

            // Update change display
            const changeEl = document.getElementById(`change-${timeframe}`);
            if (changeEl) {
                const sign = isPositive ? '+' : '';
                changeEl.textContent =
                    `${sign}$${Math.abs(changeAmount).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} (${sign}${changePercent.toFixed(1)}%)`;
                changeEl.className = 'change-display ' + (isPositive ? 'up' : 'down');
            }
        }

        // Bias Gauge
        let buyVolume = 0, sellVolume = 0;
        let needlePos = 0.5;

        // Volume spike detection for 5m chart
        let recentVolumes = []; // Track recent 5-second volumes for 5m chart
        const maxVolumeHistory = 60; // Keep last 60 data points (5 minutes)

        function checkVolumeSpike() {
            if (recentVolumes.length < 10) return false; // Need some history

            // Calculate average of recent volumes (excluding current)
            const completed = recentVolumes.slice(0, -1).filter(v => v > 0);
            if (completed.length < 5) return false;

            const avgVol = completed.reduce((a, b) => a + b, 0) / completed.length;
            const currentVol = recentVolumes[recentVolumes.length - 1];

            // Spike if current volume is 1.5x or more than average
            return currentVol > 0 && currentVol >= (avgVol * 1.5);
        }

        function triggerSpikeAlert() {
            const panel = document.querySelector('.chart-panel:nth-child(3)'); // 5m chart is 3rd panel
            if (panel) {
                panel.classList.remove('spikeAlert');
                void panel.offsetWidth; // Force reflow to restart animation
                panel.classList.add('spikeAlert');
            }
        }

        function drawGauge() {
            const canvas = document.getElementById('biasGauge');
            if (!canvas) return;

            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            const ctx = canvas.getContext('2d');

            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const total = buyVolume + sellVolume;
            const target = total ? (buyVolume / total) : 0.5;
            needlePos += (target - needlePos) * 0.25;

            const g = ctx.createLinearGradient(0, 0, w, 0);
            g.addColorStop(0, '#2dd4bf');
            g.addColorStop(Math.max(0, needlePos - 0.001), '#2dd4bf');
            g.addColorStop(Math.min(1, needlePos + 0.001), '#f59e0b');
            g.addColorStop(1, '#f59e0b');

            ctx.fillStyle = g;
            ctx.fillRect(0, 0, w, h);

            const needle = document.getElementById('needle');
            if (needle) {
                needle.style.left = (needlePos * 100) + '%';
            }
        }

        // WebSocket for real-time updates
        const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');

        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'subscribe',
                product_ids: ['BTC-USD'],
                channels: ['ticker', 'matches']
            }));
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'ticker' && data.price) {
                const price = parseFloat(data.price);
                const now = Math.floor(Date.now() / 1000);

                // Update each timeframe
                Object.keys(chartConfigs).forEach(key => {
                    const pData = priceData[key];
                    const config = chartConfigs[key];

                    // Add new data point
                    if (pData.timestamps.length === 0 ||
                        now - pData.timestamps[pData.timestamps.length - 1] >= config.granularity) {
                        pData.timestamps.push(now);
                        pData.prices.push(price);
                        pData.volumes.push(0);

                        // Keep only the required number of points
                        if (pData.timestamps.length > config.points) {
                            pData.timestamps.shift();
                            pData.prices.shift();
                            pData.volumes.shift();
                        }

                        updateChart(key);
                        updateStats(key);
                    }
                });
            }

            // Handle match data for bias gauge and volume spike detection
            if (data.type === 'match') {
                const size = parseFloat(data.size);
                if (data.side === 'buy') {
                    buyVolume += size;
                } else {
                    sellVolume += size;
                }
                drawGauge();
            }
        };

        // Wait for window to fully load before initializing
        window.addEventListener('load', () => {
            // Delay to let Lovelace iframe size properly
            setTimeout(() => {
                // Force chart resize
                Object.keys(charts).forEach(key => {
                    charts[key].resize();
                });

                // Initialize with historical data
                Object.keys(chartConfigs).forEach(key => {
                    fetchHistoricalData(key);
                });
            }, 500);
        });

        // Refresh historical data periodically
        setInterval(() => {
            Object.keys(chartConfigs).forEach(key => {
                fetchHistoricalData(key);
            });
        }, 60000); // Refresh every minute

        // Track volume and decay for gauge + spike detection
        setInterval(() => {
            // Track total volume for this 5-second period for 5m chart spike detection
            const totalVolume = buyVolume + sellVolume;
            recentVolumes.push(totalVolume);

            // Keep only last 60 data points (5 minutes)
            if (recentVolumes.length > maxVolumeHistory) {
                recentVolumes.shift();
            }

            // Check for volume spike and trigger alert
            if (checkVolumeSpike()) {
                triggerSpikeAlert();
            }

            // Decay volume for gauge
            buyVolume *= 0.8;
            sellVolume *= 0.8;
            drawGauge();
        }, 5000);
    </script>
</body>
</html>
