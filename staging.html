<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Live BTC/USD</title>
  <style>
    :root {
      --bg:#0a0a0a; --panel:#101010; --text:#e9fef7;
      --up:#00ffb3; --down:#ff3c3c; --glow: rgba(0,255,179,0.25); --muted:#c8d6cf;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
    }

    /* ===== Layout ===== */
    .site { display:block; padding:10px; }
    .desktop-only{ display:none; }
    .mobile-only{ display:block; }

    /* Desktop grid only at >=1024px */
    @media (min-width:1024px){
      .site{
        display:grid !important;
        grid-template-columns: 1.4fr 1.6fr 1fr; /* LEFT charts | CENTER analytics | RIGHT feed */
        gap:16px;
        padding:16px;
        align-items:start;
      }
      .sticky{ position:sticky; top:0; }
      .desktop-only{ display:block !important; }
      .mobile-only{ display:none !important; }
    }

    /* Cards */
    .card{
      background:var(--panel);
      border-radius:12px;
      box-shadow:0 0 0 1px rgba(255,255,255,.04),0 10px 30px rgba(0,0,0,.35);
    }

    /* ===== Header (works for mobile + desktop) ===== */
    .centerbar{
      position:sticky;top:0;z-index:10;width:100%;
      background:linear-gradient(180deg,rgba(10,10,10,.95),rgba(10,10,10,.7));
      backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
      padding:calc(8px + env(safe-area-inset-top)) 14px 8px 14px;
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;flex-wrap:wrap;gap:12px;align-items:baseline;justify-content:center;
      font-variant-numeric:tabular-nums;
    }
    .price{font-size:clamp(22px,7vw,40px);font-weight:800;line-height:1;transition:color .25s ease;color:#fff;text-shadow:0 0 18px rgba(0,0,0,.35);}
    .price.up{color:var(--up)} .price.down{color:var(--down)}
    .change{font-size:clamp(12px,3.2vw,16px);font-weight:700;opacity:.9;transition:color .25s ease;}
    .change.up{color:var(--up)} .change.down{color:var(--down)} .change.flat{color:var(--muted)}
    @keyframes changeFlash{0%{opacity:.4;transform:scale(.985)}60%{opacity:1;transform:scale(1)}100%{opacity:.95;transform:scale(1)}}
    .change.flash{animation:changeFlash 450ms ease-out;}

    .pill{border:1px solid rgba(255,255,255,0.12);border-radius:999px;padding:2px 8px;font-size:12px;opacity:.9}
    .pillRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

    /* Connection pill (inline, hidden by default) */
    .conn{margin-left:12px;font-size:12px;border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:2px 8px;opacity:.9;display:none}
    .conn.bad{color:#ffadad;border-color:#ffadad}
    .conn.ok{color:#9affd9;border-color:#9affd9}

    /* Floating connection notice (mobile & desktop) */
    #connNotice{
      position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
      background:rgba(20,20,20,.96);color:#ffd5a1;border:1px solid rgba(255,211,150,.25);
      padding:8px 12px;border-radius:999px;font-size:13px;box-shadow:0 8px 24px rgba(0,0,0,.5);
      display:none;z-index:20;
    }

    /* ===== LEFT column: live 10m + desktop charts ===== */
    #leftCol .card{ margin-bottom:12px; }
    #chartContainer{position:relative;width:min(920px,96vw);height:clamp(130px,26vh,220px);margin:0 auto;}
    #chartCanvas{position:absolute;inset:0;width:100%;height:100%;border-radius:12px;}
    @media (min-width:1024px){ #chartContainer{width:auto;} }

    /* Desktop-only per-minute volume (10m) */
    .volBoxTop{padding:12px;}
    .volTitle{font-weight:700;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center;}
    #volCanvas{width:100%;height:160px;display:block;border-radius:8px;}
    .dot{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:6px;vertical-align:middle;}
    .dot.up{background:var(--up);} .dot.down{background:var(--down);}

    .subchart{ padding:10px; }
    .subchart .title{font-weight:700;margin:0 0 6px 2px;opacity:.9;}
    .subchart canvas{width:100%;height:160px;display:block;border-radius:8px;}

    /* ===== CENTER analytics (desktop-only) ===== */
    .statsBox{padding:12px;}
    .statsTitle{font-weight:700;margin-bottom:8px;}
    .statRow{display:flex;justify-content:space-between;margin:6px 0;font-variant-numeric:tabular-nums;}
    .histBox{padding:12px;margin-top:16px;}
    #histCanvas{width:100%;height:160px;display:block;border-radius:8px;}

    /* ===== RIGHT feed ===== */
    #feedContainer{
      border-radius:12px;padding:6px;
      overflow-y:auto;-webkit-overflow-scrolling:touch;
      box-shadow:0 0 0 1px rgba(255,255,255,.04),0 10px 30px rgba(0,0,0,.35),0 0 18px var(--glow);
      background:var(--panel);
    }
    /* Mobile height like your original */
    @media (max-width:1023.98px){
      #feedContainer{ height:56vh; width:min(920px,96vw); margin:12px auto 0; }
    }
    /* Desktop sticks and stretches to 1d bottom */
    @media (min-width:1024px){
      #feedContainer{ position:sticky; top:0; height:auto; font-size:12px; line-height:1.1; }
      #feedContainer .tops{ display:none; }
    }

    .row{display:grid;grid-template-columns:82px 1fr auto;column-gap:8px;align-items:center;
      padding:3px 6px;border-radius:8px;font-size:inherit;line-height:inherit;
      font-variant-numeric:tabular-nums;text-align:left;}
    .row.buy{color:var(--up)} .row.sell{color:var(--down)}
    .time{white-space:nowrap;opacity:.85}
    .priceCell{white-space:nowrap}
    .amountCell{white-space:nowrap;opacity:.95;cursor:pointer;}
    .dir{opacity:.8;margin-left:6px}
    .headerRow{font-weight:600;text-transform:uppercase;letter-spacing:.5px;font-size:.85em;opacity:.7;
      border-bottom:1px solid rgba(255,255,255,0.08);margin-bottom:4px;padding-bottom:4px;
      display:grid;grid-template-columns:82px 1fr auto;column-gap:8px;text-align:left;}

    /* Mobile tops (unchanged from your original feel) */
    .tops{margin:2px 6px 6px;}
    .tops-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .tops h4{margin:4px 0 4px;font-size:.9em;font-weight:700;color:#fff;}
    .tops ul{list-style:none;margin:0;padding:0;}
    .tops li{padding:3px 0;border-bottom:1px dashed rgba(255,255,255,.07);font-variant-numeric:tabular-nums;}
    .tops .buy{color:var(--up)} .tops .sell{color:var(--down)} .tops .muted{color:var(--muted);opacity:.9}
    .tops-summary{
      display:flex;width:100%;
      background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08);
      border-radius:10px; padding:6px 10px; font-size:.95em;font-weight:600; color:#fff;
      cursor:pointer; align-items:center; justify-content:space-between; gap:8px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .tops-summary .vals{font-variant-numeric:tabular-nums;}
    .tops-summary .chev{opacity:.8;flex-shrink:0;}
    @media (max-width:600px){ .tops-grid{display:none;} .tops.expanded .tops-grid{display:grid;} }
    @media (min-width:1024px){ .tops-summary{display:none !important;} }
  </style>
</head>
<body>
  <!-- Floating connection notice -->
  <div id="connNotice">⚠️ Live data paused — waiting for a secure connection…</div>

  <div class="site">
    <!-- LEFT: live 10m + (desktop: volume + 1h + 1d) -->
    <div id="leftCol" class="sticky">
      <header class="centerbar card">
        <div id="livePrice" class="price">$—</div>
        <div id="liveChange" class="change flat">—</div>
        <div class="pillRow desktop-only">
          <span id="d24Change" class="pill">24h Δ —</span>
          <span id="d24HiLo" class="pill">H/L —</span>
          <span id="d24Vol" class="pill">Vol —</span>
        </div>
        <div id="connPill" class="conn bad">WS — / REST —</div>
      </header>

      <!-- Live 10m price line (mobile & desktop) -->
      <section id="chartContainer" class="card"><canvas id="chartCanvas"></canvas></section>

      <!-- Desktop-only: Per-minute volume (10m) with fixed 1m bins + labels -->
      <div class="card volBoxTop desktop-only">
        <div class="volTitle">
          <span>Per-minute volume (10m)</span>
          <span class="pill"><span class="dot up"></span> Buys &nbsp; <span class="dot down"></span> Sells</span>
        </div>
        <canvas id="volCanvas" width="400" height="160"></canvas>
      </div>

      <!-- Desktop-only: 1h / 1d charts -->
      <section class="card subchart desktop-only">
        <div class="title">1 hour (1-min candles)</div>
        <canvas id="chart1h"></canvas>
      </section>
      <section id="oneDayCard" class="card subchart desktop-only">
        <div class="title">1 day (5-min candles)</div>
        <canvas id="chart1d"></canvas>
      </section>
    </div>

    <!-- CENTER (desktop-only analytics) -->
    <section id="centerCol" class="desktop-only">
      <div class="card statsBox" style="margin:12px 0;">
        <div class="statsTitle">Last 10 minutes <span class="pill" id="statCount">—</span></div>
        <div class="statRow"><span>Trades / min</span><strong id="statTpm">—</strong></div>
        <div class="statRow"><span>Buy ratio (USD)</span><strong id="statBuyRatio">—</strong></div>
        <div class="statRow"><span>VWAP</span><strong id="statVWAP">—</strong></div>
        <div class="statRow"><span>High / Low</span><strong id="statHiLo">—</strong></div>
        <div class="statRow"><span>Range</span><strong id="statRange">—</strong></div>
        <div class="statRow"><span>Avg size (BTC)</span><strong id="statAvgSz">—</strong></div>
        <div class="statRow"><span>Median size (BTC)</span><strong id="statMedSz">—</strong></div>
        <div class="statRow"><span>Largest buy</span><strong id="statBigBuy">—</strong></div>
        <div class="statRow"><span>Largest sell</span><strong id="statBigSell">—</strong></div>
      </div>

      <div class="card statsBox" style="margin:12px 0;">
        <div class="statsTitle">Last 1 hour <span class="pill" id="statCount1h">—</span></div>
        <div class="statRow"><span>Trades / min</span><strong id="statTpm1h">—</strong></div>
        <div class="statRow"><span>Buy ratio (USD)</span><strong id="statBuyRatio1h">—</strong></div>
        <div class="statRow"><span>VWAP</span><strong id="statVWAP1h">—</strong></div>
        <div class="statRow"><span>High / Low</span><strong id="statHiLo1h">—</strong></div>
        <div class="statRow"><span>Range</span><strong id="statRange1h">—</strong></div>
        <div class="statRow"><span>Avg size (BTC)</span><strong id="statAvgSz1h">—</strong></div>
        <div class="statRow"><span>Median size (BTC)</span><strong id="statMedSz1h">—</strong></div>
        <div class="statRow"><span>Largest buy</span><strong id="statBigBuy1h">—</strong></div>
        <div class="statRow"><span>Largest sell</span><strong id="statBigSell1h">—</strong></div>
      </div>

      <div class="card histBox">
        <div class="statsTitle">Trade size histogram (10m)</div>
        <canvas id="histCanvas" width="400" height="160"></canvas>
      </div>
    </section>

    <!-- RIGHT: live ticker (mobile: same component; desktop: tall sticky) -->
    <section id="feedContainer" class="card">
      <div class="tops mobile-only" id="topsPanel">
        <button id="topsToggle" class="tops-summary" aria-expanded="false">
          <span class="vals" id="topsSummaryVals"><span class="buy">—</span> | <span class="sell">—</span></span>
          <span class="chev" id="topsChev">▼</span>
        </button>
        <div class="tops-grid" id="topsLists">
          <div><h4>Top Buys (10m)</h4><ul id="topBuys"><li class="muted">—</li></ul></div>
          <div><h4>Top Sells (10m)</h4><ul id="topSells"><li class="muted">—</li></ul></div>
        </div>
      </div>

      <div class="headerRow">
        <div>Time</div><div>Price</div>
        <div id="amountHeader" style="cursor:pointer;">Amount (USD)</div>
      </div>
      <!-- rows injected by JS -->
    </section>
  </div>

  <script>
    const $=s=>document.querySelector(s);

    /* ===== Refs ===== */
    const priceEl=$('#livePrice'),changeEl=$('#liveChange');
    const connPill=$('#connPill'), connNotice=$('#connNotice');

    const leftCol=$('#leftCol'), oneDayCard=$('#oneDayCard');
    const feedEl=$('#feedContainer'),amountHeader=$('#amountHeader');
    const topBuysEl=$('#topBuys'),topSellsEl=$('#topSells'),topsPanel=$('#topsPanel'),
          topsToggle=$('#topsToggle'),topsChev=$('#topsChev'),topsSummaryVals=$('#topsSummaryVals');

    const chartCanvas=$('#chartCanvas'),ctx=chartCanvas.getContext('2d',{desynchronized:true});
    const c1h=$('#chart1h'), c1d=$('#chart1d');
    const ctx1h=c1h?.getContext('2d',{desynchronized:true});
    const ctx1d=c1d?.getContext('2d',{desynchronized:true});

    const volCanvas=$('#volCanvas'), vctx=volCanvas?.getContext('2d',{desynchronized:true});
    const histCanvas=$('#histCanvas'), hctx=histCanvas?.getContext('2d',{desynchronized:true});

    const statCount=$('#statCount'),statTpm=$('#statTpm'),statBuyRatio=$('#statBuyRatio'),statVWAP=$('#statVWAP'),
          statHiLo=$('#statHiLo'),statRange=$('#statRange'),statAvgSz=$('#statAvgSz'),statMedSz=$('#statMedSz'),
          statBigBuy=$('#statBigBuy'),statBigSell=$('#statBigSell');

    const statCount1h=$('#statCount1h'),statTpm1h=$('#statTpm1h'),statBuyRatio1h=$('#statBuyRatio1h'),statVWAP1h=$('#statVWAP1h'),
          statHiLo1h=$('#statHiLo1h'),statRange1h=$('#statRange1h'),statAvgSz1h=$('#statAvgSz1h'),
          statMedSz1h=$('#statMedSz1h'),statBigBuy1h=$('#statBigBuy1h'),statBigSell1h=$('#statBigSell1h');

    const d24Change=$('#d24Change'), d24HiLo=$('#d24HiLo'), d24Vol=$('#d24Vol');

    /* Formatters */
    const fmtUSD=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2});
    const fmtUSD0=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0});
    const fmtUSDChange=new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2,signDisplay:'always'});
    const fmtBTC=new Intl.NumberFormat(undefined,{minimumFractionDigits:0,maximumFractionDigits:5});
    const fmtPct1=new Intl.NumberFormat(undefined,{minimumFractionDigits:1,maximumFractionDigits:1});
    const fmtPct2=new Intl.NumberFormat(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});

    /* State */
    let MAX_TRADES=50;
    const WINDOW_10M_MS=10*60*1000, WINDOW_1H_MS=60*60*1000;
    let trades=[],window10m=[],window1h=[],series=[],lastPrice=null,showUSD=true;

    const desktop=window.matchMedia('(min-width:1024px)');
    function onLayout(e){ MAX_TRADES = e.matches ? 300 : 50; }
    desktop.addEventListener('change',onLayout); onLayout(desktop);

    /* ===== Sizing + right feed align (desktop) ===== */
    function resizeCanvas(){
      const dpr=Math.max(1,Math.min(window.devicePixelRatio||1,3));
      chartCanvas.width=chartCanvas.clientWidth*dpr; chartCanvas.height=chartCanvas.clientHeight*dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0); drawChart();

      if(ctx1h && c1h){ c1h.width=c1h.clientWidth*dpr; c1h.height=c1h.clientHeight*dpr; ctx1h.setTransform(dpr,0,0,dpr,0,0); drawSubchart(ctx1h, data1h); }
      if(ctx1d && c1d){ c1d.width=c1d.clientWidth*dpr; c1d.height=c1d.clientHeight*dpr; ctx1d.setTransform(dpr,0,0,dpr,0,0); drawSubchart(ctx1d, data1d); }

      if(vctx && volCanvas){ volCanvas.width=volCanvas.clientWidth*dpr; volCanvas.height=volCanvas.clientHeight*dpr; vctx.setTransform(dpr,0,0,dpr,0,0); drawVolumeBars(); }
      if(hctx && histCanvas){ histCanvas.width=histCanvas.clientWidth*dpr; histCanvas.height=histCanvas.clientHeight*dpr; hctx.setTransform(dpr,0,0,dpr,0,0); drawHistogram(); }

      alignRightFeedHeight();
    }
    function alignRightFeedHeight(){
      if(!desktop.matches || !oneDayCard) return;
      const topOffset = feedEl.getBoundingClientRect().top + window.scrollY;
      const leftBottom = oneDayCard.getBoundingClientRect().bottom + window.scrollY;
      const target = Math.max(220, leftBottom - topOffset);
      feedEl.style.height = target + 'px';
    }
    new ResizeObserver(resizeCanvas).observe(document.body);
    window.addEventListener('scroll', alignRightFeedHeight, {passive:true});

    /* ===== WS + REST + notices ===== */
    let ws=null, reconnectTimer=null, firstMsgTimer=null, gotMessage=false;
    let lastWsMsgAt = 0, lastRestAt = 0, pillShown=false;

    function toggleConnNotice(show){
      connNotice.style.display = show ? 'block' : 'none';
    }
    function setConnPill(txt, ok){
      connPill.textContent = txt;
      connPill.className = 'conn ' + (ok?'ok':'bad');
      const now = Date.now();
      const silentFor = now - Math.max(lastWsMsgAt,lastRestAt);
      const shouldShow = !ok && silentFor >= 3000;
      if(shouldShow && !pillShown){ connPill.style.display='inline-block'; pillShown=true; }
      if(ok && pillShown){ connPill.style.display='none'; pillShown=false; }
      toggleConnNotice(shouldShow);  // floating banner mirrors the same logic
    }

    function connectSequence(){ connectWS("advanced"); }
    function connectWS(kind){
      clearTimeout(reconnectTimer); clearTimeout(firstMsgTimer);
      if(ws){ try{ ws.close(); }catch(e){} ws=null; }
      const url = kind==="advanced" ? "wss://advanced-trade-ws.coinbase.com"
                                    : "wss://ws-feed.exchange.coinbase.com";
      ws = new WebSocket(url);
      ws.onopen = () => {
        gotMessage=false;
        if(kind==="advanced"){
          ws.send(JSON.stringify({ type:"subscribe", channel:"market_trades", product_ids:["BTC-USD"] }));
        }else{
          ws.send(JSON.stringify({ type:"subscribe", product_ids:["BTC-USD"], channels:["matches"] }));
        }
        firstMsgTimer = setTimeout(()=>{
          if(!gotMessage && kind==="advanced"){ try{ ws.close(); }catch(e){} connectWS("legacy"); }
        }, 5000);
      };
      ws.onmessage = (e) => {
        gotMessage=true; lastWsMsgAt = Date.now();
        try{
          const msg = JSON.parse(e.data);
          if(msg.channel==="market_trades" && Array.isArray(msg.events)){
            for(const ev of msg.events){
              if(ev.type==="update" && Array.isArray(ev.trades)){
                for(const tr of ev.trades){
                  onTrade({ price:+tr.price, size:+tr.size, side:String(tr.side||"").toLowerCase(), time:new Date(ev.timestamp||tr.time||Date.now()) });
                }
              }
            }
            return;
          }
          if(msg.type==="match" && msg.product_id==="BTC-USD"){
            onTrade({ price:+msg.price, size:+msg.size, side:String(msg.side||"").toLowerCase(), time:new Date(msg.time||Date.now()) });
            return;
          }
        }catch(_){}
      };
      ws.onclose = () => { clearTimeout(firstMsgTimer); reconnectTimer=setTimeout(connectSequence, 1000); };
      ws.onerror = () => { try{ ws.close(); }catch(e){} };
    }

    async function pollTradesFallback(){
      const QUIET_MS = 3500;
      const now = Date.now();
      try{
        if(now - lastWsMsgAt >= QUIET_MS){
          const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/trades?limit=20',{headers:{'Accept':'application/json'}});
          if(r.ok){
            const arr = await r.json();
            for(let i=arr.length-1;i>=0;i--){
              const t = arr[i];
              onTrade({ price:+t.price, size:+t.size, side:String(t.side||"").toLowerCase(), time:new Date(t.time||now) });
            }
            lastRestAt = now; setConnPill('WS — / REST ✓', true);
            return;
          }
        }
        if(now - Math.max(lastWsMsgAt,lastRestAt) >= QUIET_MS){
          const r2 = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/ticker',{headers:{'Accept':'application/json'}});
          if(r2.ok){
            const t = await r2.json();
            onTrade({ price:+t.price, size:+(t.size||0.001), side:'buy', time:new Date(t.time||now) });
            lastRestAt = now; setConnPill('WS — / REST ✓', true);
            return;
          }
        }
        setConnPill('WS — / REST —', false);
      }catch(_){ setConnPill('WS — / REST —', false); }
    }
    setInterval(pollTradesFallback, 1200);

    /* ===== Trade handling & UI ===== */
    let needsFeedRender=false, pendingPriceForSeries=null;
    function onTrade(t){
      const p=t.price, s=t.size, side=t.side==='sell'?'sell':'buy', time=t.time;
      const prev=trades.length?trades[trades.length-1].price:lastPrice;
      const arrow = (prev!=null) ? (p>prev?'▲':p<prev?'▼':'•') : '';

      setConnPill('WS ✓ / REST ✓', true);
      toggleConnNotice(false);

      if(lastPrice!==null){
        priceEl.classList.remove('up','down');
        if(p>lastPrice) priceEl.classList.add('up'); else if(p<lastPrice) priceEl.classList.add('down');
      }
      lastPrice=p; priceEl.textContent = fmtUSD.format(p);

      trades.push({price:p,size:s,time,side,arrow});
      if(trades.length>MAX_TRADES) trades.shift();

      const epoch=time.getTime();
      window10m.push({price:p,size:s,side,time:epoch});
      window1h.push({price:p,size:s,side,time:epoch});
      pendingPriceForSeries=p; needsFeedRender=true;
    }

    function pruneWindows(){
      const cutoff10=Date.now()-WINDOW_10M_MS;
      const cutoff1h=Date.now()-WINDOW_1H_MS;
      window10m=window10m.filter(t=>t.time>=cutoff10);
      window1h=window1h.filter(t=>t.time>=cutoff1h);
    }

    function renderFeed(){
      const headers=Array.from(feedEl.children).slice(0,2);
      const frag=document.createDocumentFragment(); headers.forEach(n=>frag.appendChild(n));
      for(let i=trades.length-1;i>=0;i--){
        const t=trades[i],row=document.createElement('div');
        row.className=`row ${t.side}`;
        const ts=t.time.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit',second:'2-digit'});
        const amt=showUSD?fmtUSD.format(t.price*t.size):`${fmtBTC.format(t.size)} BTC`;
        row.innerHTML=`<div class="time">${ts}</div><div class="priceCell">${fmtUSD.format(t.price)} <span class="dir">${t.arrow}</span></div><div class="amountCell">${amt}</div>`;
        row.querySelector('.amountCell').addEventListener('click',toggleAmountView);
        frag.appendChild(row);
      }
      feedEl.innerHTML=''; feedEl.appendChild(frag);
    }

    function computeWindow(arr, minutes){
      const count=arr.length;
      const volBtc=arr.reduce((a,t)=>a+t.size,0);
      const volUsd=arr.reduce((a,t)=>a+t.size*t.price,0);
      let buyUsd=0, sellUsd=0, buyMax=0, sellMax=0, hi=-Infinity, lo=Infinity;
      for(const t of arr){
        const usd=t.price*t.size;
        hi=Math.max(hi, t.price); lo=Math.min(lo, t.price);
        if(t.side==='buy'){ buyUsd+=usd; buyMax=Math.max(buyMax,usd); }
        else { sellUsd+=usd; sellMax=Math.max(sellMax,usd); }
      }
      const vwap = volBtc ? (arr.reduce((a,t)=>a+t.price*t.size,0)/volBtc) : NaN;
      const rangeUsd = isFinite(hi) && isFinite(lo) ? (hi - lo) : NaN;
      const rangePct = isFinite(hi) && isFinite(lo) && lo>0 ? ((hi/lo - 1)*100) : NaN;
      const avgSz = count ? (volBtc / count) : NaN;
      const medSz = count ? medianSize(arr) : NaN;
      return {count, volUsd, buyUsd, sellUsd, buyMax, sellMax, vwap, hi:(hi===-Infinity?NaN:hi),
              lo:(lo===Infinity?NaN:lo), rangeUsd, rangePct, avgSz, medSz, tpm:(count/minutes)};
    }

    function renderStats(){
      pruneWindows();

      // 10 minutes (desktop-only nodes exist there)
      if(statCount){
        const S=computeWindow(window10m, 10);
        statCount.textContent = `${S.count} trades`;
        statTpm.textContent = S.tpm.toFixed(1);
        statBuyRatio.textContent = `${fmtPct1.format(S.volUsd ? (S.buyUsd/S.volUsd*100) : 0)}%`;
        statVWAP.textContent = isFinite(S.vwap) ? fmtUSD.format(S.vwap) : '—';
        statHiLo.textContent = (isFinite(S.hi)&&isFinite(S.lo)) ? `${fmtUSD.format(S.hi)} / ${fmtUSD.format(S.lo)}` : '—';
        statRange.textContent = (isFinite(S.rangeUsd)&&isFinite(S.rangePct)) ? `${fmtUSD0.format(S.rangeUsd)} (${fmtPct1.format(S.rangePct)}%)` : '—';
        statAvgSz.textContent = isFinite(S.avgSz) ? S.avgSz.toLocaleString(undefined,{maximumFractionDigits:4}) : '—';
        statMedSz.textContent = isFinite(S.medSz) ? S.medSz.toLocaleString(undefined,{maximumFractionDigits:4}) : '—';
        statBigBuy.textContent = S.buyMax? fmtUSD0.format(S.buyMax) : '—';
        statBigSell.textContent = S.sellMax? fmtUSD0.format(S.sellMax) : '—';
      }

      // 1 hour
      if(statCount1h){
        const H=computeWindow(window1h, 60);
        statCount1h.textContent = `${H.count} trades`;
        statTpm1h.textContent = H.tpm.toFixed(1);
        statBuyRatio1h.textContent = `${fmtPct1.format(H.volUsd ? (H.buyUsd/H.volUsd*100) : 0)}%`;
        statVWAP1h.textContent = isFinite(H.vwap) ? fmtUSD.format(H.vwap) : '—';
        statHiLo1h.textContent = (isFinite(H.hi)&&isFinite(H.lo)) ? `${fmtUSD.format(H.hi)} / ${fmtUSD.format(H.lo)}` : '—';
        statRange1h.textContent = (isFinite(H.rangeUsd)&&isFinite(H.rangePct)) ? `${fmtUSD0.format(H.rangeUsd)} (${fmtPct1.format(H.rangePct)}%)` : '—';
        statAvgSz1h.textContent = isFinite(H.avgSz) ? H.avgSz.toLocaleString(undefined,{maximumFractionDigits:4}) : '—';
        statMedSz1h.textContent = isFinite(H.medSz) ? H.medSz.toLocaleString(undefined,{maximumFractionDigits:4}) : '—';
        statBigBuy1h.textContent = H.buyMax? fmtUSD0.format(H.buyMax) : '—';
        statBigSell1h.textContent = H.sellMax? fmtUSD0.format(H.sellMax) : '—';
      }
    }

    function medianSize(arr){
      const sizes = arr.map(t=>t.size).sort((a,b)=>a-b);
      const n = sizes.length; if(!n) return NaN;
      return n%2 ? sizes[(n-1)/2] : (sizes[n/2-1]+sizes[n/2])/2;
    }

    /* ===== Volume (10m) — fixed 1-minute bins, labeled ===== */
    function minuteAlignedStart(){
      const now = Date.now();
      const minuteStart = now - (now % 60000);
      return minuteStart - (9 * 60000);
    }
    function minuteBuckets(){
      const start = minuteAlignedStart();
      const bins = Array.from({length:10}, (_,i)=>({buyUsd:0,sellUsd:0, ts: start + i*60000}));
      for(const t of window10m){
        if(t.time < start-1 || t.time >= start + 10*60000) continue;
        const idx = Math.min(9, Math.max(0, Math.floor((t.time - start)/60000)));
        const usd = t.price*t.size;
        if(t.side==='buy') bins[idx].buyUsd += usd; else bins[idx].sellUsd += usd;
      }
      return bins;
    }
    function drawVolumeBars(){
      if(!vctx || !volCanvas) return;
      const w=volCanvas.clientWidth, h=volCanvas.clientHeight;
      vctx.clearRect(0,0,w,h);
      const bins = minuteBuckets();
      const max = Math.max(1, ...bins.map(b=>b.buyUsd + b.sellUsd));
      const padX = 28, padYTop=8, padYBot=22;
      const chartH = h - padYTop - padYBot;
      const barW = (w - padX*2) / bins.length * 0.7;
      const step = (w - padX*2) / bins.length;

      const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim() || '#00ffb3';
      const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim() || '#ff3c3c';

      vctx.strokeStyle='rgba(255,255,255,0.06)'; vctx.lineWidth=1;
      for(let i=1;i<=3;i++){
        const y = padYTop + chartH*(i/4* (4/3));
        vctx.beginPath(); vctx.moveTo(padX-6, y); vctx.lineTo(w-padX+6, y); vctx.stroke();
      }

      vctx.font='11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      vctx.textAlign='center'; vctx.textBaseline='top';
      vctx.fillStyle='rgba(255,255,255,0.75)';

      for(let i=bins.length-1;i>=0;i--){
        const b=bins[i];
        const xCenter = w - padX - ((bins.length-1-i)*step) - step/2;
        const total = b.buyUsd + b.sellUsd;
        const hTotal = (total/max)*chartH;
        const hBuy = total ? (b.buyUsd/total)*hTotal : 0;
        const hSell = hTotal - hBuy;
        const yBase = padYTop + chartH;

        vctx.fillStyle = dn; vctx.fillRect(xCenter - barW/2, yBase - hSell, barW, hSell);
        vctx.fillStyle = up; vctx.fillRect(xCenter - barW/2, yBase - hSell - hBuy, barW, hBuy);

        const d = new Date(b.ts);
        const mm = d.toLocaleTimeString([], {minute:'2-digit'});
        if((i%2)===1) vctx.fillText(':'+mm, xCenter, yBase + 4);
      }

      vctx.textAlign='right'; vctx.textBaseline='alphabetic'; vctx.fillStyle='rgba(255,255,255,0.8)';
      const maxLab = new Intl.NumberFormat(undefined,{notation:'compact',maximumFractionDigits:1}).format(max);
      vctx.fillText(`max ${maxLab}`, w - 6, padYTop + 10);
    }

    /* ===== Histogram (10m) (desktop) ===== */
    const BINS = [
      {label:"<0.01", lo:0,    hi:0.01},
      {label:"0.01–0.05", lo:0.01, hi:0.05},
      {label:"0.05–0.1", lo:0.05, hi:0.1},
      {label:"0.1–0.5",  lo:0.1,  hi:0.5},
      {label:"0.5–1",    lo:0.5,  hi:1},
      {label:"1–3",      lo:1,    hi:3},
      {label:"3–10",     lo:3,    hi:10},
      {label:">10",      lo:10,   hi:Infinity},
    ];
    function histogramBuckets(){
      const buys = new Array(BINS.length).fill(0);
      const sells= new Array(BINS.length).fill(0);
      for(const t of window10m){
        const sz = t.size;
        for(let i=0;i<BINS.length;i++){
          const b=BINS[i];
          if(sz>=b.lo && sz<b.hi){
            const usd = t.price*sz;
            if(t.side==='buy') buys[i]+=usd; else sells[i]+=usd;
            break;
          }
        }
      }
      return {buys,sells};
    }
    function drawHistogram(){
      if(!hctx || !histCanvas) return;
      const w=histCanvas.clientWidth, h=histCanvas.clientHeight;
      hctx.clearRect(0,0,w,h);
      const {buys,sells} = histogramBuckets();
      const totals = buys.map((v,i)=>v + sells[i]);
      const max = Math.max(1, ...totals);
      const pad=12, barH=(h - pad*2)/BINS.length * 0.7, step=(h - pad*2)/BINS.length;

      const up = getComputedStyle(document.documentElement).getPropertyValue('--up').trim() || '#00ffb3';
      const dn = getComputedStyle(document.documentElement).getPropertyValue('--down').trim() || '#ff3c3c';

      hctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      hctx.textBaseline = 'middle';
      hctx.fillStyle = 'rgba(255,255,255,0.8)';

      BINS.forEach((b, i)=>{
        const y = pad + i*step + (step - barH)/2;
        hctx.fillText(b.label, 6, y + barH/2);

        const total = totals[i];
        const fullW = (total/max) * (w - 100);
        const x0 = 100;

        const sellW = total ? (sells[i]/total)*fullW : 0;
        hctx.fillStyle = dn; hctx.fillRect(x0, y, sellW, barH);

        const buyW = fullW - sellW;
        hctx.fillStyle = up; hctx.fillRect(x0 + sellW, y, buyW, barH);
      });
    }

    /* ===== 10m live line ===== */
    function drawChart(){
      const w=chartCanvas.clientWidth,h=chartCanvas.clientHeight;
      ctx.clearRect(0,0,w,h);ctx.fillStyle='#101010';ctx.fillRect(0,0,w,h);
      if(series.length<2)return;
      let min=Infinity,max=-Infinity,sum=0;
      for(const s of series){const p=s.p;if(p<min)min=p;if(p>max)max=p;sum+=p;}
      const range=(max-min)||1,avg=sum/series.length;
      ctx.strokeStyle='rgba(255,255,255,0.06)';ctx.lineWidth=1;
      for(let i=1;i<6;i++){const gy=(h/6)*i;ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(w,gy);ctx.stroke();}
      const yAvg=h-((avg-min)/range)*h;
      ctx.save();ctx.setLineDash([6,6]);ctx.strokeStyle='rgba(200,214,207,0.6)';
      ctx.beginPath();ctx.moveTo(0,yAvg);ctx.lineTo(w,yAvg);ctx.stroke();ctx.restore();
      ctx.lineWidth=2;
      for(let i=1;i<series.length;i++){
        const p0=series[i-1].p,p1=series[i].p;
        const x0=((i-1)/(series.length-1))*w,x1=(i/(series.length-1))*w;
        const y0=h-((p0-min)/range)*h,y1=h-((p1-min)/range)*h;
        ctx.strokeStyle=(p1>=avg)?'#00ffb3':'#ff3c3c';
        ctx.beginPath();ctx.moveTo(x0,y0);ctx.lineTo(x1,y1);ctx.stroke();
      }
    }

    function updateTenMinuteChange(){
      const cutoff=Date.now()-WINDOW_10M_MS;
      while(series.length&&series[0].t<cutoff)series.shift();
      if(series.length<2){changeEl.textContent='—';changeEl.className='change flat';return;}
      const start=series[0].p,now=series[series.length-1].p,diff=now-start,pct=((now-start)/start)*100;
      const cls=diff>0?'up':diff<0?'down':'flat';
      changeEl.textContent=`${fmtUSDChange.format(diff)} (${fmtPct2.format(pct)}%)`;
      changeEl.className=`change ${cls}`;
      void changeEl.offsetWidth;changeEl.classList.add('flash');
    }

    /* ===== 24h stats (desktop header pills) ===== */
    async function fetch24h(){
      try{
        const r = await fetch('https://api.exchange.coinbase.com/products/BTC-USD/stats', {headers:{'Accept':'application/json'}});
        if(!r.ok) throw new Error('bad status');
        const j = await r.json();
        const open = +j.open, last = +j.last, high = +j.high, low = +j.low, vol = +j.volume;
        if(Number.isFinite(open) && Number.isFinite(last)){
          const diff = last - open;
          const pct = open ? (diff/open*100) : 0;
          d24Change.textContent = `24h Δ ${fmtUSDChange.format(diff)} (${fmtPct2.format(pct)}%)`;
          d24Change.style.color = diff>0 ? 'var(--up)' : (diff<0 ? 'var(--down)' : 'var(--muted)');
        }else{
          d24Change.textContent = '24h Δ —'; d24Change.style.color='var(--muted)';
        }
        d24HiLo.textContent = (Number.isFinite(high)&&Number.isFinite(low)) ? `H/L ${fmtUSD0.format(high)} / ${fmtUSD0.format(low)}` : 'H/L —';
        d24Vol.textContent = Number.isFinite(vol) ? `Vol ${vol.toLocaleString(undefined,{maximumFractionDigits:0})}` : 'Vol —';
      }catch(e){
        if(d24Change){ d24Change.textContent='24h Δ —'; d24Change.style.color='var(--muted)'; }
        if(d24HiLo) d24HiLo.textContent='H/L —';
        if(d24Vol) d24Vol.textContent='Vol —';
      }
    }

    /* ===== Candles (desktop) ===== */
    let data1h = []; // [{t,c}]
    let data1d = []; // [{t,c}]
    function iso(ms){ return new Date(ms).toISOString(); }
    async function fetchCandles(secsBack, granularity){
      const end = Date.now();
      const start = end - secsBack*1000;
      const url = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=${granularity}&start=${encodeURIComponent(iso(start))}&end=${encodeURIComponent(iso(end))}`;
      const r = await fetch(url, {headers:{'Accept':'application/json'}});
      if(!r.ok) throw new Error('bad status');
      const arr = await r.json();
      return arr.sort((a,b)=>a[0]-b[0]).map(x=>({t:x[0]*1000, c:+x[4]}));
    }
    async function refreshSubcharts(){
      try{ if(ctx1h) data1h = await fetchCandles(60*60, 60); }catch(_){}
      try{ if(ctx1d) data1d = await fetchCandles(24*60*60, 300); }catch(_){}
      if(ctx1h) drawSubchart(ctx1h, data1h);
      if(ctx1d) drawSubchart(ctx1d, data1d);
      alignRightFeedHeight();
    }
    function drawSubchart(context, seriesIn){
      if(!context) return;
      const canvas = context.canvas;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      context.clearRect(0,0,w,h);
      context.fillStyle = '#101010'; context.fillRect(0,0,w,h);
      if(!seriesIn || seriesIn.length<2) return;

      const min = Math.min(...seriesIn.map(d=>d.c));
      const max = Math.max(...seriesIn.map(d=>d.c));
      const range = (max-min)||1;
      const avg = seriesIn.reduce((a,d)=>a+d.c,0)/seriesIn.length;

      context.strokeStyle = 'rgba(255,255,255,0.06)'; context.lineWidth = 1;
      for(let i=1;i<=4;i++){ const y=(h/5)*i; context.beginPath(); context.moveTo(0,y); context.lineTo(w,y); context.stroke(); }

      const yAvg = h - ((avg-min)/range)*h;
      context.save(); context.setLineDash([6,6]); context.strokeStyle='rgba(200,214,207,0.6)';
      context.beginPath(); context.moveTo(0,yAvg); context.lineTo(w,yAvg); context.stroke(); context.restore();

      context.lineWidth = 2;
      for(let i=1;i<seriesIn.length;i++){
        const p0=seriesIn[i-1].c, p1=seriesIn[i].c;
        const x0=((i-1)/(seriesIn.length-1))*w, x1=((i)/(seriesIn.length-1))*w;
        const y0=h-((p0-min)/range)*h, y1=h-((p1-min)/range)*h;
        context.strokeStyle = (p1>=avg)?'#00ffb3':'#ff3c3c';
        context.beginPath(); context.moveTo(x0,y0); context.lineTo(x1,y1); context.stroke();
      }

      const lab = (v)=> new Intl.NumberFormat(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0}).format(v);
      context.fillStyle = 'rgba(255,255,255,0.75)';
      context.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      context.textBaseline = 'middle';
      context.fillText(lab(max), 6, 10);
      context.fillText(lab(avg), 6, Math.max(14, Math.min(h-14, yAvg)));
      context.fillText(lab(min), 6, h-10);
    }

    /* ===== Loop ===== */
    function loop(){
      if(pendingPriceForSeries!=null){series.push({t:Date.now(),p:pendingPriceForSeries});pendingPriceForSeries=null;}
      const cutoff=Date.now()-WINDOW_10M_MS;
      while(series.length&&series[0].t<cutoff)series.shift();

      renderStats(); drawChart(); drawVolumeBars(); drawHistogram(); updateTenMinuteChange(); renderTops();
      if(needsFeedRender){needsFeedRender=false;renderFeed();}
      requestAnimationFrame(loop);
    }

    function renderTops(){
      const buys=window10m.filter(t=>t.side==='buy').map(t=>({...t,usd:t.price*t.size})).sort((a,b)=>b.usd-a.usd).slice(0,3);
      const sells=window10m.filter(t=>t.side==='sell').map(t=>({...t,usd:t.price*t.size})).sort((a,b)=>b.usd-a.usd).slice(0,3);
      const fmtAmt=t=>showUSD?fmtUSD.format(t.usd):`${fmtBTC.format(t.size)} BTC`;
      if(topBuysEl) topBuysEl.innerHTML=buys.length?buys.map(t=>`<li class="buy">${fmtAmt(t)}</li>`).join(''):`<li class="muted">—</li>`;
      if(topSellsEl) topSellsEl.innerHTML=sells.length?sells.map(t=>`<li class="sell">${fmtAmt(t)}</li>`).join(''):`<li class="muted">—</li>`;
      if(topsSummaryVals){
        const topBuy=buys[0]?`<span class="buy">${fmtAmt(buys[0])}</span>`:'<span class="buy">—</span>';
        const topSell=sells[0]?`<span class="sell">${fmtAmt(sells[0])}</span>`:'<span class="sell">—</span>';
        topsSummaryVals.innerHTML=`${topBuy} | ${topSell}`;
      }
    }

    function toggleAmountView(){
      showUSD=!showUSD;
      amountHeader.textContent=showUSD?'Amount (USD)':'Amount (BTC)';
      renderFeed();renderTops();renderStats();drawHistogram();
    }
    amountHeader.addEventListener('click',toggleAmountView);
    topsToggle?.addEventListener('click',()=>{
      const exp=topsPanel.classList.toggle('expanded');
      topsToggle.setAttribute('aria-expanded',exp?'true':'false');
      topsChev.textContent=exp?'▲':'▼';
    });

    /* Kickoff */
    resizeCanvas();
    connectSequence();
    refreshSubcharts();
    fetch24h();
    requestAnimationFrame(loop);
    setInterval(fetch24h, 60000);
    setInterval(refreshSubcharts, 60000);
  </script>
</body>
</html>
